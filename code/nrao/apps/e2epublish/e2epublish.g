# e2epublish: Publish results for pipeline processing
#
#   Copyright (C) 1996,1997,1998,1999,2000,2001,2002
#   Associated Universities, Inc. Washington DC, USA.
#
#   This program is free software; you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the Free
#   Software Foundation; either version 2 of the License, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful, but WITHOUT
#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#   more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   675 Massachusetts Ave, Cambridge, MA 02139, USA.
#
#   Correspondence concerning AIPS++ should be addressed as follows:
#          Internet email: aips2-request@nrao.edu.
#          Postal address: AIPS++ Project Office
#                          National Radio Astronomy Observatory
#                          520 Edgemont Road
#                          Charlottesville, VA 22903-2475 USA
#
#   $Id: e2epublish.g,v 19.0 2003/07/16 03:45:02 aips2adm Exp $
#

pragma include once;

e2epublish := function(what, type='project', telescope='VLA', version='') {

  public := [=];
  private := [=];

  private.what := what;

  if(type=='tape') {
    private.root := spaste('/users/e2emgr/archive/results/telescopes/', telescope, '/tapes/', what) ~ s!//!/!g;
    if(has_field(environ, 'E2EROOT')) {
      private.root  := spaste(environ.E2EROOT, '/archive/results/telescopes/', telescope, '/tapes/', what) ~ s!//!/!g;
    }
  }
  else {
    private.root := '/users/e2emgr/e2e/archive/results/projects/';
    if(has_field(environ, 'E2EROOT')) {
      private.root  := spaste(environ.E2EROOT, '/archive/results/projects/');
    }
  }

  private.haveviewer := have_gui();

  private.tables := [=];
  include 'table.g';
#
# Write header for html
#
  private.writehtmlheader := function(f, title) {
    wider private;
    fprintf (f, '%s\n', '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">');
    fprintf (f, '%s\n', '<html>');
    fprintf (f, '%s\n', '  <head>');
    fprintf (f, '%s\n', spaste('    <title>',title,'</title>'));
    fprintf (f, '%s\n', '  </head>');
    fprintf (f, '%s\n', '  <body>');
    fprintf (f, '%s\n', spaste('    <h1><b>',title,'</b></h1>'));
    return T;
  }

  private.writehtmllink := function(f, text, lnk) {
    wider private;
    fprintf(f, '%s\n', spaste('<p><a href=\"', lnk, '\">', text, '</a></p>'));
  }

  private.writehtmlline := function(f, text='') {
    wider private;
    fprintf(f, '%s\n', text);
  }

  private.writehtmlimage := function(f, text, imagename) {
    wider private;
    fprintf(f, '%s\n', spaste('<p>', text, '</p><img src=\"', imagename, '\"></p>'));;
  }

  private.writehtmlfooter := function(f) {
    wider private;
    fprintf (f, '%s\n', '    <hr>');
    include 'sysinfo.g';
    sysinfo().version(formatted=sys)
    fprintf (f, '%s\n', spaste('    <p><i>This page was generated by the <a href="http://www.nrao.edu/e2e">e2e project</a> using the <a href="http://aips2.nrao.edu">AIPS++</a> package, version ', sys, '. Please send comments to:<a href="mailto:e2emgr@nrao.edu"> e2e Manager</a></i>'));
    fprintf (f, '%s\n', spaste('    <p><i>Generated by ', environ.USER, ' at ', dms.timetostring(time()), '</i></p>'));
    fprintf (f, '%s\n', spaste('    <p><i>Generated by makefile versions ', version, '</i></p>'));
    fprintf (f, '%s\n', '  </body>');
    fprintf (f, '%s\n', '</html>');
    return T;
  }
#
  public.publishimage := function(what, source, imfile) {
    wider private, public;
    include 'os.g';
    basename := dos.basename(imfile);
    include 'image.g';
    im := image(imfile);
    if(is_fail(im)) fail;
    include 'catalog.g';
    fitsname := spaste(private.root, '/', basename, '.fits');
    dc.delete(fitsname, confirm=F);
    im.tofits(fitsname);
    note('Publishing image ', imfile, ' to ', fitsname);
    f:=open(spaste('> ', private.root, '/', basename, '.html'));
    private.writehtmlheader(f, spaste('End-to-end processing results for ', type, ' : ',
				      private.what),
				      ',  source : ', source);
    private.writehtmllink(f, spaste('Generated as part of ', type, ' : ', private.what), spaste(private.what, '.html'));

    hdr := [=];
    im.summary(hdr);
    stat := [=];
    for (i in 1:hdr.shape[3]) {
      reg := drm.box([1,1,i,1],[hdr.shape[1], hdr.shape[2], i, 1]);
      stat[i] := [=];
      im.statistics(stat[i], robust=T, region=reg);
    }
    im.done();
#
# Now write jpg's if we can
#
    if(private.haveviewer) {
      include 'e2edisplayutils.g';
      q:=e2edisplayutils(imfile);
      if(!is_fail(q)) {
	q.label(paste(imfile));
	q.colormap();
	q.setoption('wedge', 'right');
	q.writeps(spaste(private.root, '/', basename, '.ps'));
	ichan := 1;
	if(hdr::shape[4]>1) ichan := hdr::shape[4]/2 + 1;
	zoom:=drm.box([max(1, stat[1].maxpos[1]-hdr.shape[1]/20), max(1, stat[1].maxpos[2]-hdr.shape[2]/20), 1, ichan],
		      [min(hdr.shape[1], stat[1].maxpos[1]+hdr.shape[1]/20), min(hdr.shape[2], stat[1].maxpos[2]+hdr.shape[2]/20), 1, ichan]); 
	q.region(zoom);
	q.writeps(spaste(private.root, '/', basename, '.zoom.ps'));
	q.done();
	shell('convert ', spaste(private.root, '/', basename, '.ps'), ' ', spaste(private.root, '/', basename, '.jpg'));
	shell('convert ', spaste(private.root, '/', basename, '.zoom.ps'), ' ', spaste(private.root, '/', basename, '.zoom.jpg'));
	private.writehtmlimage(f, spaste('<i>Image : ', basename, '</i> : In neighborhood of brightest point, channel ', ichan),
			       spaste(basename, '.zoom.jpg'));
	private.writehtmlimage(f, spaste('<i>Image : ', basename, '</i> : Full image, channel ', ichan),
			       spaste(basename, '.jpg'));
      }
      else {
	private.haveviewer := F;
      }
    }

    private.writehtmlline(f);
    private.writehtmlline(f, '<h2>Header</h2></p>');
    private.writehtmlline(f, '<TABLE BORDER=3 CELLSPACING=3 CELLPADDING=0>');
    private.writehtmlline(f, spaste('<TR><TD>Image name     </TD><TD>', basename, '</TD></TR>'));
    private.writehtmlline(f, spaste('<TR><TD>Image type     </TD><TD>', hdr.imagetype, '</TD></TR>'));
    private.writehtmlline(f, spaste('<TR><TD>Image units    </TD><TD>', hdr.unit, '</TD></TR>'));
    private.writehtmlline(f, spaste('<TR><TD>Image shape    </TD><TD>', hdr.shape, '</TD></TR>'));
    private.writehtmlline(f, '</TABLE>');

    private.writehtmlline(f, '<h2>Restoring beam</h2></p>');
    private.writehtmlline(f, spaste(hdr.restoringbeam.major.value, ' ', hdr.restoringbeam.major.unit, ' by ', 
				    hdr.restoringbeam.minor.value, ' ', hdr.restoringbeam.minor.unit, ' at ', 
				    hdr.restoringbeam.positionangle.value, ' ', hdr.restoringbeam.positionangle.unit));

    private.writehtmlline(f, '<h2>Coordinate system</h2>');
    private.writehtmlline(f, '<TABLE BORDER=3 CELLSPACING=3 CELLPADDING=0>');
    private.writehtmlline(f, '<TH>Axis</TH><TH>Coord Type</TH><TH>Length</TH><TH>Coord value</TH><TH>Pixel</TH>');
    for (i in 1:length(hdr.shape)) {
      private.writehtmlline(f, spaste('<TR><TD>', i, '</TD><TD>', hdr.axisnames[i], 
				      '</TD><TD>', hdr.shape[i], '</TD><TD>', hdr.refval[i],
				      '</TD><TD>', hdr.refpix[i], '</TD></TR>'));
    }
    private.writehtmlline(f, '</TABLE>');

    private.writehtmlline(f)
    private.writehtmlline(f, '<h2>Statistics</h2>');

    for (i in 1:hdr.shape[3]) {
      private.writehtmlline(f);
      private.writehtmlline(f, spaste('<h3><b>Polarization plane </b></h3>', i));
      private.writehtmlline(f);

      private.writehtmlline(f, '<TABLE BORDER=3 CELLSPACING=3 CELLPADDING=0>');
      private.writehtmlline(f, spaste('<TR><TD>Number points </TD><TD> ', stat[i].npts, '</TD><TD> Sum       </TD><TD> ', stat[i].sum, '</TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>Flux density  </TD><TD> ', stat[i].flux, ' ', hdr.unit,
				      '</TD><TD></TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>Mean          </TD><TD> ', stat[i].mean, ' ', hdr.unit,
				      '</TD><TD>Median    </TD><TD> ', stat[i].median, ' ', hdr.unit, '</TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>RMS           </TD><TD> ', stat[i].rms, ' ', hdr.unit,
				      '</TD><TD>Std. Dev. </TD><TD> ', stat[i].sigma, ' ', hdr.unit, '</TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>MedAbsDevMed  </TD><TD> ', stat[i].medabsdevmed, ' ', hdr.unit,
				      '</TD><TD>Quartile  </TD><TD> ', stat[i].quartile, ' ', hdr.unit, '</TD></TR>'));
      private.writehtmlline(f, '</TABLE>');
      private.writehtmlline(f);
      private.writehtmlline(f, '<TABLE BORDER=3 CELLSPACING=3 CELLPADDING=0>');
      private.writehtmlline(f, '<TH></TH><TH>Value</TH><TH>Pixel coordinates</TH><TH>Sky coordinates</TH>');
      private.writehtmlline(f, spaste('<TR><TD>Minimum</TD><TD>', stat[i].min, ' ', hdr.unit, '</TD><TD>', stat[i].minpos,
				      '</TD><TD>', stat[i].minposf, '</TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>Maximum</TD><TD>', stat[i].max, ' ', hdr.unit, '</TD><TD>', stat[i].maxpos,
				      '</TD><TD>', stat[i].maxposf, '</TD></TR>'));
      private.writehtmlline(f, '</TABLE>');
      private.writehtmlline(f);
    }

    private.writehtmlline(f, '<h2>FITS image</h2>');
    private.writehtmllink(f, spaste(basename, '.fits'), spaste(basename, '.fits'));
    private.writehtmlfooter(f);
    f:= F;
#
    return T;
  }

  public.publishwhat := function(threads) {
    wider private, public;
#
# Now write html
#
    f:=open(spaste('> ', private.root, '/', private.what, '.html'));
    private.writehtmlheader(f, spaste('End-to-end processing results for ', type,'  : ', private.what));

    private.writehtmlline(f, '<h2>Processing information</h2>');
    include 'catalog.g';
    dc.copy(spaste(private.what, '.g'), spaste(private.root, '/', private.what, '.g'), confirm=F);
    private.writehtmllink(f, 'Processing script', spaste(private.what, '.g'));;
    private.writehtmllink(f, 'Processing log', spaste(private.what, '.log'));;

    private.writehtmlline(f, '<h2>MeasurementSet</h2>');

    include 'os.g';
    basename := dos.basename(msname);
    note('Publishing MeasurementSet ', msname, ' to ', spaste(private.root, '/', basename, '.fits'));
    shell(spaste('ms2archive ms=', msname, ' fits=', private.root, '/', basename, '.fits'));
    tabledelete(spaste(private.root, '/', basename));
    shell(spaste('cp -r ', msname, ' ', private.root, '/', basename));
    private.writehtmllink(f, spaste('MeasurementSet in FITS format ',
				    spaste(dos.basename(msname), '.fits')),
			  spaste(dos.basename(msname), '.fits'));
    private.writehtmllink(f, spaste('MeasurementSet in AIPS++ format ', dos.basename(msname)),
			  dos.basename(msname));

    private.writehtmlline(f, '<h2>Threads</h2>');
    for (thread in 1:length(threads)) {
      if(len(threads[thread].history())) {
	private.writehtmlline(f, 'Processing history');
	for (history in threads[thread].history()) {
	  private.writehtmlline(f, spaste('   ', history));
	}
      }
      if(threads[thread].valid()) {
	private.writehtmlline(f, spaste('<h2>Thread ', thread, ' images</h2>'));
	for (source in threads[thread].sources().all) {
	  imagename := threads[thread].image(source, 'clean.restored');
	  if(!tableexists(imagename)) {
	    imagename := threads[thread].image(source, 'dirty');
	  }
	  if(tableexists(imagename)) {
	    basename := dos.basename(imagename);
	    private.writehtmllink(f, source, spaste(basename, '.html'));
	    public.publishimage(what, source, imagename);
	  }
	}
      }
      else {
	private.writehtmlline(f, spaste('<h2>Thread ', thread, ' - unable to process: no results</h2>'));
      }
    }
    private.writehtmlfooter(f);
    f:= F;
#
    note('Successfully published ', type, ' : ', what);

    return T;
  }

  public.type := function() {
    return "e2epublish";
  }

  public.done := function() {
    wider private, public;
  }
  return public;
}


e2epublishtest := function() {
}
