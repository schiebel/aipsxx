# sumcatalog: Define and manipulate ms catalogs
#
#   Copyright (C) 1995,1996,1997,1998,1999,2000,2001,2002
#   Associated Universities, Inc. Washington DC, USA.
#
#   This program is free software; you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the Free
#   Software Foundation; either version 2 of the License, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful, but WITHOUT
#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#   more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   675 Massachusetts Ave, Cambridge, MA 02139, USA.
#
#   Correspondence concerning AIPS++ should be addressed as follows:
#          Internet email: aips2-request@nrao.edu.
#          Postal address: AIPS++ Project Office
#                          National Radio Astronomy Observatory
#                          520 Edgemont Road
#                          Charlottesville, VA 22903-2475 USA
#
#   $Id: sumcatalog.g,v 19.0 2003/07/16 03:44:43 aips2adm Exp $
#
#----------------------------------------------------------------------------

pragma include once;

#
# 

sumcatalog := function(directory='/users/jbenson/aips2data', obsfile='none', catalogname='SUMCATALOG') {
#
# Include all the good stuff
#  
  include 'table.g';
  include 'quanta.g';
  include 'measures.g';
  include 'archive/e2efuncs.g';
#
#
# Define private data and public functions
#  
  private := [=];
  public  := [=];
#
#
   indir  := paste(directory);
   infile := paste(obsfile);
#
   filename := spaste(indir,'/',infile);
   xfile := open (spaste('< ',filename));
#
   if (!is_file(xfile)) {
      return throw('Failed to open input file ', result::message,
		   origin='sumcatalog');
    }
#
#
  print "reading file : ", filename;

  private.filename := infile;
  private.maxants := 100;
  private.catalogname := catalogname;
#
#
#
  note('Input file name  = ', private.filename, origin='sumcatalog');
  note('Catalog name     = ', private.catalogname, origin='sumcatalog');
#
#
# Get seconds from 1-Jan-1970 0:0:0, calculate seconds from 1-Jan-2000
#
  private.from2000 := as_integer(floor(time() - 946728000));
#
#----------------------------------------------------------------------------
#
# Now for a bit of sundry slop...
#
  private.arch_file_date := as_double(53000.0);
  private.catalog_date   := as_double(53000.0);
#
# Get the last modified date/time from the ms file.
#
  sh_cmd  := paste("ls -lt --full-time ", filename);
  linebuf := paste(shell(sh_cmd));
#  print "sh_cmd  : ",  sh_cmd;
#  print "linebuf : ",  linebuf;
  linevec := split(linebuf);
  datestr := spaste(linevec[8],linevec[7],linevec[10]);
  timestr := spaste(linevec[9]);
#  private.arch_file_date := mjdObsTime(datestr, timestr);

  print datestr,"  ", timestr, "  ", private.arch_file_date;

  private.catalog_date := mjdTimeNow();
#
  private.ant_count := array(0,private.maxants);
  private.desc_id   := array(0,private.maxants);
#
  private.last_scan_num::print.precision := 4;
#
# Measurement Sets that were constructed from FITS files generated by 
# classical AIPS do not have the project column in the observations
# table set. Copy observer into project. Observer carries the project
# name in the FITS file.
#
  private.observer:= paste('UNKNOWN');
  private.project := paste(private.observer);
  private.segment := paste('?');
  private.source_id := paste('?');
  private.obs_bands := paste('?');
  private.corrmode  := paste('?');
  private.observer_id:=100;
#
# Now determine the archive format
#
  private.arch_format := paste('VLA Exp');
#
# End general purpose slop ..
#----------------------------------------------------------------------------
#
# Public function that writes SQL statements or AIPS++ tables containing 
# the mscatalog info
#
  public.write := function(what='tables') {
    
    wider private;
#
    debug :=  0;
#
# Make a server to handle mscatalog interactions
#
    mscs := F;
    if(what=='tables') {
      include 'archive/mscatalogtables.g';
      mscs := mscatalogtables(private.catalogname);
      note('Adding archive info to AIPS++ tables, table name = ', 
           private.catalogname, origin='sumcatalog.writetable');
    }
    else if(what=='sql'){
      include 'archive/mscatalogsql.g';
      mscs := mscatalogsql(private.catalogname);
      note('Adding archive info to rdbms SQL, SQL script file = ', 
           spaste(private.catalogname, '.sql'), origin='sumcatalog.writetable');
    }

    if(is_fail(mscs)) {
      return throw('Failed to open mscatalog server ', mscs::result,
		   origin='sumcatalog');
    }
#
# Finally add observation information:
#
    ra2000  := as_double(0.0);
    dec2000 := as_double(0.0); 
    twopi   := as_double(2.0*pi);
#
#
# loop steps on each row number when a scan number changes.
    last_row := 1;
    idesc := private.from2000;
    iarch := private.from2000;
    
    n_data_ids := 0;
    n_saved_ids := 0;
    ndesc := 0;
    nsegs := 1;
    narchfiles := 1;
    total_obs_time := 0.0;
    for (i in 1:500)    {
       temp_project[i]  := paste("");
       temp_segment[i]  := paste("?");
       temp_from2000[i] := 0;
       temp_idesc[i]    := 0;
       temp_if_band[i]  := paste(" ");
       temp_ircvr[i]    := 0;
       temp_if_ref[i]   := 0;
       temp_sub_ref[i]  := as_double(0.0);
       temp_sub_bw[i]   := as_float(0.0);
       temp_sub_side[i] := as_integer(0);
       temp_sub_nchn[i] := as_integer(0);
       temp_ipol1[i]    := -1;
       temp_ipol2[i]    := -1;
       temp_ipol3[i]    := -1;
       temp_ipol4[i]    := -1;
   }
#
    iskip := 0;
#
#    print "shape of private.data_id = ", shape(private.data_id);
#
    obs_type    := paste("TRACK");
    source_type := paste("STAR");
    frame_type := paste("ICRF");
    uv_min := 1.0e+3;
    uv_max := 1.0e+9;
    qual := -1;
#
    ipol         := array(0, 4);
    temp_ipol    := array(256,4);
    all_data_ids := array(-1,64,256);
    chk_data_ids := array(-1,256);
#--------------------------------------------------------------------------------
# Begin scan loop here.
# Each value of irow is the row number of the first row of a new scan
#
    print "start loading tables : ",  shell('date');
    nscans := 0;
    while (linebuf := read(xfile)) {
#       linebuf := read(xfile);
       linevec := split(linebuf, ',');
#
       if (iskip == 1) {
          if ((split(linevec[1]) == 'AT245')) {
             iskip := 0;
             print "start reading project : ", linevec[1];
          }
       }          
       if (iskip == 1) {
          continue;
       }
#
       nscans := nscans + 1;
#       if (nscans == 500) break;
#
#       continue;
#
       if (nscans == 1) {
          last_project := spaste(split(linevec[1]));
          mjad    := dq.quantity(linevec[28]);
          file_first_time := mjad.value + as_double(linevec[31])/twopi;
          proj_first_time := file_first_time;
       }
#
# Hit a new project_code, write a new row in the project table.
#
       if ((split(linevec[1]) != private.project) && nscans > 1) { 
          propriety_date := private.last_mjd_time + 540.0;
          result := mscs.addproject(private.project, private.segment, 
                              private.observer, private.observer_id,                              
			      proj_first_time, private.last_mjd_time,
                              propriety_date,
			      private.tele_name, private.tele_config,
                              private.obs_bands, 
                              total_obs_time, nsegs, narchfiles,
			      private.catalog_date);
          if(is_fail(result)) {
             return throw('Failed to write row to archive ', 
                           result::message, origin='sumcatalog');
          }
          print "project row : ",private.project,ingresTime(proj_first_time),
                 ingresTime(private.last_mjd_time);
          mjad := dq.quantity(linevec[28]);
          proj_first_time  := mjad.value + as_double(linevec[31])/twopi;
          total_obs_time := 0.0;
          narchfiles := 0;
       }
#
#
# Encountered a new project_code or a new archive file tape and file number.
# Write a row in the archive table, reset the internal datadesc table
#
       arch_file := spaste(split(linevec[60]),"_",split(linevec[61]));
#
       if (((split(linevec[1]) != private.project) || 
            (arch_file != private.arch_file)) && nscans > 1) {
#
#          print "archive row : ",private.project,ingresTime(file_first_time),
#                 ingresTime(private.last_mjd_time), private.arch_file;

          result := mscs.addarchive(private.project, private.segment, 
			      file_first_time, private.last_mjd_time,
			      private.tele_name, private.tele_config, 
			      private.arch_format,'RAW',private.subarray, iarch,
			      private.arch_file, private.arch_file_date, 
                              private.catalog_date);
          if(is_fail(result)) {
             return throw('Failed to write row to archive ', 
                           result::message, origin='sumcatalog');
          }
#          print "arch row : ",private.project,ingresTime(file_first_time),
#                  private.arch_file;
#

          for (i in 1:4) {
             ipol[i] := -1;
          }
          ndesc := 0;
          for (i in 1:500)    {
             temp_project[i]  := paste("");
             temp_segment[i]  := paste("?");
             temp_from2000[i] := 0;
             temp_idesc[i]    := 0;
             temp_if_band[i]  := paste(" ");
             temp_ircvr[i]    := 0;
             temp_if_ref[i]   := 0;
             temp_sub_ref[i]  := as_double(0.0);
             temp_sub_bw[i]   := as_float(0.0);
             temp_sub_side[i] := 0;
             temp_sub_nchn[i] := as_integer(0);
             temp_ipol1[i]    := ipol[1];
             temp_ipol2[i]    := ipol[2];
             temp_ipol3[i]    := ipol[3];
             temp_ipol4[i]    := ipol[4];
         }
#
          iarch := iarch + 1;
          narchfiles := narchfiles + 1;
          mjad := dq.quantity(linevec[28]);
          file_first_time  := mjad.value + as_double(linevec[31])/twopi;
       }
#
# Load up values into the private record.
#        
       private.project        := spaste(split(linevec[1]));
       private.segment        := paste('?');
       private.observer_id    := as_integer(linevec[4]);
       private.observer       := paste(split(linevec[5]));
       private.source_id      := spaste(split(linevec[2]));
       private.calcode        := spaste(linevec[19]);
       private.corrmode       := spaste(linevec[20]);
       private.subarray       := linevec[22];
       private.avg_int        := as_float(linevec[40]);
       private.config         := spaste(split(linevec[35]));
#
       private.arch_file      := spaste(split(linevec[60]),"_",split(linevec[61]));
       private.tele_name      := spaste("VLA");
       private.tele_config    := spaste(split(linevec[35]));          
#
       mjad    := dq.quantity(linevec[28]);
       private.first_mjd_time := mjad.value + as_double(linevec[31])/twopi;
       private.last_mjd_time  := mjad.value + as_double(linevec[33])/twopi;
#
       time_on_src := as_double(linevec[34]);
       total_obs_time := total_obs_time + time_on_src/3600.0;
#
#
       ra2000  := as_double(linevec[26]);
       dec2000 := as_double(linevec[27]);
#
# Convert ra2000 to radians that range over 0 to 2pi. This is for the
# sake of queries that encompass an ra range.
#
       if (ra2000 < 0.0) ra2000 := ra2000 + twopi;
#
       phase_dir[1] := ra2000;
       phase_dir[2] := dec2000;
#
# Compare the datadesc's in the temp table with that of the current input row
#
       for (j in 1:4) {
           private.center[j] := as_double(linevec[j+5]);
           private.bw[j]     := as_float(linevec[j+9]);
           private.nchans[j] := as_integer(linevec[j+35]);
           if (private.nchans[j] <= 0) private.nchans[j] := 1;
       }
#
#       print "----------------------------------------------------------------------";
#       print private.center[1],private.bw[1], private.nchans[1];
#       print temp_sub_ref[1], temp_sub_bw[1], temp_sub_nchn[1];

       iexists := -1;
       if (ndesc >= 1) {
          for (j in [1:ndesc]) {
              if ( (abs(private.center[1] - temp_sub_ref[j]) < 0.1e-6) &&
                   (abs(private.bw[1]     - temp_sub_bw[j] ) < 0.1e-6) &&
                   (private.nchans[1] == temp_sub_nchn[j])) {
                 iexists := 1;
                 break;
              }
          }
       }
#
# no datadesc rows found that match the freqs, chans in the input row, so write
# four VLA rows into datadesc.
#
       if (iexists == -1) {
          idesc := idesc + 1;
#          print "add 4 new rows : ", idesc, private.project, private.center[1],private.bw[1], private.nchans[1];
          for (j in 1:4) {
             i := j + ndesc;
             ipol[1] := temp_ipol1[i];
             ipol[2] := temp_ipol2[i];
             ipol[3] := temp_ipol3[i];
             ipol[4] := temp_ipol4[i];
             temp_project[i] := paste(private.project);
             temp_segment[i] := paste(private.segment);
             temp_if_band[i] := paste(freq_band(private.center[j]));
             temp_from2000[i]:= as_integer(iarch); 
             temp_idesc[i]   := as_integer(idesc);
             temp_if_ref[i]  := private.center[j];
             temp_sub_ref[i] := private.center[j];
             temp_sub_bw[i]  := private.bw[j];
             temp_sub_side[i]:= 1;
             if(split(linevec[j+13])=="L") {
                temp_sub_side[i] := -1;
             }
             temp_sub_nchn[i]:= private.nchans[j];

             if (debug ==  0){
                result := mscs.adddatadesc(temp_project[i],  temp_segment[i], 
                                        temp_from2000[i], temp_idesc[i], 
                                        temp_if_band[i],  temp_ircvr[i],
			      	        temp_if_ref[i]*1.0e6,   ipol, j,
		 	 	        temp_sub_ref[i]*1.0e6,  
                                        temp_sub_bw[i]*1.0e6,
				        temp_sub_side[i], temp_sub_nchn[i]);
                if(is_fail(result)) {
	           return throw('Failed to write row to archive ', result::message, origin='sumcatalog');
                } 
              }
          }
          ndesc := ndesc + 4;
       }
#
# We will write out a scan row in  observations catalog table for the current row
#
       if (debug == 0) {
          result := mscs.addobservation(private.project, private.segment, 
                                    obs_type,
				    private.first_mjd_time,  private.last_mjd_time,
				    private.source_id,
				    source_type,
				    private.calcode,
                                    private.corrmode,
				    phase_dir,
				    frame_type,
				    as_integer(private.subarray),
				    as_integer(idesc), as_integer(iarch),
				    time_on_src, 
                                    private.avg_int,		
 		                    1.0e+3, 1.0e+9);
           if(is_fail(result)) {
	      return throw('Failed to write row to archive ', result::message, origin='sumcatalog');
           }
       }
    }
#
    propriety_date := private.last_mjd_time + 540.0;
    result := mscs.addproject(private.project, private.segment, 
                              private.observer, private.observer_id,                              
			      proj_first_time, private.last_mjd_time,
                              propriety_date,
			      private.tele_name, private.tele_config, 
                              private.obs_bands,
                              total_obs_time, nsegs, narchfiles,
			      private.catalog_date);
    if(is_fail(result)) {
        return throw('Failed to write row to archive ', result::message, origin='sumcatalog');
    }
          print "project row : ",private.project,ingresTime(file_first_time),ingresTime(private.last_mjd_time);
#
    result := mscs.addarchive(private.project, private.segment, 
			      file_first_time, private.last_mjd_time,
			      private.tele_name, private.tele_config, 
			      private.arch_format,'RAW',private.subarray,iarch,
			      private.arch_file, private.arch_file_date, private.catalog_date);
    if(is_fail(result)) {
      return throw('Failed to write row to archive ', result::message, origin='sumcatalog');
    }
#    print "arch row : ",private.project,ingresTime(file_first_time),private.arch_file;
#
  print "stop loading tables : ",  shell('date');
  print "read and copied nscans = ", nscans;

#
# end of scan loop
#--------------------------------------------------------------------------------
#

#
# Everything is now written
#
    mscs.done();

    return T;
  }
#
# End of public.write function
#----------------------------------------------------------------------------
#
# Type identification for toolmanager, etc.
#
  public.type := function() {
    return "mscatalogserver";
  }


  public.done := function() {
    return T;
  }

  return ref public;
}
# End of mscatalog function 
#----------------------------------------------------------------------------
#



