//# DramaGlishSysEvent.cc: Wrapper for combining Drama and glish events
//# Copyright (C) 1995,1994,1995,1996,1997,1998,1999,2001,2002
//# Associated Universities, Inc. Washington DC, USA.
//#
//# This library is free software; you can redistribute it and/or modify it
//# under the terms of the GNU Library General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or (at your
//# option) any later version.
//#
//# This library is distributed in the hope that it will be useful, but WITHOUT
//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
//# License for more details.
//#
//# You should have received a copy of the GNU Library General Public License
//# along with this library; if not, write to the Free Software Foundation,
//# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
//#
//# Correspondence concerning AIPS++ should be addressed as follows:
//#        Internet email: aips2-request@nrao.edu.
//#        Postal address: AIPS++ Project Office
//#                        National Radio Astronomy Observatory
//#                        520 Edgemont Road
//#                        Charlottesville, VA 22903-2475 USA
//#

#include <casa/Containers/List.h>
#include <casa/Utilities/CountedPtr.h>
#include <hia/DramaGlishEvent/DramaGlishEvent.h>

//# To shut up cpp
#undef List

/*+
Routine name:
	DramaHandleGlishSysEventSource

Function:
	handle an incoming glish event from Drama event loop 

Method:
	If the client is connected to glish
		handle the next glish event
		check if file descriptors should be updated
	else
		a glish shutdown event was previously received, so exit

	DitsAltInAdd is told to send control to this function when
	any file descriptor associated with a glish event is active. This
	function has to be outside the DramaGlishEvent class for reasons
	not understand (by me, anyway).

Language:
	c++

Visibility:
	Public

Call:
	(void) DramaHandleGlishSysEventSource(void* client_data, StatusType * status)

Parameters:   ( (I) Input)
(I) client_data (void*) pointer to client data - a DramaGlishSysEventSource object
(I) status (StatusType*) pointer to Drama status parameter
*-
*/
void DramaHandleGlishSysEventSource(void* client_data, StatusType * status)
{
// while connected to glish
   	DramaGlishSysEventSource * source = 
		(DramaGlishSysEventSource *) client_data;
   	if (source->connected()) {
   		GlishSysEvent event;
   		event = source->nextGlishEvent();
// ignore events generated by 'link' operator
   		if (strcmp(event.type().chars(),"*rendezvous-resp*" ) == 0 )  
			source->update_glish_fds(status);
		else {
// process the event
			source->processEvent(event);
			source->update_glish_fds(status);
		}
   	}
   	else {
//  disconnected from glish so exit
		delete source;
		exit(0);
	}
}

// class DramaGlishSysEventSource constructor
DramaGlishSysEventSource::DramaGlishSysEventSource(int &argc,char **argv,
	StatusType* status):GlishSysEventSource(argc,argv) 
{
    _First = True;
    _num_glish_connects = 0;
    update_glish_fds(status);
}

void DramaGlishSysEventSource::update_glish_fds(StatusType* status)
{
   int condition = DITS_M_READ_MASK;

   if (_First) {
// get connection to glish script
	_First = False;
	FD_ZERO(&_glish_select_set);
    	int num = client_->AddInputMask(&_glish_select_set);
                // add glish file descriptors to DRAMA event handler
        DitsAltInClear(&_DramaFd,status);
	if (*status != STATUS__OK)
        	printf("DramaGlishSysEventSource::update_glish_fds failure of status in call to DitsAltInClear\n");
        for (int cnt=0;num && cnt < FD_SETSIZE; ++ cnt)
                if (FD_ISSET(cnt,&_glish_select_set))
                        {
			
                        DitsAltInAdd(&_DramaFd,cnt,condition,DramaHandleGlishSysEventSource,(void*)this,status);
			if (*status != STATUS__OK)
        			printf("DramaGlishSysEventSource::update_glish_fds failure of status in call to DitsAltInAdd\n");
    			_num_glish_connects++;
                        --num;
                        }
   }
   else {
	Bool updated = False;
   	fd_set temp_fd_set;
   	temp_fd_set = _glish_select_set;
   	int num = client_->AddInputMask(&temp_fd_set);
   	for ( int cnt=0; num && cnt < FD_SETSIZE; ++cnt ) {
		// if not set, go to next fd
		if ( !FD_ISSET(cnt,&temp_fd_set) ) continue;

		// if set, has it already been set previously
        	if ( FD_ISSET(cnt,&_glish_select_set ) )  continue;

		// not already set, so add a new connector to DRAMA
                DitsAltInAdd(&_DramaFd,cnt,condition,DramaHandleGlishSysEventSource,(void*)this,status);
		if (*status != STATUS__OK)
        		printf("DramaGlishSysEventSource::update_glish_fds failure of status in call to DitsAltInAdd\n");
		updated = True;
    		_num_glish_connects++;
        	--num;
   	}
	if (updated)
   		_glish_select_set = temp_fd_set;
  }
}


// destructor - does nothing
DramaGlishSysEventSource::~DramaGlishSysEventSource() {
}

void DramaGlishSysEventSource::delete_glish_fds(StatusType* status)
{
// delete all glish-related file desciptors in DitsAlt event loop
    	int condition = DITS_M_READ_MASK;
     	int num = _num_glish_connects;
   	for ( int cnt=0; num && cnt < FD_SETSIZE; ++cnt ) {
        	if ( FD_ISSET(cnt,&_glish_select_set ) ) { 
                	DitsAltInDelete(&_DramaFd,cnt,condition,DramaHandleGlishSysEventSource,(void*)this,status);
			if (*status != STATUS__OK)
	        		printf("DramaGlishSysEventSource::delete_glish_fds failure of status in call to DitsAltInDelete\n");
        		--num;
		}
   	}
}

// run Drama event loop
Bool DramaGlishSysEventSource::loop(StatusType* status)
{
        DitsAltInLoop(&_DramaFd,status);
	if (*status != STATUS__OK)
       		printf("DramaGlishSysEventSource::loop failure of status in call to DitsAltInLoop\n");
	return True;
}
