//# VOT2AIPS.h: this defines VOT2AIPS, which writes an AIPS++ file from a VOTable node.
//# Copyright (C) 2003
//# Associated Universities, Inc. Washington DC, USA.
//#
//# This library is free software; you can redistribute it and/or modify it
//# under the terms of the GNU Library General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or (at your
//# option) any later version.
//#
//# This library is distributed in the hope that it will be useful, but WITHOUT
//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
//# License for more details.
//#
//# You should have received a copy of the GNU Library General Public License
//# along with this library; if not, write to the Free Software Foundation,
//# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
//#
//# Correspondence concerning AIPS++ should be addressed as follows:
//#        Internet email: aips2-request@nrao.edu.
//#        Postal address: AIPS++ Project Office
//#                        National Radio Astronomy Observatory
//#                        520 Edgemont Road
//#                        Charlottesville, VA 22903-2475 USA
//#
//# $Id: VOT2AIPS.h,v 19.3 2004/11/30 17:51:23 ddebonis Exp $

#ifndef VO_VOT2AIPS_H
#define VO_VOT2AIPS_H
#include <casa/aips.h>
#include <tables/Tables.h>

#include <VOTable.h>

#include <casa/namespace.h>
// <synopsis>
// Takes a VOTable tree and creates an AIPS++ table from it.
// The resulting output is an AIPS++ table with most of the information
// accessible via the table's keywords.
//
// VOTable - table
//  Keywords:
//	Contains all information in records.
//
// Tables are stored in sub directories.

// Keywords of main table: (A trailing '/' indicates a list).
//	RESOURCES/	List of VOTABLE RESOURCES
//	VOTABLE		Record containing information about the VOTABLE itself.
//		DESCRIPTION
//		DEFINITIONS/
//		INFO/
//		attributes
//	V2A	Keywords generated by the converter to help reverse translation.
//
// The RESOURCES keyword contains an ID, name, etc. plus a list of RESOURCEs
//
//	RESOURCES/
//	  RESOURCE:00/
//		TABLES/
//		  TABLE:00/		AIPS++ table 0 for RESOURCE 0.
//		  TABLE:01/
//		  ...
//		  TABLE:nn/
//		RESOURCES/
//		  ...
//	  RESOURCE:01/
//	  ...
//	  RESOURCE:nn/
// This allows each table to be associated with its parent RESOURCE.
//
// NOTE:
// For VOTABLE files with multiple tables, all data tables are stored as
// shown above. The main table is used as table of contents listing the name,
// id and a pointer to each data table.
//

// For the special case of there being only 1 top level data table, the
// table is stored in the main table. The main table's key words will also
// have DESCRIPTION and LINKS keywords.
//
// <example>
// VOT2AIPS	vot2aips;
// ...
//	try {
//	  vot2aips.buildAIPSTable(<votable pointer>, <outfilename>, 1);
//	}
//	catch (const AipsError &err) {
//
// </example>
//
// </synopsis>
//
// <todo asof="2003/04/25>
// In the SIMPLE case, The pointer to the table exists in the RESOURCE
// tree, but points to nothing. This is there for consistency with the
// GENERAL case.
// </todo>
//
// <thrown>
// <li> AipsError (By Table functions).
// </thrown>

class VOT2AIPS {
 public:
	VOT2AIPS();
	~VOT2AIPS();

	// Create and populate an output AIPS++ table.
	// The contents of the upper level table controlled by whether the
	// input table is "SIMPLE" or not.
	// vtbl		- Pointer to VOTable tree containing VOTABLE table.
	// tablename	- Output filename.
	// maxdepth	- Max # of levels to descend for counting tables. Used
	//		  to decide whether the VOTABLE is "SIMPLE" or not.
	//		  Default is effectively all levels. The only other
	//		  value ever used will be 1. (Although any value
	//		  is valid).
	void buildAIPSTable(VOTable *vtbl, String &tablename,
			    uLong maxdepth= ~0);

 protected:
	// Most of these could be public, but putting them here keeps them
	// out of the way.
	// Most of these are static since very little state information
	// is used.
	////////////////////////////////////////////////////////////////
	// Just about everything else is only used internally.
	////////////////////////////////////////////////////////////////

	// Add a keyword if it isn't empty. If force is true, add the keyword
	// even if it isn't empty.
	// NOTE: addKW is very similar to defineRecordValue below. The
	// difference is that addKW will normally only add non-empty keywords.
	static bool addKW(TableRecord &rec, const char *kw,
			  const String &value, bool force=false);

	//		Add values to TableRecords.
	static void defineRecordValue(TableRecord &rec, const String &name,
				      const String &value);
	// Don't use uInt.
	static void defineRecordValue(TableRecord &rec, const String &name,
				      const Int value);

	static void defineRecordValue(TableRecord &rec, const String &name,
				      const TableRecord &value);
	// Add a table to a TableRecord.
	static void defineRecordTable(TableRecord &rec, const String &name,
				      const Table &value);
	static bool addAttributes(TableRecord &rec, votAttributeNode *node);
	/////////////////////////////////////////////////////////////////////
	// Bunches of routines to add VOTABLE parts to table records.
	////////////////////////////////////////////////////////////////////

	// Create a record containing a description. The reason for a
	// separate record is that the tablebrowser may not show a long
	// description otherwise.  (No longer a separate record, but maybe
	// should be again).
	static bool addDescription(TableRecord &rec, votDescription *node);

	// Create a record, add COOSYS info to it then attache the record
	// to the parent. coosysnum is used to create a name. If it's < 0,
	// then the COOSYS is not part of a list and doesn't need a unique
	// name.
	static bool addCOOSYS(Int coosysnum, TableRecord &rec,
			      votCOOSYS *node);
	static bool addCOOSYSList(TableRecord &rec, votCOOSYSList *list);
	static bool addLink(uInt count, TableRecord &rec, votLink *node);
	static bool addLinkList(TableRecord &rec, votLinkList *list);
	// Add a MIN or MAX record.
	static bool addMinMax(TableRecord &rec, votMinMaxNode *node,
			      const char *type);

	static bool addOPTION(uInt vnum, TableRecord &rec, votOption *node);
	static bool addOPTIONList(TableRecord &rec, votOptionList *list);

	static bool addValues(uInt vnum, TableRecord &rec, votValues *node);
	static bool addValuesList(TableRecord &rec, votValuesList *list);
	// Add a votField's info directly into the record.
	// Called by addParam and handleField.
	static bool addFieldKWs(TableRecord &field, votField *node);
	static bool addParam(Int nparam, TableRecord &rec, votParam *node);
	static bool addParamList(TableRecord &rec, votParamList *node);
	static bool addDefinition(uInt defnum, TableRecord &rec,
				  votDefinition *node);
	static bool addDefinitionsList(TableRecord &rec,
				       votDefinitionsList *node);
	static bool addInfo(uInt infoNum, TableRecord &rec, votInfo *node);
	static bool addInfoList(TableRecord &rec, votInfoList *node);
	// Adds field information to the table description.
	static void handleField(uInt fieldNum, votField *field,
				TableDesc &td);
	// Add data for a column.
	static void addColumnData(Table &tab, uInt colnum, votTRList *trlist);
	// Add column descriptors and keywords.
	static uInt createTableColumns(TableDesc &td, votTable *tbl);
	// Given pointers to an AIPS++ table and a votTable, fill the AIPS++
	// table. aipstbl must have its columns correctly setup.
	// Returns true if any data were copied, else false.
	static bool fillTable(Table *aipstbl, votTable *votbl);
	// Create the table from the descriptor and add data.
	static Table *createTable(const String &tablename,
				  TableDesc &td, votTable *tbl);
	static bool addTableKeywords(TableRecord &kw, votTable *node);

	// Update main table's rows with info from a new table.
	void updateMainTable(const String name, const String id,
			     Table &atable);

	// Create an AIPS++ table with the given name using the votTable node.
	// If the name includes subdirectories, they should already exist.
	// Returns a pointer to the Table object.
	static Table *createAIPSTable(const String &tableName,
				      votTable *node);

	// Create an AIPS++ table given a pointer to a voTable node.
	// On return tableName, is set to the name of the table which isn't
	// necessarily the same as the name the table was created with.
	// Besides no path info, the name will be from the ID attribute if it
	// exists.
	//
	Table *addAIPSTable(uInt count, const String &rpath,
			    String &tableName, votTable *node);
	uInt addAIPSTables(const String &rpath, TableRecord &parent,
			   votTableList *list);

	// Process a Resource. Create a record then add the resource's
	// information to it. Then attach the record to the parent. resnum
	// is used to make a unique (for the parent resource) name. A
	// subdirectory of the parents RESOURCES directory is created.
	bool addResource(uInt resnum, const String rpath, TableRecord &parent,
			 votResource *node);
	// Process a Resource list. Create a record then add each
	// resource's information to it. Then attach the record to the
	//parent. A subdirectory is created to store tables in.
	 uInt addResources(const String rpath, TableRecord &parent,
			   votResourceList *list);

	// Adds version info of this program to a table record:
	//  record/
	//	V2A/
	//		V2A major version
	//		V2A minor version
	//		Table format: "GENERAL" or "SIMPLE"
	static void addV2AInfo(TableRecord &rec, bool isSimple);
	// Adds version info of the VOTABLE to a table record:
	//  record/
	//	VOTABLE:	// Votable information
	//		version
	//		SystemID
	// Add the Votable's attributes (version & xmlns) if they exist.
	static void addVOTABLEattributes(TableRecord &kw, VOTable *tbl);
	void VOT2AIPS::addDOCINFO(TableRecord &kw, VOTable *tbl);
	////////////////////////////////////////////////////////////////
	// These routines work together to decide whether the VOTABLE
	// is a 'SIMPLE' table.

	// Count and return the number of tables in the list. If it's > 0,
	// return a pointer to the first table if tbl1 is 0. If it isn't 0,
	// don't change it.
	static uInt countTables(votTableList *tl, votTable * & tbl1);
	// Recursively count the number of tables within a resource.
	// maxdepth gives the maximum # of levels to count, including this
	// one.
	static uInt checkResource(votResource *res, votTable * &tbl1,
				  const uLong maxdepth = ~0);
	static uInt checkResources(votResourceList *rl, votTable * & tbl1,
				   const uLong maxdepth);

	// Scan a VOTable tree and returns true if there is only one table
	// otherwise false. Returns the number of tables and a pointer to the
	// first votTable.  maxdepth gives the maximum # of levels of
	// RESOURCES to descend below the first RESOURCE.
	static bool checkForSimple(VOTable *votable, votTable * & vtbl1,
				   uLong maxdepth = ~0);
	////////////////////////////////////////////////////////////////
	// Add kewords for the main VOTABLE node.
	static void addVOTABLEKeywords(TableRecord &rec, VOTable *vtbl);

	// Debugging routine. Prints r's field names to cerr.
	// If str is non 0, it's printed first.
	void pfields(const TableRecord &r, const char *str=0);
 private:
	void init();
 private:
	// These variables are used as pointers back to the top level
	// table.
	Table *gtable_;
	Table *firstTable_;
	votTable *firstvotTable_;
};
#endif
