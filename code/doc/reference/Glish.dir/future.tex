% $Header: /home/cvs/casa/code/doc/reference/Glish.dir/future.tex,v 19.0 2003/07/16 04:18:47 aips2adm Exp $

\chapter{Future Directions}
\label{future}

\index{possible future changes|(}
There are many areas in which the {\em Glish} language or system may
evolve in the future.  Listed here are likely changes (or, in some
cases, changes at least being considered), some of which will not be
backward-compatible:

%\begin{sloppy}
\begin{enumerate}

\item A way for providing ``type signatures", both for {\em Glish} functions
\index{type signatures (proposed)}
\index{type-checking (proposed)}
and {\tt whenever} statements, and for programs using the Client Library.
The signature would provide run-time type-checking, and also automatic
partition of a value into its components.  For example,
\begin{verbatim}
    whenever a->b(numeric c, string d) do
        ...
\end{verbatim}
would respond to any {\tt b} event generated by agent {\tt a} by
first checking whether its value had a {\em numeric} ``{\tt c}" field and
a {\tt string} ``{\tt d}" field, and if so then assigning those
fields to local variables ``{\tt c}" and ``{\tt d}".

Similarly, in a {\em Glish} client, something along the lines of:
\begin{verbatim}
    client->Register( "b", "numeric c, string d",
                      my_func );
\end{verbatim}
which would register the client as responding to the same sort
of {\tt b} event by calling {\tt my\_func} with arguments ``{\tt c}"
and ``{\tt d}".

\item Perhaps a ``module" facility to support precompiled script
\indtt{module}{facility (proposed)}
libraries.

\item Support for
\index{timeouts!for await and request/reply (proposed)}
timeouts and
\index{exception-handling!for await and request/reply (proposed)}
exception handling when using await and request/reply events (\xref{request-reply}).

\item {\tt print} needs to be more sophisticated, to support
\index{possible future changes!better printing of values}
\index{{\em printf()} (proposed)}
\index{formatting (proposed)}
{\em printf()\/}-style formatting.

\item Perhaps
\indtt{in}{operator (proposed)}
an ``{\tt in}" operator for determining whether a
field is in a record, rather than {\tt has\_field()} (\xref{has_field-func}),
which is somewhat inefficient and clumsy to use.

\item Additional
\index{operators!proposed}
C-style operators, such as ``{\tt ? $\ldots$ :}" and perhaps ``{\tt ++}".

\item A mechanism
\index{records!addition of@``addition'' of (proposed)}
for ``adding" one record to another, including all
of its fields.

\item Making the implicit semi-colon insertion algorithm (\xref{semicolons})
never insert a semi-colon if there is a pending close-parenthesis (i.e.,
more open-parentheses have been seen than close-parentheses).

\item An ``{\tt Incomplete()}" member function for {\em Client\/}, similar
\indmem{Incomplete}{Client}
to {\tt Unrecognized()}, for reporting events that arrive without all
the necessary values (record fields).  The various {\tt Value:Field()} member
functions would record the last field they were asked to find but couldn't,
so {\tt Incomplete()} could generate an event identifying which field
was missing (or had the wrong type).

\item The ability
\index{records!comparisons (proposed)}
to compare records element-by-element using the ``{\tt ==}"
operator.

\item An {\tt ascii=T} optional argument to {\tt read\_value()} to make
\indtt{ascii=}{option for reading and writing values (proposed)}
the resulting file human-readable.  Of course, {\tt write\_value()}
should be able to read the result.

\item Similarly, making the {\tt input=} argument to {\tt shell()} and
{\tt client()} more imaginative about how it turns event values into text.
For example, {\tt 1:10} should generated 10 lines, one integer per line,
instead of a single line of the numbers surrounded by {\tt []}'s.

\item Sprucing up the limited {\em stdin} interface provided to stand-alone
clients (\xref{standalone}).

\item Additional mathematical functions,
\index{predefined functions!mathematical (proposed)}
such as {\tt sgn()}

\item Additional functions for manipulating strings: extracting substrings,
\index{predefined functions!string manipulation (proposed)}
\index{strings!manipulation functions (proposed)}
searching for patterns, substitution.  Perhaps the ``{\tt +}" operator should
perform {\tt spaste()} (\xref{spaste-func}) when invoked with {\tt string}
operands.

\item Perhaps allow assignment between multiple record fields and a
\index{records!assigning (proposed)}
single vector with the same number of values:
\begin{verbatim}
    r["x y z"] := [0, 0, 10]
\end{verbatim}
would assign {\tt r.x} to {\tt 0}, {\tt r.y} to {\tt 0}, and {\tt r.z}
to {\tt 10}.

\item Perhaps make
\index{await statement!as an expression (proposed)}
{\tt await} an expression (returning {\tt \$value})
%\$
instead of a statement.

\item Perhaps redefine {\tt ref} so that it ``distributes" across
\index{references!distributed@``distributed'' (proposed)}
records.  For example, ``{\tt a["b c"] := ref d["x y"]}" would
make {\tt a.b} a reference to {\tt d.x} and {\tt a.c} a reference
to {\tt d.y}.

\item A more flexible {\tt record}-constructor that expands any
\indoptwo{[]}{record creation operator (proposed)}
records inside it, so that {\tt [a=1, [b=2, c=3]]} becomes equivalent to
{\tt [a=1, b=2, c=3]}, just as {\tt [1, [3, 5]]} is presently
equivalent to {\tt [1, 3, 5]}.

\item A ``trace"
\index{trace facility (proposed)}
feature that reports when large internal copies
are done, so inefficiencies in {\em Glish} scripts can be tracked down.

\item Functions for ``walking" records or vectors and applying
other functions to each element or field.

\item {\tt num\_args()} and {\tt nth\_arg()} should default to
apply to ``{\tt ...}" if no arguments are given.

\item A mechanism
\index{records!deleting fields (proposed)}
for efficiently deleting a field from a record.

\item Perhaps a
\index{assignment!compound (proposed)}
``compound-assignment" statement for extracting pieces
of a vector or a record:
\begin{verbatim}
    a, b, c := d
\end{verbatim}
would assign the first field (or element) of {\tt d} to {\tt a}, the
second field to {\tt b}, and the remainder to {\tt c}.

\item A mechanism for
\index{events!recording (proposed)}
recording events and later playing them back
or displaying them for analysis.

\item More
\index{variables!uninitialized (proposed)}
flexible use of uninitialized variables, rather than just
generating a warning and assigning them to {\tt F}.  Perhaps simply
do away with the warning message.

\item Event-designators
\index{events!designators!possible future changes}
for ``an {\tt x} event generated by any agent"
(``{\tt *->foo}") or ``any event whatsoever" (``{\tt *->*}'').

\item Presently there is a division between functions that are
actually built into the {\em Glish} interpreter and those that are defined
in the {\tt glish.init} file (\xref{glish-init}).  The former do
not support named arguments or variable argument lists.  This restriction
should be removed, making it much easier to add more
built-in functions.

\item {\tt for} loops should work for iterating over {\tt record}'s as
well as vectors.

\item Probably {\tt for} loop indices should be implicitly {\tt local}
unless explicitly made global.

\item A mechanism for
\index{events!out-of-band (proposed)}
dealing with out-of-band events, and for
flushing event queues under exceptional conditions.

\item The ``{\tt ...}" ellipsis should ``remember" its {\tt name=value}
\index{ellipsis!remembering bindings (proposed)}
bindings so they are preserved if the ellipsis is passed as an argument
to another function.

\item A mechanism
\index{clients!joining a running script (proposed)}
for allowing ``unexpected" clients to ``join" a
{\em Glish} script.  The present mechanism (using {\tt async=T} in a call
to {\tt client()}; see \xref{client-func-long}) requires the script to
anticipate a client wanting to join.

\item Probably the full set of ANSI escape sequences will be
\index{escape sequences (proposed)}
supported in string literals.

\item Executing the same {\tt link} statement more than once should
not cause the link source to send multiple copies of the given event,
but instead do nothing if the link is already established.

\item A mechanism for terminating a subsequence.

\item More flexible type conversion in {\tt Value::Polymorph()}.

\item Perhaps {\tt split()} should return empty strings if it finds multiple,
adjacent split characters.

\item Changing the {\tt environ} global should probably change the environment.

\item Errors in executing shell commands and asynchronous shell clients
should probably result in events being generated.

\item The ``short-circuit" {\tt \&\&} and \verb+||+ operators should
complain if one of their operands is not a scalar, instead of just
using the first element of the operand.  The same holds for values
tested in conditionals.

\end{enumerate}

%\end{sloppy}

\index{possible future changes|)}
