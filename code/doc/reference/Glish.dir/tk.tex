% $Header: /home/cvs/casa/code/doc/reference/Glish.dir/tk.tex,v 19.0 2003/07/16 04:18:52 aips2adm Exp $

\chapter{Glish/Tk}
\label{glishtk}
\index{tk|(}
\index{Tk|see{tk}}
\index{Glish/Tk|see{tk}}

This chapter describes a TCL/Tk based client, {\tt glishtk}, which allows for the
integration of graphical widgets into {\em Glish} control
scripts. 
The addition of Tk allows you to  
create simple GUIs (graphical user interfaces) 
which interact with
{\em Glish}.

\section{Introduction}
\index{Ousterhout, John}
\htmllink{TCL/Tk}{\tcltkurl} was developed
by John Ousterhout, and it has achieved wide popularity. TCL, {\em Tool Command
Language}, was developed to be an embeddable language. It provides a simple
easily extensible string based language that allows you to customize
it for your particular application. Tk is a binding of graphical widget
functionality to TCL. This allows widgets to be accessed directly from a
simple interpreter.

\index{tk!{\em description}}
The Tk widgets were chosen for {\em Glish} because they have been 
extensively used
and are robust in an interpretive environment. It is very important that
widgets which are used interactively handle bad input with grace. Tk is
somewhat unique in this respect. Most widget toolkits are designed
to be used as linkable libraries and are therefore intended for programmers
rather than end users. As a result, these library toolkits have not tended
to be very robust.

In creating {\em Glish}/Tk, every attempt was made to fully integrate the widgets
into {\em Glish}, and as a result, it is not simply a binding of the Tk widgets
to yet another language. In {\em Glish}/Tk, the widgets are 
synonymous with {\em Glish}
clients. They are agents which you create with functions. Once
created, these agents generate and respond to events. The events which
they generate are almost always the result of user interaction with the
widgets. The events generated by the Tk agents are handled just like any
other events in {\em Glish}.

To use this client, you should be able to simply add {\tt -l glishtk.g} to
the command line invocation of {\em Glish}. This will start the client which
serves up the widgets, and it will define all of the necessary functions.

While {\em Glish}/Tk is quite usable, it is not yet complete, 
and as a result, not
all of the features found in TCL/Tk have made it into {\em Glish}/Tk. In addition,
this chapter only gives an introduction to Tk. For more information about
Tk, I would recommend ``Practical Programming in TCL and Tk''
\footnote{Brent Welch, \underline{Practical Programming in TCL and Tk} (New Jersey: Prentice Hall,1995)}.

For most of the Tk widgets, a table is provided listing the events
the widget accepts or generates. Table~\ref{tkevent-legend} presents
the meaning behind the arrows in these tables. These arrows provide a
shorthand notation for indicating event flow between {\em Glish} and 
the widget.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|p{3.1in}|}
\hline
 I/O & Description \\
\hline
\hline
$\rightarrow$& event sent from {\em Glish} and accepted by the widget \\ \hline
$\leftarrow$& event generated by the widget \\ \hline
$\Leftrightarrow$& {\tt request}/{\tt reply} event \\ \hline
$\leftrightarrow$& either $\leftarrow$ or $\rightarrow$ event\\ \hline
\end{tabular}
\end{center}
}
\caption{ Event Legend }
\label{tkevent-legend}
\end{table}

\index{tk!focus model}
\index{tk!click to focus}
\index{{\tt system} global variable!{\tt tk}|(}
The default focus model for {\em Glish/Tk} is ``focus follows mouse''. The
focus is always on the widget under the cursor. This is {\bf unlike} the
default {\em TCL/Tk} focus model, ``click to focus.'' Applications
can change the focus model back to TCL/Tk's ``click to focus'' by setting:
\begin{verbatim}
    system.tk := [=]
    system.tk.focus := 'click'
\end{verbatim}
{\bf before} including {\tt glishtk.g}.
\index{{\tt system} global variable!{\tt tk}|)}

\section{Frame}
\index{tk!frame|(}
The most basic widget in {\em Glish}/Tk is the {\em frame} widget. 
The frame widgets  group other Tk widgets and are the parent of most
other widgets in Tk.  They position and group multiple
widgets and insert space into the GUI layout forming the basis for layout
specifications.

Here is a simple {\em Glish}/Tk example that creates a number of frames:
\begin{verbatim}
    f := frame(side='left')
    rec := [=]
    for (i in "raised sunken flat groove ridge")
       rec[i] := frame(f,relief=i)
\end{verbatim}
In this example, {\tt f} is set to  a {\em toplevel} frame. Toplevel frames
are stand-alone windows which have no parent. The {\tt frame} function
 creates the  frames. In this case only one parameter is specified,
{\tt side}. By default, frames arrange other widgets from top to bottom, i.e.
the default value for {\tt side} is {\tt 'top'}. By specifying {\tt 'left'}
here, the frame packs children widgets from left to right.

A record is created and used to hold the other frames they are
produced. The loop loops through each of the different Tk relief 
styles. The final
assignment assigns a frame to  elements of the record.
The first parameter to \verb+frame()+ is an optional parent, and in this case, the
parent for these frames is {\tt f}. Another optional parameter for frames is
{\tt relief}. It specifies the edge relief of the frame. The default relief
is {\tt 'flat'}.

The window which is generated by this simple script is shown in
Figure~\ref{tkframe}.
\begin{figure}[thb]
%\htmlimage{useimg=tkframe.gif}
%\latex{\centerline{\psfig{figure=tkframe.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkframe.eps,scale={0.7}}}
\caption{ Frame }
\label{tkframe}
\end{figure}
It shows each of the five different reliefs available for
the Tk widgets. In this example, the frames are the children of another
frame, and they are packed in the parent frame horizontally.

Frames have a number of other optional parameters, and Table~\ref{tkframe-params}
lists these options.
\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.7in}|p{1.8in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}            & {\tt F}       & widget & parent of the frame \\ \hline
{\tt relief}            & {\tt 'flat'}  & {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & border relief \\ \hline
{\tt borderwidth}       & {\tt 2}       & dimension & width of the border \\ \hline
{\tt side}              & {\tt 'top'}   & {\tt 'top'} {\tt 'left'} {\tt 'right'} {\tt 'bottom'} & direction for child placement \\ \hline
{\tt padx}              & {\tt 0}       & dimension & horizontal padding \\ \hline
{\tt pady}              & {\tt 0}       & dimension & vertical padding \\ \hline
{\tt expand}            & {\tt 'both'}  & {\tt 'both'} {\tt 'none'} {\tt 'x'} {\tt 'y'} & frame expansion when resized \\ \hline
{\tt background}        & {\tt 'lightgrey'}& X color & the background color \\ \hline
{\tt width}             & {\tt 70}      & dimension & default width of empty frame \\ \hline
{\tt height}            & {\tt 50}      & dimension & default height of empty frame \\ \hline
{\tt cursor}            & {\tt ''}      & X cursor name & cursor displayed in frame \\ \hline
{\tt title}             & {\tt 'glish/tk'}& string & string displayed by window manager \\ \hline
{\tt icon}              & {\tt ''}      & path & path to xbitmap file \\ \hline
{\tt newcmap}           & {\tt F}       & boolean & use private color map? \\ \hline
{\tt tlead}             & {\tt F}       & widget & leader for this popup frame \\ \hline
{\tt tpos}              & {\tt 'sw'}    & {\tt 'c'} {\tt 'n'} {\tt 's'} {\tt 'e'} {\tt 'w'} {\tt 'ne'} {\tt 'nw'} {\tt 'se'} {\tt 'sw'} & location of this popup, relative to {\tt tlead} \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
{\tt visual}		& {\tt ''}	& {\tt 'staticgrey'}, {\tt 'greyscale'}, {\tt 'staticcolor'}, {\tt 'pseudocolor'}, {\tt 'truecolor'}, {\tt 'directcolor'}, {\tt 'best'}\footnotemark & set the visual to be used for all drawing within the frame \\ \hline
{\tt visualdepth}	& {\tt []}	& integer & bit depth of desired visual \\ \hline
\end{tabular}
\end{center}
}
\caption{ Frame Construction Parameters }
\label{tkframe-params}
\index{tk!frame!construction parameters}
\end{table}

In addition to specifying frame attributes at construction time, frames accept
events which are used to modify frame characteristics. For example,
you may want to change the cursor for a frame to indicate the  
application is busy so the user must wait.  
Continuing the example above:
\begin{verbatim}
    f->cursor('watch')
\end{verbatim}
After this statement, the ``watch'' cursor is  used whenever the user
enters the frame with the mouse. All {\em Glish}/Tk widgets accept and generate
events. Table~\ref{tkframe-events} lists the events which frames accept.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.9in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+ with Glish event \verb+<G>+ \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt cursor}    &$\rightarrow$& X cursor name & change the cursor for this frame\\ \hline
{\tt disable}&$\rightarrow$& & disable all widgets within frame, must be balanced by {\tt enable} \\ \hline
{\tt enable}&$\rightarrow$& & enable all widgets within frame, must be balanced by {\tt disable} \\ \hline
{\tt expand}    &$\rightarrow$& {\tt 'both'} {\tt 'none'} {\tt 'x'} {\tt 'y'} & change the resizing behavior \\ \hline
{\tt fonts}&$\leftarrow$& & all available fonts as a string \\ \hline
{\tt grab}      &$\rightarrow$& {\tt 'global'} {\tt 'local'} & change focus to this frame \\ \hline
{\tt height}    &$\leftarrow$& & get current height of frame \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt icon}&$\rightarrow$& path & change icon of frame \\ \hline
{\tt killed}    &$\leftarrow$& & frame was deleted by user \\ \hline
{\tt map}&$\rightarrow$& & make the toplevel frame visible \\ \hline
{\tt padx}      &$\rightarrow$& dimension & set horizontal padding \\ \hline
{\tt pady}      &$\rightarrow$& dimension & set vertical padding \\ \hline
{\tt raise}     &$\rightarrow$& {\em none} or toplevel {\tt frame} & raise frame, just above param if supplied \\ \hline
{\tt release}   &$\rightarrow$& & release a grab on this frame \\ \hline
{\tt relief}    &$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt resize}    &$\leftarrow$& old and new size & indicates frame was resized by user \\ \hline
{\tt side}      &$\rightarrow$& {\tt 'top'} {\tt 'left'} {\tt 'right'} {\tt 'bottom'} & direction for child placement \\ \hline
{\tt title}     &$\rightarrow$& string & set title of frame \\ \hline
{\tt unmap}     &$\rightarrow$& & hide the toplevel frame \\ \hline
{\tt width}     &$\leftarrow$& & get current width of frame \\ \hline
\end{tabular}
\end{center}
}
\caption{ Frame Events }
\index{tk!frame!events}
\label{tkframe-events}
\end{table}

It is important to note that sending a {\em global} {\tt grab} event to an
empty frame is a sure way to lock up your X session. This is because there
is no way to release the grab.

\index{tk!frame!popup}
\index{tk!frame!transient}
In addition to {\em toplevel} frames and nested frames, it is also possible to
create {\em popup} or {\em transient} frames. These frames are created whenever
you need a toplevel frame which does not have the window manager decorations.
These transient frames are created relative to some other widget. For example, this
\begin{verbatim}
    f := frame()
    b := button(f)
    b->bind('<Enter>','enter')
    b->bind('<Leave>','exit')
    whenever b->enter do
        t := frame(tlead=b,tpos='se',background='blue')
    whenever b->exit do
        t := F
\end{verbatim}
will create a button, and whenever the cursor enters the button, it will pop up
a blue frame. When the cursor exits the button, it will pop down the frame. The
position of the transient frame is defined relative to another widget, here
{\tt b}, which is passed as the {\tt tlead} parameter. The {\tt tpos}
parameter specifies where in relation to the {\tt tlead} widget the frame
should be positioned, in this case the {\em southeast} corner. When the
{\tt tlead} widget is moved, any transient frames which are associated
with it move too. These transient frames are useful for things like {\em popup help}.
\footnotetext{The {\tt visual} selected with {\tt -visual} must be supported by your X Display; use {\it xdpyinfo} to find out.}
\index{tk!frame|)}
\FloatBarrier

\section{Button}
\index{tk!button|(}
Buttons are the simplest widgets which actually {\em do something}, i.e. generate
events. You create buttons to allow the user to click on an area of the
screen to cause some action. In {\em Glish}/Tk, the
action which the
button itself causes is the generation of a {\tt press} event. The
{\em Glish}
script handles this event as it does any other event.

\subsection{Plain Buttons}
{\em Plain} buttons are the simplest kind of buttons. They have no
state, and the only
thing that happens when the user presses them is that a {\tt press} event is
generated. Here is an example of how {\em plain} buttons are created:
\begin{verbatim}
    fme := frame( )
    b1 := button(fme,'Button One')
    b2 := button(fme,'Button Two')
    whenever b1->press do
        print 'Button One Pressed'
    whenever b2->press do
        print 'Button Two Pressed'
\end{verbatim}
This example generates a simple dialog containing two buttons, 
and when the user
presses either of the buttons, a message is printed by the {\tt whenever}
statements. The dialog box which this creates looks like the one in
Figure~\ref{tkbutton}.
\begin{figure}[thb]
%\htmlimage{useimg=tkbutton.gif}
%\latex{\centerline{\psfig{figure=tkbutton.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkbutton.eps,scale={0.7}}}
\caption{ Button }
\label{tkbutton}
\end{figure}
It is simply a frame with two buttons. In addition to the parameters shown in
this example, buttons accept many other construction parameters. These are summarized
in Table~\ref{tkbutton-params}.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.9in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}            &               & widget & parent of the button \\ \hline
{\tt text}              & {\tt 'button'}& string & text label for button \\ \hline
{\tt type}              & {\tt 'plain'} & {\tt 'plain'} {\tt 'radio'} {\tt 'check'} {\tt 'menu'} & button type \\ \hline
{\tt padx}              & {\tt 7}       & dimension & horizontal padding around text \\ \hline
{\tt pady}              & {\tt 3}       & dimension & vertical padding around text \\ \hline
{\tt width}             & {\tt 0}       & integer & width in {\em character} units\\ \hline
{\tt height}            & {\tt 1}       & integer & height in {\em character} units\\ \hline
{\tt justify}           & {\tt 'center'}& {\tt 'center'} {\tt 'left'} {\tt 'right'} & justification of text \\ \hline
{\tt font}              & {\tt ''}      & X font & font of text \\ \hline
{\tt relief}            & {\tt 'raised'}& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & edge relief \\ \hline
{\tt borderwidth}       & {\tt 2}       & dimension & border width \\ \hline
{\tt foreground}        & {\tt 'black'} & X color & color of text \\ \hline
{\tt background}        & {\tt 'lightgrey'}& X color & background color \\ \hline
{\tt disabled}          & {\tt F}       & boolean & is inactivated? \\ \hline
{\tt value}             & {\tt T}       & Glish value & value returned with {\tt press} event \\ \hline
{\tt anchor}            & {\tt 'c'}     & {\tt 'c'} {\tt 'n'} {\tt 's'} {\tt 'e'} {\tt 'w'} {\tt 'ne'} {\tt 'nw'} {\tt 'se'} {\tt 'sw'} & location of {\tt text} \\ \hline
{\tt fill}		& {\tt 'none'}	& {\tt 'x'} {\tt 'y'} {\tt 'both'} {\tt 'none'} & how to expand when resized \\ \hline
{\tt bitmap}            & {\tt ''}      & path & use specified bitmap file instead of {\tt text} \\ \hline
{\tt group}             & {\tt parent}  & widget & only for radio; indicates how radio functionality is grouped \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
\end{tabular}
\end{center}
}
\caption{ Button Construction Parameters }
\label{tkbutton-params}
\index{tk!button!construction parameters}
\end{table}

In this example, if {\tt fme} is constructed with
{\tt side} set to {\tt left}, then the buttons are arranged
horizontally instead of vertically. In fact, if the frame is sent {\tt side}
events:
\begin{verbatim}
    fme->side('left')         # arrange left to right
    fme->side('right')        # arrange right to left
    fme->side('bottom')       # arrange bottom to top
\end{verbatim}
the buttons can be dynamically rearranged. In an analogous way, the text of
the buttons can also be changed:
\begin{verbatim}
    b1->text('First Button')
    b2->text('Second Button')
\end{verbatim}
The other events which buttons accept are similar to the construction parameters;
they are outlined in Table~\ref{tkbutton-events}. The only event which buttons
generate is the {\tt press} event, and this is the hook through which buttons
cause actions in a script.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{2.5in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt anchor}    &$\rightarrow$& {\tt 'c'} {\tt 'n'} {\tt 's'} {\tt 'e'} {\tt 'w'} {\tt 'ne'} {\tt 'nw'} {\tt 'se'} {\tt 'sw'} & set location of {\tt text} \\ \hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+ with Glish event \verb+<G>+ \\ \hline
{\tt bitmap}    &$\rightarrow$& string & set path to bitmap file \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt disable}&$\rightarrow$& & disable widget, must be balanced by {\tt enable} \\ \hline
{\tt disabled}	&$\rightarrow$& boolean & set state, disable ({\tt T}) or enable ({\tt F}) \\ \hline
{\tt enable}&$\rightarrow$& & enable widget, must be balanced by {\tt disable} \\ \hline
{\tt font}      &$\rightarrow$& X font & set font for text \\ \hline
{\tt foreground}&$\rightarrow$& X color & change foreground color \\ \hline
{\tt height}    &$\rightarrow$& integer & set height (in {\em character} units) \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt justify}   &$\rightarrow$& {\tt 'center'} {\tt 'left'} {\tt 'right'} & set justification for text \\ \hline
{\tt padx}      &$\rightarrow$& dimension & set horizontal padding around text \\ \hline
{\tt pady}      &$\rightarrow$& dimension & set vertical padding around text \\ \hline
{\tt press}     &$\leftarrow$& Glish value & indicates that button was pressed \\ \hline
{\tt relief}    &$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt state}     &$\Leftrightarrow$& boolean & set state for button ({\em check} and {\em radio} only) \\ \hline
{\tt text}      &$\rightarrow$& string & set text \\ \hline
{\tt width}     &$\rightarrow$& integer & set width (in {\em character} units) \\ \hline
\end{tabular}
\end{center}
}
\caption{ Button Events }
\label{tkbutton-events}
\index{tk!button!events}
\end{table}

As shown in Table~\ref{tkbutton-params}, there are several different types
of buttons -- plain, radio, check, and menu. These are set with the {\tt type}
parameter. The example above shows how {\em plain} buttons
work. Below you
will see how other buttons work.

\subsection{Check Buttons}
\index{tk!button!check|(}
{\em Check} buttons are identical to {\em plain}
buttons, but {\em check} buttons have state. Their state is indicated
by their appearance. Check buttons allow the user to select multiple
items from a list. Here is an example of a check box:
\begin{verbatim}
    root := frame( side='left' )
    fbox := frame( root, borderwidth=0 )
    box := [=]
    for (i in "one two three")
        {
        box[i] := button(fbox,paste('button',i),type='check',value=i)
        whenever box[i]->press do
            print "check button", $value, "pressed"
        }
\end{verbatim}
When the user clicks on {\em check} buttons, the appearance of the button
changes to indicate the state of the button. Note that the the {\tt value}
parameter to {\tt button} is used to permit later differientation of
the buttons. The graphic that this script creates is shown in 
Figure~\ref{tkcheckb}. Note, however, that the second button has been
pressed by the user.
\begin{figure}[thb]
%\htmlimage{useimg=tkcheckb.gif}
%\latex{\centerline{\psfig{figure=tkcheckb.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkcheckb.eps,scale={0.7}}}
\caption{ Check Button }
\label{tkcheckb}
\end{figure}
The script prints ``check button two pressed'' in response to the selection
of the second check button. This action is again accomplished with a
{\tt whenever} statement. Each time one of the check buttons is pressed
a {\tt press} event is generated.

You can query the state of a check button with the {\tt state} event:
\begin{verbatim}
    print box[2]->state()
\end{verbatim}
Since the second button is selected once, the output of this
statement is {\tt T}. The {\tt state} event is also  used to set the
state. So if you  want to {\em unselect} the second check button, you do 
something like:
\begin{verbatim}
    box[2]->state(F)
\end{verbatim}
and the the appearance of the second button's check box changes to look like
the checkboxes of the other two {\em check} buttons.
\index{tk!button!check|)}

\subsection{Radio Buttons}
\index{tk!button!radio|(}
{\em Radio} buttons are very similar to check buttons with the exception that
radio buttons are mutually exclusive. This means that the state of only one
radio button in a group can have its state set to {\tt T}. By default, a {\em group}
is defined to be all radio buttons within a given frame, but the {\tt group} parameter
can be used to change this grouping. 

To change the dialog in Figure~\ref{tkcheckb} to use {\em radio} buttons instead
of {\em check} buttons, you can do the following:
\begin{verbatim}
    for (i in "one two three")
        {
        box[i] := button(fbox,paste('button',i),type='radio',value=i)
        whenever box[i]->press do
            print "check button", $value, "pressed"
        }
    box[i]->state(T)
\end{verbatim}
Notice that you use the same toplevel frame from the example above, but
when each \verb+box[i]+ is reassigned, the previous widget is deleted.
Assume you wanted to have an extra column of radio buttons, you can do
it as follows:
\begin{verbatim}
    nf := frame(root, borderwidth=0)
    for (i in "four five six")
        {
        box[i] := button(nf,paste('button',i),type='radio',
                         value=i,group=fbox)
        whenever box[i]->press do
            print "check button", $value, "pressed"
        }
\end{verbatim}
%$
After running these two small scripts, the dialog Figure~\ref{tkcheckb} will
change dynamically to look like Figure~\ref{tkradiob}.
\begin{figure}[thb]
%\htmlimage{useimg=tkradiob.gif}
%\latex{\centerline{\psfig{figure=tkradiob.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkradiob.eps,scale={0.7}}}
\caption{ Radio Button }
\label{tkradiob}
\end{figure}
Here again, a {\tt press} event is generated each time a user selects one of the
buttons, and the state of the buttons can be set and queried with the {\tt state}
event. Now, however, selecting button five, for example, causes the previously
selected button, here button three, to be unselected. This is the behavior of
radio buttons. Specifying the {\tt group} for the second column of radio buttons
make the two columns act as one group.
\index{tk!button!radio|)}

\subsection{Menu Buttons}
\index{tk!button!menu|(}
Like {\em radio} and {\em check} buttons, {\em menu} buttons are more complicated
than {\em plain} buttons. {\em Menu} buttons do not have state, but rather their
action when pressed is to display more buttons. This allows you to build
menus containing all of the buttons discussed above.

As before, a button is indicated to be a menu by setting the {\tt type} parameter.
Here is a simple example:
\begin{verbatim}
    top := frame()
    bar := frame(top,side='left',expand='x')
    file := button(bar,'File',type='menu')
    opt := button(bar,'Options',type='menu')
    rec := [=]
    rec['space'] := frame(bar,width=150,height=1)
    help := button(bar,'Help',type='menu')
    for (i in "A B C")
        {
        rec[i] := button(file,paste('File',i))
        rec[len(rec)+1] := button(opt,paste('Opt',i))
        rec[len(rec)+1] := button(help,paste('Help',i))
        }
\end{verbatim}
In this example, there are a couple of things to note. First a frame, {\tt bar}, is
created to contain all of the menus. This is how a menubar is created in Tk. Note
that the {\tt expand} parameter is set to {\tt 'x'} indicating that {\tt bar}
will only expand horizontally. This is to prevent the frame containing the
menu buttons from expanding vertically if the user resizes the window. Next,
two menu buttons, {\tt file} and {\tt opt},  are placed in {\tt bar}, and because
of the way {\tt bar} is constructed, these menu buttons are organized left to
right. Next a frame is used to space the next menu button out to the end of the
dialog, and then another menu, {\tt help}, is added to the menu{\tt bar}. The
loop simply fills each of the menu buttons with entries which are simply more
buttons. The key thing to notice is that the parent of these buttons is a
{\em menu} button. 

\begin{figure}[thb]
%\htmlimage{useimg=tkmenu.gif}
%\latex{\centerline{\psfig{figure=tkmenu.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkmenu.eps,scale={0.7}}}
\caption{ Menu Button }
\label{tkmenu}
\end{figure}
Entries in a menu button are the only case in {\em Glish}/Tk where a widget can have
a parent which is not a frame. Figure~\ref{tkmenu} shows what the menubar created
above looks like when the user selects, i.e. presses,  the ``{\em Options}''
menu button and selects the second menu element. The selection by the user of
entries in a menu button are caught using {\tt whenever} statements in the same
way as regular buttons. For example:
\begin{verbatim}
    whenever rec['A']->press do
        print "Got It!"
\end{verbatim}
causes ``{\tt Got It!}'' to be printed by the interpreter whenever the first
entry in the {\tt file} menu button is selected.
\index{tk!button!menu|)}
\index{tk!button|)}
\FloatBarrier

\section{Listbox and Scrollbar}
The {\em listbox} widget presents a number of options to allow the user to select
one or more of the options. In some respects, a {\em listbox} is like an
encapsulated group of check buttons. Their function is essentially identical, but
as you shall see, listboxes are more convenient when many options are involved. In
this case, the {\em scrollbar} widget and the {\em listbox} 
work together to allow
the user to easily select from many options.

\subsection{Listbox}
\index{tk!listbox|(}
Like buttons, listboxes
have a parent, and the widget is returned by a constructor function call. Here is an
example of how a listbox is created:
\begin{verbatim}
    lbf := frame(f)
    lb := listbox(lbf)
    lb->insert("one two three four five six seven eight nine")
\end{verbatim}
In this case, only the parent is specified to create the listbox.
Table~\ref{tklistbox-params} lists all of the options for creation of listboxes.
Creating a listbox, however, only generates an empty listbox with
no options for the user to choose. An {\tt insert} event must be sent to the
listbox to place strings in the listbox. These strings represent
the choices which the listbox presents the user.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.9in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}            &               & widget & parent of the listbox \\ \hline
{\tt width}             & {\tt 20}      & integer& listbox width in {\em character} units \\ \hline
{\tt height}            & {\tt 6}       & integer& listbox height in lines \\ \hline
{\tt mode}              & {\tt 'browse'}& {\tt 'browse'} {\tt 'single'} {\tt 'extended'} {\tt 'multiple'} & listbox mode \\ \hline
{\tt font}		& {\tt ''}	& X font & text font \\ \hline
{\tt relief}		& {\tt 'sunken'} & {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & edge relief \\ \hline
{\tt borderwidth}       & {\tt 2}       & dimension & border width \\ \hline
{\tt foreground}        & {\tt 'black'} & X color & text color \\ \hline
{\tt background}	& {\tt 'lightgrey'}& X color & background color \\ \hline
{\tt exportselection}	& {\tt F}	& boolean & export selection to X clipboard? \\ \hline
{\tt fill}		& {\tt 'x'}	& {\tt 'x'} {\tt 'y'} {\tt 'both'} {\tt 'none'} & how to expand when resized \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
\end{tabular}
\end{center}
}
\caption{ Listbox Construction Parameters }
\label{tklistbox-params}
\index{tk!listbox!construction parameters}
\end{table}

A listbox has a {\em mode} which specifies how the user can select items. By default,
the listbox is in {\tt 'browse'} mode. In this mode, the user can only select one item
from the listbox, and the selection can be {\em dragged}. The user can select the item,
drag the mouse, and the selection will follow the mouse. If there are more items in
the listbox than are displayed, the listbox scrolls to display the selected items
as the user drags the mouse. In the example above, nine items are put into the listbox,
but by default, only six are displayed. By dragging the selection, the user can access
the items that are outside of the displayed range. A listbox in {\tt 'single'} mode
is like the {\tt 'browse'} mode listbox except that the user cannot  drag the
selection.

A listbox in {\tt 'extended'} mode allows the user to select multiple items from the
listbox. Selections are made by selecting individual items or by selecting and
dragging over several items. The control key is used to augment the selected
items, and the shift key used to specify the beginning and end of a range of
items to select. This mode is analogous to the {\tt 'browse'} single selection
mode, and {\tt 'multiple'} mode is analogous to {\tt 'single'}. In {\tt 'multiple'}
mode, the user can only add and remove items from the group of 
selected items by
single selections of individual items.

It is important to be able to retrieve the selection the user has indicated. There
are two ways of doing this. Each time a selection is made, a {\tt select} event
is generated. So continuing the example above:
\begin{verbatim}
    whenever lb->select do
        print "Items selected:",lb->get($value)
\end{verbatim}
this {\tt whenever} causes the interpreter to print a message each time
the selection in the listbox changes. The entire selection is returned
as indexes in \verb+$value+. The {\tt get} request is used to map the
selection offsets to the strings they represent. The {\tt selection}
request also is  used to retrieve the current selection indexes:
\begin{verbatim}
    print lb->selection()
\end{verbatim}
i.e. the \verb+$value+ in the above example. Table~\ref{tklistbox-events}
lists all of the listbox events.

A final common listbox operation is deleting all of the  elements in the
listbox. This is easy to accomplish:
\begin{verbatim}
    lb->delete('start','end')
\end{verbatim}

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{0.7in}|p{3.1in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+ with Glish event \verb+<G>+ \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt clear}	&$\rightarrow$&string& clear indicated items, use 2 strings to clear range \\ \hline
{\tt delete}	&$\rightarrow$&string& delete indicated items, use 2 strings to delete range \\ \hline
{\tt exportselection} &$\rightarrow$&boolean& export selection to X clipboard? \\ \hline
{\tt font}	&$\rightarrow$& X font & change text font \\ \hline
{\tt foreground}&$\rightarrow$& X color & change foreground color \\ \hline
{\tt get}	&$\Leftrightarrow$&integer& request items, i.e. map indexes to items \\ \hline
{\tt height}	&$\rightarrow$&integer& listbox height in lines \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt insert}	&$\rightarrow$&string& insert items, optional 2nd param insert index \\ \hline
{\tt mode}	&$\rightarrow$&{\tt 'browse'} {\tt 'single'} {\tt 'multiple'} {\tt 'extended'} & change listbox mode \\ \hline
{\tt nearest}	&$\Leftrightarrow$&integer& return item nearest the {\em y offset} param \\ \hline
{\tt relief}	&$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt see}	&$\rightarrow$&string& scroll listbox so specified index is visible \\ \hline
{\tt select}	&$\leftrightarrow$&string& generated when user makes selection, can also be used to select items \\ \hline
{\tt selection}	&$\Leftrightarrow$&integer& get indexes of the current selection \\ \hline
{\tt view}	&$\rightarrow$&record& scrollbar update event \\ \hline
{\tt width}	&$\rightarrow$&integer& listbox width in {\em character} units \\ \hline
{\tt xscroll}	&$\leftarrow$&double& information for horizontal scrollbar update \\ \hline
{\tt yscroll}	&$\leftarrow$&double& information for vertical scrollbar update \\ \hline
\end{tabular}
\end{center}
}
\caption{ Listbox Events }
\label{tklistbox-events}
\index{tk!listbox!events}
\end{table}
\index{tk!listbox|)}

\subsection{Scrollbar}
\index{tk!scrollbar|(}
\label{tkscrollbar}
\label{tkscrollbar-example}

With a plain listbox, some items may be out of view as you saw above. By connecting
scrollbars to the listbox, however, the user can scroll the box to look at the items,
and the user gets feedback about how many items are in the box and which portion of
the items are currently being displayed. Indeed, this is the type of feedback users
expect. A scrollbar is added to the example above as follows:
\begin{verbatim}
    lbf := frame(f,side='left')
    lb := listbox(lbf)
    sb := scrollbar(lbf)
    whenever sb->scroll do
        lb->view($value)
    whenever lb->yscroll do
        sb->view($value)
    lb->insert("one two three four five six seven eight nine")
\end{verbatim}
In this case, a new frame widget is created , {\tt lbf}, so the
listbox and the {\em scrollbar} are side by side. Figure~\ref{tklistbox} shows
what this looks like.

\begin{figure}[thb]
%\htmlimage{useimg=tklistbox.gif}
%\latex{\centerline{\psfig{figure=tklistbox.eps,scale={0.7}}}}
\centerline{\psfig{figure=tklistbox.eps,scale={0.7}}}
\caption{ Listbox }
\label{tklistbox}
\end{figure}

Two {\tt whenever} statements are required so that the listbox and the scrollbar
update each other. The scrollbar only generates one event, {\tt scroll}. The value
of this event must be relayed to the widget that the scrollbar is controlling, here
a listbox. These {\tt scroll} events are generated by the user moving the scrollbar
{\em thumb}, i.e. the raised part in the middle of the scrollbar.

The listbox generates two scroll related events, {\tt xscroll} and {\tt yscroll}.
These allow for both vertical and horizontal scrollbars to be attached to the listbox.
The {\tt yscroll} events are generated either by the user {\em dragging} the selection
or in response to {\tt view} events. The {\tt xscroll} events are generated in response
to {\tt view} events.

This interaction is pretty interesting. The scrollbar generates the {\tt scroll} event
but does not update its appearance. Its apperance is updated by the resulting {\tt view}
event generated by the widget the scrollbar is controlling. Without these
{\tt whenever}s, no scrolling occurs.
\index{tk!scrollbar|)}
\FloatBarrier

\section{Odds and Ends}
This section discusses a few remaining {\em minor} widgets which 
are useful, but have a single function. These are grouped together in a single
section because they are similar in complexity and functionality.

\subsection{Label}
\index{tk!label|(}
The label widget does exactly what you would expect; it is used to insert a short
text string into the interface. Here is a simple example:
\begin{verbatim}
    f := frame(f,side='left')
    l := label(f,'Options:')
    b1 := button(f,'continue')
    b2 := button(f,'quit')
    whenever b2->press do
        exit
\end{verbatim}
This dialog is shown in Figure~\ref{tklabel}.
\begin{figure}[thb]
%\htmlimage{useimg=tklabel.gif}
%\latex{\centerline{\psfig{figure=tklabel.eps,scale={0.7}}}}
\centerline{\psfig{figure=tklabel.eps,scale={0.7}}}
\caption{ Label }
\label{tklabel}
\end{figure}
The label is simply placed in the frame first, and then the buttons it
describes are added to the frame. Table~\ref{tklabel-params} show the other
parameters which can be specified during the creation of a label.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.7in}|p{1.3in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}		& {\tt F}	& widget & parent of the label \\ \hline
{\tt text}		& {\tt 'label'}	& string & label text \\ \hline
{\tt justify}		& {\tt 'left'}& {\tt 'center'} {\tt 'left'} {\tt 'right'} & justification of text \\ \hline
{\tt padx}		& {\tt 4}	& dimension & horizontal padding \\ \hline
{\tt pady}		& {\tt 2}	& dimension & vertical padding \\ \hline
{\tt font}		& {\tt ''}	& X font & text font \\ \hline
{\tt width}		& {\tt 0}	& integer & width in {\em character} units \\ \hline
{\tt relief}		& {\tt 'flat'}	& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & border relief \\ \hline
{\tt borderwidth}	& {\tt 2}	& dimension & border width \\ \hline
{\tt foreground}	& {\tt 'black'}	& X color & color of text \\ \hline
{\tt background}	& {\tt 'lightgrey'}& X color & background color \\ \hline
{\tt anchor}            & {\tt 'c'}     & {\tt 'c'} {\tt 'n'} {\tt 's'} {\tt 'e'} {\tt 'w'} {\tt 'ne'} {\tt 'nw'} {\tt 'se'} {\tt 'sw'} & location of {\tt text} \\ \hline
{\tt fill}		& {\tt 'none'}	& {\tt 'x'} {\tt 'y'} {\tt 'both'} {\tt 'none'} & how to expand when resized \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
\end{tabular}
\end{center}
}
\caption{ Label Construction Parameters }
\label{tklabel-params}
\index{tk!label!construction parameters}
\end{table}

Table~\ref{tklabel-events} shows the events which labels accept, and as you can
see from the table, labels do not generate events.
\index{tk!label|)}

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.7in}|p{2.0in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt anchor}    &$\rightarrow$& {\tt 'c'} {\tt 'n'} {\tt 's'} {\tt 'e'} {\tt 'w'} {\tt 'ne'} {\tt 'nw'} {\tt 'se'} {\tt 'sw'} & set location of {\tt text} \\ \hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+ with Glish event \verb+<G>+ \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt font}	&$\rightarrow$& X font & set text font \\ \hline
{\tt foreground}&$\rightarrow$& X color & change foreground color \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt justify}	&$\rightarrow$& {\tt 'center'} {\tt 'left'} {\tt 'right'} & set text justification \\ \hline
{\tt padx}	&$\rightarrow$& dimension & set horizontal padding \\ \hline
{\tt pady}	&$\rightarrow$& dimension & set vertical padding \\ \hline
{\tt relief}	&$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt text}	&$\rightarrow$& string & set label text \\ \hline
{\tt width}	&$\rightarrow$& integer & set width (in {\em character} units) \\ \hline
\end{tabular}
\end{center}
}
\caption{ Label Events }
\label{tklabel-events}
\index{tk!label!events}
\end{table}


\subsection{Scale}
\index{tk!scale|(}
The {\em scale} widget allows the user to pick a number out of a range. In other toolkits,
this is called a slider. Here is an example of the creation of a scale:
\begin{verbatim}
    f := frame(side='left')
    v := scale(f,0,110,text='Volume')
    t := scale(f,0,110,text='Treble')
    b := scale(f,0,110,text='Bass')
\end{verbatim}
The interface which this example creates is shown in Figure~\ref{tkscale}.
\begin{figure}[thb]
%\htmlimage{useimg=tkscale.gif}
%\latex{\centerline{\psfig{figure=tkscale.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkscale.eps,scale={0.7}}}
\caption{ Scale }
\label{tkscale}
\end{figure}
The value of the slider is posted with the {\tt value} event. Here is an example,
\begin{verbatim}
    whenever v->value do
        print "Volume:",$value
\end{verbatim}
This {\tt whenever} prints out a message each time the volume is changed. Note
however if you just want to get the last value of the slider, it is accessible as
a member of the agent, in this case \verb+v.value+. This is because the last
value of each event name is retained in the agent. As a result, {\tt whenever}
statements are often not needed with scales. Table~\ref{tkscale-params} lists the
other construction parameters for {\tt scale}s, and Table~\ref{tkscale-events} lists
the {\tt scale} events.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.5in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}		& 		& widget & parent of the scale \\ \hline
{\tt start}		& {\tt 0.0}	& float & starting integer for scale \\ \hline
{\tt end}		& {\tt 100.0}	& float & ending integer for scale \\ \hline
{\tt value}		& {\tt start}	& float & initial value for the scale \\ \hline
{\tt length}		& {\tt 110}	& integer & length of scale \\ \hline
{\tt text}		& {\tt ''}	& string & optional label for scale \\ \hline
{\tt resolution}	& {\tt 1.0}	& float & resolution of the scale \\ \hline
{\tt orient}		& {\tt 'horizontal'}& {\tt 'horizontal'} {\tt 'vertical} & orientation of scale \\ \hline
{\tt width}		& {\tt '15'}    & dimension & width/height of the thumb \\ \hline
{\tt font}		& {\tt ''}	& X font & text font \\ \hline
{\tt relief}		& {\tt 'flat'}& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & edge relief \\ \hline
{\tt borderwidth}	& {\tt 2}	& dimension & border width \\ \hline
{\tt foreground}	& {\tt 'black'}	& X color & color of text \\ \hline
{\tt background}	& {\tt 'lightgrey'}& X color & background color \\ \hline
{\tt fill}		& {\tt ''}	& {\tt 'x'} {\tt 'y'} {\tt 'both'} {\tt 'none'} & how to expand when resized; default: expand with {\tt orient} \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
{\tt showvalue}		& {\tt T}	& boolean & display the selected value? \\ \hline
\end{tabular}
\end{center}
}
\caption{ Scale Construction Parameters }
\label{tkscale-params}
\index{tk!scale!construction parameters}
\end{table}

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.6in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+ with Glish event \verb+<G>+ \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt end}	&$\rightarrow$& integer & change ending value \\ \hline
{\tt font}	&$\rightarrow$& X font & set text font \\ \hline
{\tt foreground}&$\rightarrow$& X color & change foreground color \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt length}	&$\rightarrow$& integer & change length of scale \\ \hline
{\tt orient}	&$\rightarrow$& {\tt 'horizontal'} {\tt 'vertical} & change orientation \\ \hline
{\tt relief}	&$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt resolution} &$\rightarrow$& float & change resolution of scale \\ \hline
{\tt showvalue}	&$\rightarrow$& boolean & show/hide scale value \\ \hline
{\tt start}	&$\rightarrow$& integer & change starting value \\ \hline
{\tt text}	&$\rightarrow$& string & set scale label \\ \hline
{\tt value}	&$\leftarrow$& integer & value changed by user \\ \hline
{\tt width}	&$\rightarrow$& integer & change width/height of scale \\ \hline
\end{tabular}
\end{center}
}
\caption{ Scale Events }
\label{tkscale-events}
\index{tk!scale!events}
\end{table}
\index{tk!scale|)}

\subsection{Message}
\index{tk!message|(}
The {\em message} widget is viewed as a multi-line label. It is essentially a
scratch pad for displaying several word messages to the user. For long messages,
the {\em text} widget is a better choice.

Here is an example of the message widget in use:
\begin{verbatim}
    f := frame(side='left')
    b := button(f,'time')
    m := message(f,shell('date'))
    whenever b->press do
        m->text(shell('date'))
\end{verbatim}
This simple example updates the time display in the {\em message} widget whenever
the button is pressed. This looks like Figure~\ref{tkmessage}.
\begin{figure}[thb]
%\htmlimage{useimg=tkmessage.gif}
%\latex{\centerline{\psfig{figure=tkmessage.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkmessage.eps,scale={0.7}}}
\caption{ Message }
\label{tkmessage}
\end{figure}
In general, the {\tt text} event is the primary event for the {\em message} widget.
The other construction parameters are shown on Table~\ref{tkmessage-params}.
The {\tt message} widget itself does not generate any event, but the events which
it accepts are shown in Table~\ref{tkmessage-events}.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.5in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}		& 		& widget & parent of the message \\ \hline
{\tt text}		& {\tt 'message'}& string & text for message \\ \hline
{\tt width}		& {\tt 180}	& dimension & width of message\\ \hline
{\tt justify}		& {\tt 'center'}& {\tt 'center'} {\tt 'left'} {\tt 'right'} & justification of text \\ \hline
{\tt font}		& {\tt ''}	& X font & font of text \\ \hline
{\tt padx}		& {\tt 7}	& dimension & horizontal padding \\ \hline
{\tt pady}		& {\tt 3}	& dimension & vertical padding \\ \hline
{\tt relief}		& {\tt 'raised'}& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & edge relief \\ \hline
{\tt borderwidth}	& {\tt 2}	& dimension & border width \\ \hline
{\tt foreground}	& {\tt 'black'}	& X color & color of text \\ \hline
{\tt background}	& {\tt 'lightgrey'}& X color & background color \\ \hline
{\tt anchor}            & {\tt 'c'}     & {\tt 'c'} {\tt 'n'} {\tt 's'} {\tt 'e'} {\tt 'w'} {\tt 'ne'} {\tt 'nw'} {\tt 'se'} {\tt 'sw'} & location of {\tt text} \\ \hline
{\tt fill}		& {\tt 'none'}	& {\tt 'x'} {\tt 'y'} {\tt 'both'} {\tt 'none'} & how to expand when resized \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
\end{tabular}
\end{center}
}
\caption{ Message Construction Parameters }
\label{tkmessage-params}
\index{tk!message!construction parameters}
\end{table}

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{2.1in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt anchor}    &$\rightarrow$& {\tt 'c'} {\tt 'n'} {\tt 's'} {\tt 'e'} {\tt 'w'} {\tt 'ne'} {\tt 'nw'} {\tt 'se'} {\tt 'sw'} & set location of {\tt text} \\ \hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+ with Glish event \verb+<G>+ \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt font}	&$\rightarrow$& X font & set font for text \\ \hline
{\tt foreground}&$\rightarrow$& X color & change foreground color \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt justify}	&$\rightarrow$& {\tt 'center'} {\tt 'left'} {\tt 'right'} & set justification for text \\ \hline
{\tt padx}	&$\rightarrow$& dimension & set horizontal padding around text \\ \hline
{\tt pady}	&$\rightarrow$& dimension & set vertical padding around text \\ \hline
{\tt relief}	&$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt text}	&$\rightarrow$& string & set text \\ \hline
{\tt width}	&$\rightarrow$& integer & set width (in {\em character} units) \\ \hline
\end{tabular}
\end{center}
}
\caption{ Message Events }
\label{tkmessage-events}
\index{tk!message!events}
\end{table}
\index{tk!message|)}

\subsection{Entry}
\index{tk!entry|(}
The {\em entry} provides slots where the user can type in text. The script
can then retrieve this text when it is needed. Here is a more complex example:
\begin{verbatim}
    f := frame()
    ef := frame(f,side='left')
    b := button(ef,'ls')
    en := entry(ef)
    lbf := frame(f,side='left')             # **
    lb := listbox(lbf,width=32)             # **
    sb := scrollbar(lbf)                    # **
    whenever b->press, en->return do
        {
        lb->delete("start","end")
        dir := en->get()
        files := shell('if [ -r',dir,'];then ls -1F',dir,';else exit 1;fi')
        if ( ! files::status )
            lb->insert(files)
        else
            en->insert('*BAD DIRECTORY* ','start')
        }
    whenever sb->scroll do                  # **
        lb->view($value)                    # **
    whenever lb->yscroll do                 # **
        sb->view($value)                    # **
\end{verbatim}
In this example, first note that the lines tagged with {\tt **} are nearly
identical to the {\em listbox} plus {\em scrollbar} example in
\S~\ref{tkscrollbar-example}. The remaining lines setup a button and an entry
widget. Next the {\em listbox} plus {\em scrollbar} dialog from the
previous example is used. In this dialog, the user enters a directory in the
{\em entry} widget, and the contents of the directory  shows up in the
{\em listbox} (see Figure~\ref{tkentry}).

The mechanics of this are controlled by the first
{\tt whenever}. Whenever the user presses the button or hits the
\verb+<return>+ key in the entry widget, the listbox is cleared, the string
from the entry widget is retrieved, an {\tt ls} is done on the directory, and if it
succeeds, the output is used to fill the {\em listbox} otherwise an error is
indicated in the {\em entry} widget. The complicated \verb+shell()+ command which
actually does the {\tt ls} just checks to see if the directory exists, and if
it does exist, the {\tt ls} is done, otherwise the shell command exits with a
non-zero status.

\begin{figure}[thb]
%\htmlimage{useimg=tkentry.gif}
%\latex{\centerline{\psfig{figure=tkentry.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkentry.eps,scale={0.7}}}
\caption{ Entry }
\label{tkentry}
\end{figure}

This example shows three of the entry widget events, {\tt get},
{\tt insert}, and {\tt return}. The {\tt get} event returns
the contents of the entry widget and the {\tt insert} event inserts text 
into the {\tt entry} widget.
The second parameter to {\tt insert} is optional, and it specifies where to
insert the string. By default, the string is inserted at the end. The {\tt return}
event is generated when the user hits the \verb+<return>+ key in the {\em entry}
widget. Table~\ref{tkentry-params} list all of the parameters to \verb+entry()+, and
Table~\ref{tkentry-events} lists the entry widget events.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.6in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}		& 		& widget & parent of the entry \\ \hline
{\tt width}		& {\tt 0}	& integer & width in {\em character} units\\ \hline
{\tt justify}		& {\tt 'center'}& {\tt 'center'} {\tt 'left'} {\tt 'right'} & justification of text \\ \hline
{\tt font}		& {\tt ''}	& X font & font of text \\ \hline
{\tt relief}		& {\tt 'raised'}& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & edge relief \\ \hline
{\tt borderwidth}	& {\tt 2}	& dimension & border width \\ \hline
{\tt foreground}	& {\tt 'black'}	& X color & color of text \\ \hline
{\tt background}	& {\tt 'lightgrey'}& X color & background color \\ \hline
{\tt disabled}		& {\tt F}	& boolean & is inactivated? \\ \hline
{\tt show}		& {\tt T}	& boolean & show typed characters? \\ \hline
{\tt exportselection}	& {\tt F}	& boolean & export to X clipboard? \\ \hline
{\tt fill}		& {\tt 'x}	& {\tt 'x'} {\tt 'y'} {\tt 'both'} {\tt 'none'} & how to expand when resized \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
\end{tabular}
\end{center}
}
\caption{ Entry Construction Parameters }
\label{tkentry-params}
\index{tk!entry!construction parameters}
\end{table}

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{0.6in}|p{3.3in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+ with Glish event \verb+<G>+ \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt delete}	&$\rightarrow$&string& delete indicated character, use 2 strings to delete range \\ \hline
{\tt disable}&$\rightarrow$& & disable widget, must be balanced by {\tt enable} \\ \hline
{\tt disabled}	&$\rightarrow$& boolean & set state, disable ({\tt T}) or enable ({\tt F}) \\ \hline
{\tt enable}&$\rightarrow$& & enable widget, must be balanced by {\tt disable} \\ \hline
{\tt exportselection} &$\rightarrow$&boolean& export selection to X clipboard? \\ \hline
{\tt font}	&$\rightarrow$& X font & change text font \\ \hline
{\tt foreground}&$\rightarrow$& X color & change foreground color \\ \hline
{\tt get}	&$\Leftrightarrow$&& get current contents \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt insert}	&$\rightarrow$&string& insert item, optional 2nd param insert index \\ \hline
{\tt justify}	&$\rightarrow$& {\tt 'center'} {\tt 'left'} {\tt 'right'} & set justification for text \\ \hline
{\tt relief}	&$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt return}	&$\leftarrow$&string& generated when user hits return, returns contents \\ \hline
{\tt show}	&$\rightarrow$&boolean& show typed characters? \\ \hline
{\tt view}	&$\rightarrow$&record& scrollbar update event \\ \hline
{\tt width}	&$\rightarrow$&integer& entry width in {\em character} units \\ \hline
{\tt xscroll}	&$\leftarrow$&double& information for horizontal scrollbar update \\ \hline
\end{tabular}
\end{center}
}
\caption{ Entry Events }
\label{tkentry-events}
\index{tk!entry!events}
\end{table}

Notice in Table~\ref{tkentry-events} that the {\tt entry} widget generates
the events necessary to connect a {\em horizontal} scrollbar to the {\em entry} widget.
This is done in a way analogous to connecting a vertical {\em scrollbar} to the
{\em listbox}, i.e. change {\tt yscroll} to {\tt xscroll}.
\index{tk!entry|)}
\FloatBarrier

\section{Text}
\index{tk!text|(}
The Tk {\tt text} widget is a complex widget. You can
 write a full blown editor using the text widget, even though the
text widget is not yet completely integrated into {\em Glish}.

The {\em text} widget is used to display large amounts of textural information.
The {\tt xscroll}, {\tt yscroll}, and {\tt view} events are available to connect
vertical and horizontal scrollbars to the text widget. Here is an example of
the creation of a text widget:
\begin{verbatim}
    f := frame()
    tf := frame(f,side='left',borderwidth=0)
    t := text(tf,relief='sunken',wrap='none')
    vsb := scrollbar(tf)
    bf := frame(f,side='right',borderwidth=0)
    pad := frame(bf,expand='none',width=23,height=23,relief='groove')
    hsb := scrollbar(bf,orient='horizontal')
    whenever vsb->scroll, hsb->scroll do
        t->view($value)
    whenever t->yscroll do
        vsb->view($value)
    whenever t->xscroll do
        hsb->view($value)
    t->append('one\ntwo\nthree\nfour\nfive\nsix\n')
    t->append('seven\neight\nnine\nten\neleven\ntwelve')
    t->insert(' this line is a very very long line','8.end')
\end{verbatim}
In this example, a text widget is created along with two scrollbars. A frame,
{\tt pad}, is used to pad out the horizontal scrollbar so that it doesn't
run past the end of the text widget. Next, the scroll events between the text
widget and the scrollbar are connected up. Finally, some initial text is
added to the text widget. This simple dialog looks like the one shown
in Figure~\ref{tktext}.
\begin{figure}[thb]
%\htmlimage{useimg=tktext.gif}
%\latex{\centerline{\psfig{figure=tktext.eps,scale={0.7}}}}
\centerline{\psfig{figure=tktext.eps,scale={0.7}}}
\caption{ Text }
\label{tktext}
\end{figure}

One thing to note is that {\em indexes} for the text widget are written as
\verb+line.position+ where {\tt line} is the line number, and {\tt position}
is the character position within the line. The last line of the above example
 is an example of an index passed with the {\tt insert} event.

Indexes are also used to tag regions of the text widget. For example
if you want to change the background of the string ``{\tt this line is}''
to red, you do it by first taging the section and then changing the
configuration for that tag:
\begin{verbatim}
    t->addtag( 'red', '8.6', '8.18' )
    t->config( 'red', background='red' )
\end{verbatim}
All of the standard Tk attributes can be set in the same way {\tt background}
is set here. Multiple attributes can be passed to {\tt config}, and the
configuration of a tag done before any section of the text widget has
been tagged. Tags can also be set as lines inserted into the text widget:
\begin{verbatim}
    t->append( '\nthirteen', 'red' )
    t->insert( 'this is line ', '13.0', 'red' )
\end{verbatim}
Here, the string ``{\tt this is line thirteen}'' is appended to the text
widget, and the whole line has a red background. The {\tt deltag} event
is used to delete a tag. Deleting a tag removes any configuation
changes.

You can edit and modify the text in the text widget. The
text widget can also be disabled; this prevents text from being
added by the user. So in general for smaller amounts of non-editable
text, it is probably better to use the {\em message} widget. For things like
listing a long copyright notice, e.g. the GNU GPL, a {\em disabled} text widget
might be a good choice.

Table~\ref{tktext-params} lists all of the parameters available for the {\em text}
widget.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.9in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}		& 		& widget & parent \\ \hline
{\tt width}		& {\tt 0}	& integer & width in {\em character} units\\ \hline
{\tt height}		& {\tt 1}	& integer & height in lines \\ \hline
{\tt wrap}		& {\tt 'word'}	& {\tt 'none'} {\tt 'char'} {\tt 'word'} & line wrap behavior \\ \hline
{\tt font}		& {\tt ''}	& X font & font of text \\ \hline
{\tt disabled}		& {\tt F}	& boolean & is inactivated? \\ \hline
{\tt text}		& {\tt ''}	& string & initial text \\ \hline
{\tt relief}		& {\tt 'flat'}& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & edge relief \\ \hline
{\tt borderwidth}	& {\tt 2}	& dimension & border width \\ \hline
{\tt foreground}	& {\tt 'black'}	& X color & color of text \\ \hline
{\tt background}	& {\tt 'lightgrey'}& X color & background color \\ \hline
{\tt fill}		& {\tt 'both'}	& {\tt 'x'} {\tt 'y'} {\tt 'both'} {\tt 'none'} & how to expand when resized \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
\end{tabular}
\end{center}
}
\caption{ Text Construction Parameters }
\label{tktext-params}
\index{tk!text!construction parameters}
\end{table}

In the example above, {\tt wrap} is important because if you specified the
lines should wrap, the default behavior, there would be no need for a 
horizontal scrollbar.

Table~\ref{tktext-events} lists all of the events which are associated with the
text widget. The format of text widget indexes, as shown above, is important for
several of the events.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{0.6in}|p{3.3in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt addtag}	&$\rightarrow$&strings& create tag (1st arg), 2nd and 3rd args are indexes \\ \hline
{\tt append}	&$\rightarrow$&string& insert string at end, opt {\em n} params indicate tags \\ \hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+ with Glish event \verb+<G>+ \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt config}	&$\rightarrow$&\verb+<T>+, \verb+<A>+& change attributes \verb+<A>+ of text tagged \verb+<T>+ \\ \hline
{\tt delete}	&$\rightarrow$&string& use one index to delete a character, use two to delete a range \\ \hline
{\tt deltag}	&$\rightarrow$&string& delete tag (1st arg) \\ \hline
{\tt disable}&$\rightarrow$& & disable widget, must be balanced by {\tt enable} \\ \hline
{\tt disabled}	&$\rightarrow$& boolean & set state, disable ({\tt T}) or enable ({\tt F}) \\ \hline
{\tt enable}&$\rightarrow$& & enable widget, must be balanced by {\tt disable} \\ \hline
{\tt font}	&$\rightarrow$& X font & change text font \\ \hline
{\tt foreground}&$\rightarrow$& X color & change foreground color \\ \hline
{\tt get}	&$\Leftrightarrow$&string& use one index to get a character, use two to get a range \\ \hline
{\tt height}	&$\rightarrow$&integer& height in lines \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt insert}	&$\rightarrow$&string& insert string, 2nd param is the insert index, opt {\em n} params indicate tags \\ \hline
{\tt prepend}	&$\rightarrow$&string& insert string at start, opt {\em n} params indicate tags \\ \hline
{\tt ranges}	&$\Leftrightarrow$&string& get ranges for given tag \\ \hline
{\tt relief}	&$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt see}	&$\rightarrow$&string& index indicates a position to scroll to \\ \hline
{\tt view}	&$\rightarrow$&record& scrollbar update event \\ \hline
{\tt width}	&$\rightarrow$&integer& width in {\em character} units \\ \hline
{\tt wrap}	&$\rightarrow$& {\tt 'none'} {\tt 'char'} {\tt 'word'} & change line wrap behavior \\ \hline
{\tt xscroll}	&$\leftarrow$&double& information for horizontal scrollbar update \\ \hline
{\tt yscroll}	&$\leftarrow$&double& information for vertical scrollbar update \\ \hline
\end{tabular}
\end{center}
}
\caption{ Text Events }
\label{tktext-events}
\index{tk!text!events}
\end{table}
\index{tk!text|)}
\FloatBarrier

\section{Canvas}
\index{tk!canvas|(}
The {\em canvas} widget is the most complicated widget discussed in this chapter.
It implements a generalized drawing surface. This means that from {\em
Glish} the user can draw on the canvas and later interact with the
objects drawn on the screen.
Here is a reasonably simple example that draws a stop sign on the canvas and then
sets it up so that it is draggable by the user:
\begin{verbatim}
    f := frame()
    cf := frame(f,side='left',borderwidth=0)
    c := canvas(cf)
    vsb := scrollbar(cf)

    bf := frame(f,side='right',borderwidth=0,expand='x')
    pad := frame(bf,expand='none',width=23,height=23,relief='groove')
    hsb := scrollbar(bf,orient='horizontal')

    whenever vsb->scroll, hsb->scroll do
        c->view($value)
    whenever c->yscroll do
        vsb->view($value)
    whenever c->xscroll do
        hsb->view($value)
    poly := c->poly(20,-40,40,-20,40,20,20,40,-20,40,-40,
                    20,-40,-20,-20,-40,fill='red',tag='stop')
    edge := c->line(20,-40,40,-20,40,20,20,40,-20,40,-40,20,-40,-20,
                    -20,-40,20,-40,fill='white',width='5',tag='stop')
    word := c->text(0,0,text='STOP',fill='white',tag='stop')
    c->move("all",50,50)
    c->bind('stop','<Button-1>','snag')
    c->bind('stop','<B1-Motion>','drag')
    whenever c->snag do
        state := $value.cpoint
    whenever c->drag do
        {
        tmp := c->move($value.tag, $value.cpoint - state)
        state := $value.cpoint
        }
\end{verbatim}
Two frames are first constructed to contain the scrollbars, as
in previous examples, and then the {\em canvas} widget and the 
scrollbars are created
in these frames (Table~\ref{tkcanvas-params} lists all of the creation parameters
for {\em canvas}). Then {\tt canvas} drawing operations are used to draw the
sign.

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{1.6in}|p{1.9in}|}
\hline
Parameter & Default & Values & Description \\
\hline
\hline
{\tt parent}		& 		& widget & parent \\ \hline
{\tt width}		& {\tt 200}	& dimension & width of canvas \\ \hline
{\tt height}		& {\tt 150}	& dimension & height of canvas \\ \hline
{\tt region}		& \verb+[0,0,1000,400]+ & integer & integer array specifies the underlying drawing region \\ \hline
{\tt relief}		& {\tt 'sunken'}& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & edge relief \\ \hline
{\tt borderwidth}	& {\tt 2}	& dimension & border width \\ \hline
{\tt background}	& {\tt 'lightgrey'}& X color & background color \\ \hline
{\tt fill}		& {\tt 'both'}	& {\tt 'x'} {\tt 'y'} {\tt 'both'} {\tt 'none'} & how to expand when resized \\ \hline
{\tt hlcolor}		& {\tt ''}	& X color & highlight color with focus \\ \hline
{\tt hlbackground}	& {\tt ''}	& X color & highlight color without focus \\ \hline
{\tt hlthickness}	& {\tt []}	& dimension & hightlight border thickness \\ \hline
\end{tabular}
\end{center}
}
\caption{ Canvas Construction Parameters }
\label{tkcanvas-params}
\index{tk!canvas!construction parameters}
\end{table}

All drawing operations return an identifier. In this example,
three things are drawn onto the canvas; a {\tt red} polygon, {\tt poly}, a white
border for the polygon, {\tt edge}, and a text message, {\tt word}. The identifier
returned by these operations can later be used for other operations on the item.
Also note that each item is tagged with an additional name, {\tt stop}. This
is done with the {\tt tag} parameter. After that, the entire collection of items
drawn can be referred to as {\tt stop}. The {\tt move} event simply moves items
on the canvas. In this case, all of the items drawn are shifted from the top
left corner of the drawing surface. This is necessary because the items were
drawn about the origin, and the underlying drawing surface only goes from
\verb+[0,0]+ to \verb+[1000,400]+, the default range. The drawing surface could
just as easily start at \verb+[-1000,-400]+.

The two {\tt bind} events bind mouse events to {\em Glish} events. 
The first says that
whenever button one is pressed when the cursor is over the {\tt stop} items generate
a {\tt snag} event. The second says whenever button one is moved (after first being
pressed) when the cursor is over the {\tt stop} items generate a {\tt drag} event.
Any X event on the canvas can be bound to a {\em Glish} event in this
manner. The two
{\tt whenever} statements operate on these events. The first stores the canvas
position of the cursor in {\tt state} when the {\tt snag} event is generated. The
second requests that the item the {\tt drag} event is generated for,
\verb+$value.tag+ i.e. {\tt stop}, be moved by the difference of the previous and
current mouse positions. It then updates the {\tt state} for the next time. This
 looks like the dialog shown in Figure~\ref{tkcanvas}, after the stop sign has
been dragged a bit. Table~\ref{tkcanvas-events} describes the events that can be
sent to a canvas. The mouse events which can be bound to {\em Glish} 
events in the canvas correspond to the standard {\em X} events. 

\begin{figure}[thb]
%\htmlimage{useimg=tkcanvas.gif}
%\latex{\centerline{\psfig{figure=tkcanvas.eps,scale={0.7}}}}
\centerline{\psfig{figure=tkcanvas.eps,scale={0.7}}}
\caption{ Canvas }
\label{tkcanvas}
\end{figure}

\begin{table}[tbh]
{\small
\begin{center}
\begin{tabular}{|c|c|p{0.6in}|p{3.3in}|}
\hline
Event & I/O & Values & Description \\
\hline
\hline
{\tt addtag}	&$\rightarrow$&\verb+<N>+ \verb+<O>+& add tag \verb+<N>+ to items tagged with \verb+<O>+ \\ \hline
{\tt arc}	&$\Leftrightarrow$&integer& draw arc \\ \hline
{\tt background}&$\rightarrow$& X color & change background color \\ \hline
{\tt bind}	&$\rightarrow$&\verb+<T>+ \verb+<X>+ \verb+<G>+& associate Xevent \verb+<X>+, in tagged item \verb+<T>+ with Glish event \verb+<G>+; \verb+<T>+ is optional \\ \hline
{\tt borderwidth}&$\rightarrow$& dimension & change border width \\ \hline
{\tt canvasx}   &$\Leftrightarrow$&integer& convert from window coordintates to canvas coordinates \\ \hline
{\tt canvasy}	&$\Leftrightarrow$&integer& convert from window coordintates to canvas coordinates \\ \hline
{\tt delete}	&$\rightarrow$&string& delete items with specified tag \\ \hline
{\tt deltag}	&$\rightarrow$&string& delete the tag \\ \hline
{\tt foreground}&$\rightarrow$& X color & change foreground color \\ \hline
{\tt frame}	&$\Leftrightarrow$&integer& create a frame widget at the specified location \\ \hline
{\tt height}	&$\rightarrow$&integer& height in lines \\ \hline
{\tt hlbackground}&$\rightarrow$& X color & highlight color without focus \\ \hline
{\tt hlcolor}	&$\rightarrow$& X color & highlight color with focus \\ \hline
{\tt hlthickness}&$\rightarrow$& dimension & hightlight border thickness \\ \hline
{\tt line}	&$\Leftrightarrow$&integer& draw line \\ \hline
{\tt move}	&$\rightarrow$&string/integer& move tagged items specified offset \\ \hline
{\tt oval}	&$\Leftrightarrow$&integer& draw oval \\ \hline
{\tt poly}	&$\Leftrightarrow$&integer& draw polygon \\ \hline
{\tt rectangle}	&$\Leftrightarrow$&integer& draw rectangle \\ \hline
{\tt relief}	&$\rightarrow$& {\tt 'flat'} {\tt 'ridge'} {\tt 'raised'} {\tt 'sunken'} {\tt 'groove'} & change border relief \\ \hline
{\tt region}	&$\rightarrow$&4 integers& set the dimension of the canvas region \\ \hline
{\tt tagabove}	&$\rightarrow$&\verb+<N>+ \verb+<O>+& add tag \verb+<N>+ to item above \verb+<O>+ in display list \\ \hline
{\tt tagbelow}	&$\rightarrow$&\verb+<N>+ \verb+<O>+& add tag \verb+<N>+ to item above \verb+<O>+ in display list \\ \hline
{\tt text}	&$\Leftrightarrow$&string& draw text \\ \hline
{\tt view}	&$\rightarrow$&record& scrollbar update event \\ \hline
{\tt width}	&$\rightarrow$&integer& width in {\em character} units \\ \hline
{\tt xscroll}	&$\leftarrow$&double& information for horizontal scrollbar update \\ \hline
{\tt yscroll}	&$\leftarrow$&double& information for vertical scrollbar update \\ \hline
\end{tabular}
\end{center}
}
\caption{ Canvas Events }
\label{tkcanvas-events}
\index{tk!canvas!events}
\end{table}
\index{tk!canvas|)}

\section{Version Number and Utility Functions}

\index{{\tt system} global variable!{\tt tk}|(}
\label{system-tk}
The information about which version of Tk is currently being used can be
obtained from the {\tt system} record, e.g. :
\begin{verbatim}
    print "tk version:", system.tk.version, system.tk.version::, system.tk.version::tcl::
\end{verbatim}
prints something like:
\begin{verbatim}
    tk version: 8.0 [patch=8.0p2, tcl=8.0] [patch=8.0p2]
\end{verbatim}
\index{{\tt system} global variable!{\tt tk}|)}

Finally, there are a couple of utility functions you might find useful.

\indfunc{have\_gui}
You can use {\tt have\_gui} \label{have_gui-func}
to check if a graphical output device is available.
It returns {\tt T} if such a device is available and the Tk widgets
can be used. Otherwise, it returns {\tt F}.

\indfunc{tk\_hold}
\indfunc{tk\_release}
Typically, {\tt tk\_hold} and {\tt tk\_release} \label{tk_hold-func}
\label{tk_release-func}
are not needed, but sometimes when a large number of widget
creation/deletion operations are done, the GUI may go through contortions. This
is due to intermediate operations being processed and reflected in the GUI before
the group of operations has finished. Therefore, {\tt tk\_hold} and 
{\tt tk\_release} can
often be used to take care of this problem. A call to {\tt tk\_hold} prevents any
Tk operations from being processed until {\tt tk\_release} is called.

It is {\em important} that calls to {\tt tk\_hold} be balanced with an equal
number of calls to {\tt tk\_release}. Otherwise, the GUI can freeze preventing
any further interaction.

\index{tk|)}
