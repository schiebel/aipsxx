% $Header: /home/cvs/casa/code/doc/reference/Glish.dir/example.tex,v 19.0 2003/07/16 04:18:46 aips2adm Exp $

\chapter{An Example of Using Glish}

For an idea of the sorts of problems {\em Glish} is meant for and how it's used
to solve them, consider a simple
example\index{Glish!simple example}\index{example!of using Glish}
where you want to repeatedly view
readings generated by an instrument attached to a remote computer called
``mon".  Suppose you have a program {\em measure} that reads values from the
special hardware device and converts them into two floating-point arrays,
{\tt x} and {\tt y} and another program, {\em display},
for plotting the x/y data, which you  want to run on your
local workstation.  Therefore {\em measure} needs to run on the remote host ``mon",
because that's where the special hardware resides, and you  need 
to use  {\em display}, that has a ``Take Measurements"
button, to click on to instruct the hardware to take a new set of
measurements.

\begin{figure}[h]
\centerline{\psfig{figure=ex1.idraw,width={3.0in},height={1.0in}}}
\caption{ Simple Two-Program Distributed System }
\label{ex1}
\end{figure}

The first problem is simply to connect 
{\em measure} and {\em display} so that when {\em measure} produces
new values they're shown by {\em display\/}, and when you click
the display's button {\em measure} goes off and reads new values.
Figure~\ref{ex1}
illustrates the flow of control and data: {\em display} tells {\em measure}
to take measurements, and {\em measure} informs display when new measurements
are available.

To implement this in {\sc Unix} requires constructing
a session-layer protocol\index{protocol!session-layer}
that then has to be implemented on top of
sockets or RPC.  When using {\em Glish},
though, the protocol and the communication mechanism are
built-in.\index{protocol!built-in}
Every program in a {\em Glish} system communicates by generating {\em events\/},
messages with a name and a value.\index{events!introduction}
For this simple system you might
write {\em measure} so that whenever new readings become available it
generates an event called ``{\tt new\_data}".  The value of
this event will be a record with two elements, {\tt x} and~{\tt y}, the two
arrays of numbers it has computed from the raw measurements.  You 
write {\em display} so that when it receives a {\tt new\_data}
event it expects the value of the event to be a record with at least
{\tt x} and~{\tt y} fields; it then plots those values.  Similarly,
when you push the ``Take Measurements" button {\em display} will
generate a {\tt take\_data} event, and whenever {\em measure}
receives a {\tt take\_data} event it will get a new set of
readings and generate a new {\tt new\_data} event.

Here is a {\em Glish} script that creates the two processes when
executed (one process remotely) and conveys  messages to each
other\index{example!two intercommunicating processes}:
\begin{verbatim}
    m := client("measure", host="mon")
    d := client("display")

    whenever m->new_data do
        d->new_data( $value )

    whenever d->take_data do
        m->take_data( $value )
\end{verbatim}
When {\em Glish} executes the first two lines of this script it creates instances
of {\em measure} (running on the host ``mon") and {\em display} (running
locally) and assigns to the variables {\tt m} and {\tt d} values
corresponding to these {\em Glish} clients.  Executing the next line:
\begin{verbatim}
    whenever m->new_data do
\end{verbatim}
specifies that whenever the client associated with {\tt m}
generates a {\tt new\_data} event, execute the following statement:
\begin{verbatim}
        d->new_data( $value )
\end{verbatim}
This statement says to send a new event to the client associated with {\tt d}.
The event's name will be {\tt new\_data} and the event's value
is specified by whatever comes inside the parentheses; in this case,
the special expression {\tt \$value}, indicating the
value of the most recently received event ({\em measure\/}'s
{\tt new\_data} event).

The last two lines of the script are analogous; they say that whenever
{\em display} generates a {\tt take\_data} event an event with the
same name and value should be sent to {\em measure\/}.

This system could easily be a bit more complicated.  Suppose prior to
viewing the measurements with {\em display}, you first want to perform some
transformation on them.  The transformation might, for example, calibrate the
values and scale them into different units, filter out part of the values,
or FFT the values to convert them into frequency spectra.  Rather than
building the transformation into {\em measure\/}, you would like your
system to be modular\index{modularity},
so you use a separate program called {\em transform\/}.

\begin{figure}[thb]
\centerline{\psfig{figure=ex2.idraw,width={3.0in},height={1.3in}}}
\caption{ Three-Program Distributed System }
\label{ex2}
\end{figure}

Figure~\ref{ex2} shows the flow of control and data in this new system.
The {\em measure} values are sent to {\em transform\/}; {\em transform}
derives some transformed values and sends them to {\em display\/};
and {\em display} tells {\em measure} when to take more measurements.
With {\em Glish} it's easy to accommodate this
change\index{example!three intercommunicating processes}:
\begin{verbatim}
    m := client("measure", host="mon")
    d := client("display")
    t := client("transform")

    whenever m->new_data do
        t->new_data( $value )

    whenever t->transformed_data do
        d->new_data( $value )

    whenever d->take_data do
        m->take_data( $value )
\end{verbatim}
The third line runs {\em transform} on the local host and assigns a
corresponding value to the variable {\tt t}.  The first {\tt whenever}
forwards {\tt new\_data} events from {\em measure} to
{\em transform\/}. The second {\tt whenever} forwards
{\em transform\/}'s {\tt transformed\_data} events to {\em display\/},
but changes the event name to {\tt new\_data}, because that's what
{\em display} expects.  The third {\tt whenever} is the same as before.

\begin{figure}[thb]
\centerline{\psfig{figure=ex3.idraw,width={3.0in},height={2.0in}}}
\caption{ Conceptual Event Flows vs. Actual Flows }
\label{ex3}
\end{figure}

An important point in  this example is that {\em conceptually} control and
data flow directly from one program to another, in reality all events pass
through the {\em Glish} interpreter as \index{events!flow of!actual}
Figure~\ref{ex3} illustrates.  Here solid lines show the paths  events actually
travel, while dashed lines indicate the conceptual
flow\index{events!flow of!conceptual}.  Although  this
centralized architecture doubles the cost of simple ``point-to-point"
communication, it
buys enormous flexibility.  For example, suppose you sometimes  want to
use {\em transform} before viewing the data and other times you don't.
You add to {\em display} another button that lets you choose between
the two.  It generates a {\tt set\_transform} event with a boolean value.
If the value is true then you first pass the measurements through
{\em transform\/}, otherwise you don't.

To accommodate this change in our {\em Glish} program you can add a global
variable {\tt do\_transform} to control whether or not you use {\em transform\/}:
\begin{verbatim}
    m := client("measure", host="mon")
    t := client("transform")
    d := client("display")
    do_transform := T

    whenever m->new_data do
        {
        if ( do_transform )
            t->new_data( $value )
        else
            d->new_data( $value )
        }

    whenever t->transformed_data do
        d->new_data( $value )

    whenever d->take_data do
        m->take_data( $value )

    whenever d->set_transform do
        do_transform := $value
\end{verbatim}
You initialize {\tt do\_transform} to {\tt T}, the boolean ``true" constant.
You change it whenever {\em display} generates a {\tt set\_transform} event
(see the last two lines).  When {\em measure} generates a {\tt new\_data}
event you test the variable to determine whether to pass the event's value
along to {\em transform} or directly to {\em display\/}.

Furthermore, if the data transformation done by {\em transform} is fairly
simple, you can skip writing a program to do the work and instead just
use {\em Glish}\index{example!data transformation with {\em Glish}}.
For example, suppose the transformation is to find all of
the {\tt x} measurements that are larger than some threshold, and then
to set those {\tt x} measurements to the threshold value and the
corresponding {\tt y} measurements to 0.  You can do the transformation
in {\em Glish} using:
\begin{verbatim}
    m := client("measure", host="mon")
    d := client("display")
    do_transform := T

    if ( len(argv) > 0 )
        thresh := as_double(argv[1])
    else
        thresh := 1e6

    whenever m->new_data do
        {
        if ( do_transform )
            {
            too_big := $value.x > thresh
            $value.x[too_big] := thresh
            $value.y[too_big] := 0
            }

        d->new_data( $value )
        }

    whenever d->take_data do
        m->take_data( $value )

    whenever d->set_transform do
        do_transform := $value
\end{verbatim}
Here you first check to see whether any arguments were passed to
the {\em Glish} script and if so you initialize {\tt thresh} to be
the first argument interpreted as a double precision value.  If
no arguments were given then you use a default value of one million.

Now whenever {\em measure} generates a {\tt new\_data} event and
you want to do the transformation, you set {\tt too\_big} to a
boolean mask\index{example!boolean mask}
selecting those {\tt x} elements that were larger
than {\tt thresh}.  You then set those {\tt x} elements to
the threshold, zero the corresponding {\tt y} elements, and pass
the result to {\em display} as a {\tt new\_data} event.  You have
eliminated the need for {\em transform\/}.

Finally, for situations in which performance is vital {\em Glish} provides
point-to-point links between programs.\index{example!point-to-point links}
The {\tt link} statement
\index{example!{\tt link} statement}
\index{link statement!example}
connects events generated by one program directly to
another program.  The {\tt unlink}
statement
\index{example!{\tt unlink} statement}
\index{unlink statement!example}
suspends such a link
(further events are sent to the central {\em Glish} interpreter) until
another {\tt link}.  Here is the last example written to use
point-to-point links:
\begin{verbatim}
    m := client("measure", host="mon")
    d := client("display")

    link m->new_data to d->new_data

    if ( len(argv) > 0 )
        thresh := as_double(argv[1])
    else
        thresh := 1e6

    whenever m->new_data do
        {
        too_big := $value.x > thresh
        $value.x[too_big] := thresh
        $value.y[too_big] := 0
        d->new_data( $value )
        }

    whenever d->take_data do
        m->take_data( $value )

    whenever d->set_transform do
      {
      if ( $value )
        unlink m->new_data to d->new_data
      else
        link m->new_data to d->new_data
      }
\end{verbatim}
Now you no longer need the {\tt do\_transform} variable.  Instead you
create a link for {\em measure\/}'s {\tt new\_data} events
directly to {\em display\/}.  Whenever {\em display} sends a
{\tt set\_transform} event requesting that the transformation be activated,
you break the direct link between {\em measure} and {\em display}.  Now
when {\em measure} generates {\tt new\_data} events they are sent to
{\em Glish}, which then transforms the data and passes it along to {\em display\/}.

  One other
important point is that because {\em measure\/}, {\em transform\/}, and
{\em display} are all written in an event-driven style, each can be
easily replaced by a different program that has the same ``event
interface".\index{event interface@``event interface''}
As  scientific programmers you will often want to
replace {\em measure} with {\em simulate\/} (a program that 
simulates the
quantity being measured), {\em display} with a non-interactive 
program once the measurement cycle is ironed out, 
and {\em transform} with a
variety of different transformations.  You also might want to run
{\em measure} and {\em simulate} together, so you can 
compare {\em simulate\/}'s
model with the actual phenomenon measured by {\em measure\/}.  The ability
to quickly ``plug in" different programs in this fashion is one of
{\em Glish}'s main benefits.  These examples illustrate the main goals
of {\em Glish}\index{Glish!main goals}: making it easy to dynamically 
connect processes in a distributed system and providing powerful ways
to manipulate data sent between processes.
