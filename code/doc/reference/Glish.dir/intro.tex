% $Header: /home/cvs/casa/code/doc/reference/Glish.dir/intro.tex,v 19.0 2003/07/16 04:18:48 aips2adm Exp $

\chapter{Introduction}
\pagenumbering{arabic}
{\em Glish} is a freely available\footnote{See Chapter~\ref{copyright} for copyright information.}
programming language and part of the 
AIPS++ Project of the National Radio Astronomy Observatory.  This
language was created by Vern Paxson (vern@ee.lbl.gov) and Chris
Saltmarsh (salty@farpoint.co.uk) at Lawrence Berkeley Laboratory.  
{\em Glish} is now maintained and developed by Darrell Schiebel
(drs@nrao.edu) at the National Radio Astronomy Observatory 
in Charlottesville, Virginia.  

{\em Glish} is used for building loosely-coupled distributed
systems\index{distributed systems!loosely-coupled}.
``Loosely-coupled" means the programs in a {\em Glish}
system communicate with one another at fairly low rates (perhaps 
a hundred times a second).  ``Distributed systems" means 
programs in the {\em Glish} system can run on different computers,
communicating transparently over a network.

The main thrust of {\em Glish} is that individual programs in the
system should be wholly modular, with no knowledge of other programs or
data types that might exist in the system.  {\em Glish} provides a uniform way
for programs to communicate without knowing about one another.  Communication
occurs because the programs are written in terms of
{\em events\/}\index{events},
i.e. name/value pairs.  In the usual case, programs receive an event, perform
an action in response to that event, and possibly generate one or
more new events associated with the response.  An example is an FFT
``server"\index{FFT server}
that might be sent an event with the name ``please-FFT-this"
and an associated value of an array of double precision data.  In this
case the
server generates an ``FFT-done" event whose value is two arrays,
the Fourier components of the original data.  Programs can
also spontaneously create events in response to external actions, such as a
piece of hardware signaling that some condition has changed, a timer going
off, or a person interacting with a graphical interface.

{\em Glish} consists of three parts\index{Glish!system, elements of}:
\begin{enumerate}

\item the {\em Glish} language for writing {\em scripts}\index{scripts}
specifying what programs to run and how to interconnect them;

\item a C++ class library\index{client library}
that programs ({\em Glish} {\em clients\/})
link with so they can generate and receive events and manipulate
structured data;

\item an interpreter\index{interpreter} process for executing {\em
Glish} scripts
and acting as a central ``clearinghouse" for forwarding events between
processes.

\end{enumerate}

The {\em Glish} system is very flexible\index{Glish!flexibility}:
\begin{itemize}

\item existing programs can be turned into {\em Glish} clients either by
writing event-oriented, C++ ``wrappers"\index{wrappers}
around them or by encapsulating
their filter behavior\index{filters}
using {\tt stdin} and {\tt stdout} events;

\item clients in a {\em Glish} script can run on different computers,
which can have heterogeneous architectures;

\item providing a full programming language for manipulating the
events and data generated by and sent to clients.

\end{itemize}

Overviews of the {\em Glish} system can be found in the
papers\index{Glish!references} ``{\em Glish\/}:
A User-Level Software Bus for Loosely-Coupled Distributed Systems,",
by Vern Paxson and Chris Saltmarsh, Proceedings of the 1993 Winter USENIX
Technical Conference, ``{\em Glish\/}: A Software Bus for
High-Level Control,'' by Vern Paxson, Proceedings of the 1993 International
Conference on Accelerator and Large Experimental Physics Control Systems,
to appear in {\em Nuclear Instruments and Methods in Physics Research\/},
and ``Programming in Glish,'' by Darrell Schiebel, Proceedings of the 1995
Astronomical Data Analysis Software and Systems conference. PostScript for
these papers is also distributed with {\em Glish}, in the files
\mbox{\em doc/USENIX-93.ps\/}, \mbox{\em doc/ICALPECS-93.ps}, and
\mbox{\em doc/ADASS-95.ps}.

This manual is intended to provide full documentation for users of the
{\em Glish} system, both for those who  write {\em Glish} scripts for
creating applications from existing {\em Glish} clients, and for those who want
to write new {\em Glish} clients.  The main emphasis is on the {\em Glish} script
language, which is very powerful and can often be used to avoid having
to write lengthier programs in C or C++.

To convey the feel of using {\em Glish}, the next chapter presents
examples illustrating how {\em Glish} is used to build a simple 
distributed system.

Chapter 3 begins discussion of {\em Glish} as an {\em array-oriented} language with a look
at the different types of values that can be manipulated in a {\em Glish} script.
{\em Glish} provides many operators
for succinctly manipulating arrays of numeric and string-valued data.
This chapter covers the {\em Glish} type system, array manipulation
operators, and ways in which {\em Glish} values are created from constants.

Chapter~\ref{expressions} covers the use of {\em expressions\/} to create
values from other values using {\em expressions\/}.

Chapter~\ref{statements} then looks at the different {\em statements}
available in the {\em Glish} language for assigning values to variables,
print values, testing conditions, looping, and sending and receiving
events.

Chapter~\ref{functions} discusses how to create and use functions.

Chapter~\ref{events} discusses {\em Glish} events in full detail, and
the following chapter presents the {\em Glish} {\em Client Library\/}, which
is used by programs to connect to the {\em Glish} system.

Chapter~\ref{io} discusses how to read and write {\sc ASCII} files.

Chapter~\ref{debugging-logging-fail} discusses how {\em fail values} are
used to propagate and report errors. This chapter also discusses other
debugging tools.

Chapter~\ref{predefineds} details the functions and variables that
are predefined by {\em Glish} for use in {\em Glish} scripts; an index is given
at the end of this chapter.

Chapter~\ref{glishtk} discusses a particularly useful client which allows
graphical user interfaces to be created and controlled from {\em Glish}
scripts.

Chapter~\ref{using-glish} discusses how to use the {\em Glish} interpreter,
and how to debug {\em Glish} clients.

Chapter~\ref{cli-editing} discusses features for editing
commands entered at {\em Glish}'s command-line interface.

Chapter~\ref{client-lib} discusses the C++ library which is used to create
{\em Glish} clients.

Chapter~\ref{internals} looks ``under the hood" at how the {\em Glish}
system works from a systems programmer's point-of-view, and
chapter~\ref{cli-editing} describes the command line editing
feature.

Finally, Chapter~\ref{changes} documents the changes between the various
{\em Glish} releases, Chapter~\ref{bugs} lists all of the known {\em Glish bugs}, and
Chapter~\ref{future} discusses those areas where {\em Glish} is likely to change
in the future.  Chapter~\ref{ack} lists acknowledgments for {\em Glish}'s
development, and Appendix~\ref{grammar} provides the {\em Glish} syntax and
grammar.
