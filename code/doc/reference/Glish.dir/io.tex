% $Header: /home/cvs/casa/code/doc/reference/Glish.dir/io.tex,v 19.0 2003/07/16 04:19:15 aips2adm Exp $

\chapter{Input and Output}
\label{io}

\index{I/O|(}
\index{input and output|(}
{\em Glish} has three basic input-output modes. Scripts can process ASCII files,
prompt for input from the user or provide output to the user, and individual
values can be read and written in a machine independent binary format. This chapter
introduces {\em Glish}'s I/O mechanisms.

\section{ASCII I/O}

ASCII files combined with regular expressions (See \xref{regular-exprs}) are the
most flexible I/O mechanism in {\em Glish}.

\subsection{Opening Files}

The {\tt open} function is used to open files in a {\em Glish} script. This function is
modeled upon the {\tt open} function in \htmllink{{\em Perl}}{\perlurl}. {\tt open}
is passed one string. This string describes both the file name and how the file should be opened.
To open a file for reading, you would do something like:
\begin{verbatim}
    x := open("< /etc/passwd")
\end{verbatim}
This would open the file {\tt /etc/passwd} for reading. {\sc Unix} shell style redirection is
used within the string to indicate how the file is to be opened. In a similar manner, a
file would be opened for writing like:
\begin{verbatim}
    y := open("> /tmp/foo")
\end{verbatim}
Opening a file this way will result in any contents in the file being overwritten. If instead,
you want to append to an existing file, you would open the file like:
\begin{verbatim}
    y := open(">> /tmp/foo")
\end{verbatim}
Output can also be piped through a process, and input can be generated by a process. Here
are some examples:
\begin{verbatim}
    z1 := open("| cat -n > /tmp/bar")
    z2 := open("cat -n /etc/passwd |")
\end{verbatim}
In the case of {\tt z1}, the output written to {\tt z1} first goes through the {\tt cat}
process, and then it is written to the file {\tt /tmp/bar}. {\tt cat} is used to create
the input to be read from {\tt z2}. Finally, it is also possible to open a file for writing
to a process, and then read the output of the process. Here is an example:
\begin{verbatim}
    z3 := open("| cat -n | tee /tmp/out |")
\end{verbatim}
This example sends the output written to {\tt z3} through two processes, i.e. {\tt cat} and
{\tt tee}. The output of {\tt tee} provides the input to be read from {\tt z3}. This sort of
writing and reading from a process must be used {\em very carefully} because it relies on
buffering by the operating system, and there can be problems if the buffers fill up.

\indfunc{is\_file}\label{is_file-func}
The {\tt is\_file} function can be used to check if a variable is a file handle
or not.

\subsection{Reading}
\indfunc{read}\label{read-func}
Once a file has been opened for reading, there are two different ways to read the
information from the file. The first is to use the {\tt read} function. By default,
this function reads one line from a file (up to and including the newline). It returns
a zero length string when the end of the file is reached. So if you wanted to print
out the {\tt /etc/passwd} file, you could do something like:
\begin{verbatim}
    x := open("< /etc/passwd")
    while ( line := read(x) ) print line
\end{verbatim}
{\tt read} can also be used to read a specified number of characters from a file, for
example:
\begin{verbatim}
    x := open("< /etc/passwd")
    print read(x,40,'c')
\end{verbatim}
would print out something like:
\begin{verbatim}
    root:x:0:1:Super-User:/:/sbin/sh
    daemon:
\end{verbatim}
Here forty characters were read from the file. Newlines are included, but treated no different
than any other character. If you want to read bytes instead of characters, use a {\tt 'b'}
parameter instead of a {\tt 'c'} parameter. In this case, an array of bytes will be returned.

In addition, there is a special syntax (similar to that provided by {\em Perl}) for reading
files. Using this syntax, a file can be read like:
\begin{verbatim}
    x := open("< /etc/passwd")
    while ( <x> ) print _
\end{verbatim}
\label{io-and-regex}
The angle brackets, e.g. \verb+<x>+, perform an operation equivalent to:
\begin{verbatim}
    _ := read(x)
\end{verbatim}
The underscore is special because it is the default variable for regular expression
application. If you tried either this example or the last, you will have noticed that
there is an extra newline for each line printed. This is because each line read from
the file has an embedded newline character, and the {\tt print} statement adds another
newline. The last example could be rewritten to chop off the embedded newline as:
\begin{verbatim}
    x := open("< /etc/passwd")
    while ( <x> ) print ~ s/\n$//
\end{verbatim}
Notice that this uses the unary application of a regular expression (using the underscore
variable) to chop off the trailing newline. This loop is exactly equivalent to:
\begin{verbatim}
    while ( _ := read(x) ) print _ ~ s/\n$//
\end{verbatim}

\subsection{Writing}

Writing to a file can be accomplished with either the standard {\tt write} function or
the {\sc Unix} {\em stdio.h} styled {\tt fprintf}.

\indfunc{write}\label{write-func}
The {\tt write} function simply converts one or more values to strings and writes them
to a file, for example:
\begin{verbatim}
    x := open("| cat -n |")
    write(x,[a=1:3, b=3.6+1.06i])
    print read(x)
\end{verbatim}
would print:
\begin{verbatim}
         1  [a=[1 2 3] , b=3.6+1.06i]
\end{verbatim}
There is an an optional separator value ({\tt sep}) which can be used to set
the separator between values like:
\begin{verbatim}
    write( x, 1, 2, [a=1:3, b=3.6+1.06i], 3, 4, sep='@' )
    write( x )
    print read(x)
\end{verbatim}
would print:
\begin{verbatim}
         2  1@2@[a=[1 2 3] , b=3.6+1.06i]@3@4@
\end{verbatim}
The extra \verb+write(x)+ is important because it writes out a newline.
Without it, the {\tt read} would hang because it reads until a newline is
encountered. The first write changed the separator from the default
\verb+'\n'+ to \verb+@+ so no newline was written as part of the initial
{\tt write}.

\indfunc{fprintf}\label{fprintf-func}
{\tt fprintf} is also available for writing to a file. Here is an example:
\begin{verbatim}
    fprintf(x,'%x ',76:83)
    write(x)
    print read(x)
\end{verbatim}
would print:
\begin{verbatim}
         3  4c 4d 4e 4f 50 51 52 53
\end{verbatim}
(See \xref{sprintf-func} for a discussion of all of the options available with
{\tt fprintf}.)

\section{User Interaction}

\indfunc{printf}\label{printf-func}
There have been many examples of printing output for the user using the
{\tt print} statement. You can also generate output for the user using
{\tt printf}. Here is an example:
\begin{verbatim}
    printf('The current register value is 0x%x\n',753) 
\end{verbatim}
would result in the output:
\begin{verbatim}
    The current register value is 0x2f1
\end{verbatim}
(See \xref{sprintf-func} for a discussion of all of the options available with
{\tt printf}.)

\indfunc{readline}\label{readline-func}
You can get input from the user using the {\tt readline} function. This
function allows the user to enter strings to be used by a script, for example:
\begin{verbatim}
    print readline()
\end{verbatim}
would prompt the user with \verb+>>+:
\begin{verbatim}
    >> first string
\end{verbatim}
and the string entered by the user, here \verb+first string+, is returned as
the result of \verb+readline()+. The prompt can be changed from the default
\verb+>>+ to something else with the {\tt prompt} parameter:
\begin{verbatim}
    print readline(prompt='ANOTHER>> ')
\end{verbatim}
In this case, \verb+ANOTHER>>+ is used to prompt the user.
The {\tt readline} function allows the user to edit the input using the same
command line editing package that {\em Glish} uses to get input
(See \xref{cli-editing}).

\section{Binary I/0}
\label{reading-writing}
\label{binary-io}
\index{predefined functions!reading and writing values|(}
\index{values!functions to read and write|(}
You store {\em Glish} values to a file and read them from a file in
binary format using {\tt write\_value()} and {\tt read\_value()}.

\label{write_value-func}
\indfunc{write\_value}
{\tt write\_value(value, file)} writes a representation of the given
{\tt value} to the {\tt file} (which should be a {\tt string}).
\index{events!inter-client encoding restrictions}
Presently only values of type {\em numeric\/}, {\tt string}, or
{\tt record} are supported.  Values of type {\tt reference} are first
dereferenced before being written.

{\tt write\_value()} returns {\tt T} if successful and {\tt F} if not.

\label{read_value-func}
\indfunc{read\_value}
{\tt read\_value(file)} reads a {\em Glish} value from the {\tt file}
(interpreted as a {\tt string}) and returns it, or {\tt F} if it
encountered problems.

Note that when stored in files {\em Glish} values correspond to {\em SOS}
datasets. (See \cxref{internals}, for a discussion of {\em SOS\/}.)
\index{values!functions to read and write|)}
\index{predefined functions!reading and writing values|)}

\section{File Information}

\indfunc{is\_asciifile}\label{is_asciifile-func}
There are two functions which allow the status of a file to be checked. {\tt is\_asciifile()}
returns true if the file argument is an ASCII file:
\begin{verbatim}
    is_asciifile('/etc/passwd')
\end{verbatim}
should return {\tt T} because \verb+/etc/passwd+ is an ASCII file,
\begin{verbatim}
    is_asciifile('/bin/cat')
\end{verbatim}
should return {\tt F} since \verb+/bin/cat+ is a binary executable. The optional
second parameter to \verb+is_asciifile()+ specifies how many character should
be checked in the file before concluding that the file is indeed ASCII. So:
\begin{verbatim}
    is_asciifile('/bin/cat',4)
\end{verbatim}
might return {\tt T} because executables often have an ASCII identifier as their
first few characters, and this example only checks the first four characters.

\indfunc{stat}\label{stat-func}
The {\tt stat} function returns general information about a given file. This example:
\begin{verbatim}
    stat('/var')
\end{verbatim}
would return a record containing most of the important information about
the file. At some point, the result of {\tt stat} will be expanded to
provide information about the contents of directories and information to
follow symbolic links. {\tt stat} has two extra optional the first
is the number of bytes to check to differentiate ASCII files
from other files. The second parameter is a {\tt boolean} value,
false by default, which indicates if symbolic links should be followed.
\index{input and output|)}
\index{I/O|)}
