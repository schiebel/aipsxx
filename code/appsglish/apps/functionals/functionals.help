%% Copyright (C) 2002,2003,2004
%% Associated Universities, Inc. Washington DC, USA.
%%
%% This library is free software; you can redistribute it and/or modify it
%% under the terms of the GNU Library General Public License as published by
%% the Free Software Foundation; either version 2 of the License, or (at your
%% option) any later version.
%%
%% This library is distributed in the hope that it will be useful, but WITHOUT
%% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
%% License for more details.
%%
%% You should have received a copy of the GNU Library General Public License
%% along with this library; if not, write to the Free Software Foundation,
%% Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
%%
%% Correspondence concerning AIPS++ should be addressed as follows:
%%        Internet email: aips2-request@nrao.edu.
%%        Postal address: AIPS++ Project Office
%%                        National Radio Astronomy Observatory
%%                        520 Edgemont Road
%%                        Charlottesville, VA 22903-2475 USA
%%
%% $Id: functionals.help,v 19.5 2004/09/03 07:38:38 cvsmgr Exp $
\documentclass{book}
\usepackage{aips2help,html}
\begin{document}


\begin{ahmodule}{functionals}{Functionals handling}

\ahinclude{functionals.g}

\ahkeyword{functions}{}


\begin{ahdescription}

\bigskip

{\it Introduction}

A functional is a function with parameters, defined as $f(p;x)$, where
$p$ are the parameters, and $x$ the arguments. Methods are available to
calculate the value of a function for a series of argument values for
the given set of parameters, and for the automatic calculation of the
derivatives with respect to the parameters.

The created functionals can be used in the fitting \tool\ or in any
other \tool\ that needs to have generic function values or their derivatives.

A functional has a mask associated with it, to indicate if certain
parameters have to be solved for. See
\ahlink{masks}{functionals:functionals.masks} for details.

To access the {\mf functionals} module, include the {\em functionals.g}
\glish\ script.  This will create a default Functionalserver \tool\
called {\stf dfs}.

\begin{verbatim}
- include 'functionals.g'
- dfs.type()             # Default tool created for you
functionals
\end{verbatim}

The Functionalserver \tool\ has no state (it doesn't remember
anything), so there is generally no need to create your own \tool;
just use the default one.  However, if you do require one, perhaps
in a script, then use the {\cf functionals} constructor to make one.

\begin{verbatim}
- include 'functionals.g';
- myqt := functionals();
- myqt.type();  
functionals
\end{verbatim}

The basic purpose of the Functionalserver \tool\ is to create
Functional \tools.  You do not create Functional \tools\
directly (the Functional \tool\ has no constructor), you
always create them via the Functionalserver \tool.  

Functionals are created in a variety of ways, in general by
specifying the name of the functional, together with some necessary
information like e.g. the order of a polynomial, or the code needed
to compile your privately defined function. Parameters can be set at
creation time or later.

\begin{verbatim}
- include 'functionals.g'
- a := dfs.gaussian1d()	           # creates a 1D Gaussian, default arguments
- b := dfs.functional('gaussian1') # creates the same one
- a.state()                        # the 'state' of the functional
[type=0, order=-1, ndim=1, npar=3, params=[1 0 1] ] 
- a.type()                         # its type
gaussian1d 
- a.ndim()                         # its dimension (number of arguments)
1 
- a.npar()                         # its number of parameters
3 
- b.state()
[type=0, order=-1, ndim=1, npar=3, params=[1 0 1] ] 
- a.f(1);                          # the value at x=1
0.0625
- a.fdf([0,0.5]);                  # value and derivatives
[[1:2,]
    1   1   0       0
    0.5 0.5 1.38629 0.693147] 
\end{verbatim}

In some cases an {\em order} can be specified as well (e.g. for
polynomials):
\begin{verbatim}
- include 'functionals.g'
- a := dfs.poly(3)               # creates a 3rd order polynomial
- b := dfs.functional('polyn',3) # creates the same one, but with
                                 # original defaults
- a.state()
[type=5, order=3, ndim=1, npar=4, params=[1 1 1 1] ] 
- b.state()
[type=5, order=3, ndim=1, npar=4, params=[0 0 0 0] ] 
\end{verbatim}

An extremely valuable aspect of the Functionals module is the ability to
create a functional from a compiled string specifying an arbitrary
function.  For example, let us make our own polynomial $1 + 2*x + 3*x^2$
and evaluate it at a few abcissa locations

\begin{verbatim}
- include 'functionals.g'
- a := dfs.compiled ('p0 + p1*x + p2*x*x', [1,2,3])   # Define
- a.f([0,10,20])                                      # Evaluate at x=[0,10,20]
[1 321 1241]  
\end{verbatim}


The functions created can also be used to specify the function to be
fitted in a least squares fit (see the fitting \tool\ ).

\end{ahdescription}

\ahfuncs{}
\ahobjs{}


\begin{ahfunction}{is\_functional}{Check if functional}
\begin{ahargs}
\ahaddarg[in]{v}{value to be tested}{}{any}
\end{ahargs}
\ahreturns{Bool}
\begin{ahdescription}
Checks if the operand is a correct functional
\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- a := dfs.gaussian1d()         # make a functional
- is_functional(a)              # is it one?
T 
- a.done()
T 
- is_functional(a)
F 
-
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahobject}{functionalserver}{functionalserver tool}
\ahcategory{utility}
\ahkeyword{functionals}{}

\ahfuncs{}

\begin{ahconstructor}{functionals}{Construct functionalserver tool}
\begin{ahargs}
\ahaddarg[in]{host}{host on which to run tool}{''}{valid host name string}
\ahaddarg[in]{forceneweserver}{force the use of a new
server}{F}{bool}
\end{ahargs}
\ahreturns{functionalserver tool or fail}
\begin{ahdescription}
Create a functionalserver \tool on the specified host (or by default the
host you are running on). 
\end{ahdescription}
\end{ahconstructor}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{names}{Show the known functional names}
\begin{ahargs}
\end{ahargs}
\ahreturns{String array}
\begin{ahdescription}

Return the known functional names.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- dfs.names()
	gaussian1d gaussian2d gaussian3d gaussianNd hyperplane polynomial
	evenpolynomial oddpolynomial sinusoid1d chebyshev butterworth combine
	compound compiled
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{functional}{Create the named functional}
\begin{ahargs}
\ahaddarg[in]{name}{name of functional to create}{unset}{string}
\ahaddarg[in]{order}{order if appropriate}{depending on functional}{integer}
\ahaddarg[in]{params}{parameters}{depending on functional}{numeric array}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

Create the named functional. If an order is specified it is used,
otherwise the default functional is created with the specified (or
default) parameters. Naming is minimum-match, case insensitive. See
the separate {\em combine}, {\em compound} and {\em compiled}
descriptions for more information on these special cases.

\begin{tabular}{|c|c|c|l|}
\hline 
Name & Order & Default order & Default parameters \\
\hline
\hline
gaussian1d & - & - & [1 0 1] \\
gaussian2d & - & - & [1 0 0 1 1 0] \\
gaussian3d & - & - & [1 0 0 0 1 1 1 0 0] \\
gaussianNd & y & 2 & [0.159155 0 0 1 1 0] (note height) \\
hyperplane & y & 0 & [0] \\
polynomial & y & 0 & [0] (see separate poly)\\
evenpolynomial & y & 0 & [0] \\
odd polynomial & y & 0 & [0] \\
sinusoid1d & - & - & [1 1 0] \\
chebyshev & y & 0 & [0] \\
butterworth & - & 0 & [0] \\
combine & - & - & [] (all 1 after adds)\\
compound & - & - & [] (copied from added functions) \\
compiled & y & - & [...] (a list of zeroes: see separate compiled) \\
\hline
\end{tabular}

A created functional (or {/em function} for short, but be aware of
possible \glish\ terminology clashes) will have a set of basic
methods, which are described in the {\em functional} tool.



\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.functional('poly', 2, [1,2,3]) # create a polynomial
- a.f([0,1,2])                          # get some values
[1 6 17]  
- a.fdf([0,1,2])                        # get values and derivatives
[[1:3,]
    1  1 0 0
    6  1 1 1
    17 1 2 4] 
- b:=dfs.functional('combi')            # a combine
- b.add(a)                              # with the polynomial
T 
- b.f([0,1,2])                          # values are same
[1 6 17]  
- b.add(b)                              # add again
T 
- b.f([0,1,2])                          # as expected from the combination
[2 12 34]  
\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{gaussian1d}{Create a 1D Gaussian function}
\begin{ahargs}
\ahaddarg[in]{height}{amplitude of Gaussian, or 3 values}{1}{numeric}
\ahaddarg[in]{center}{center of Gaussian}{0}{numeric}
\ahaddarg[in]{width}{HPBW width of Gaussian}{1}{numeric}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

Create a 1-dimensional Gaussian with the specified height, width and
center. The created functional has methods {\em f} and {\em fdf} to
calculate the function value at a series of {\em x} values, or the
value and the derivatives with respect to the parameters.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
# get the value and derivatives of a Gaussian with
# height=2; center at x=1; a width of 1 at x=[0,1,2]
- dfs.gaussian1d([2,1,1]).fdf([0,1,2])
[[1:3,]
    0.125 0.0625 -0.693147 0.693147
    2     1      0         0
    0.125 0.0625 0.693147  0.693147] 

\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{gaussian2d}{Create a 2D Gaussian function}
\begin{ahargs}
\ahaddarg[in]{params}{amplitude, centers, major width, ratio, angle
of Gaussian}{[1 0 0 1 1 0]}{numeric}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

Create a 2-dimensional Gaussian with the specified height, width and
center. The created functional has methods {\em f} and {\em fdf} to
calculate the function value at a series of {\em x} values, or the
value and the derivatives with respect to the parameters.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
# get the value and derivatives of a Gaussian with
# height=2; centers at x,y=1; widths of 1 at x,y=[0,0,1,1,2,2]
- dfs.gaussian2d([2,1,1,1,1,0]).fdf([0,0,1,1,2,2])
[[1:3,]
    0.0078125 0.00390625 -0.0433217 -0.0433217 0.0866434 0.0433217 -0
    2         1          0          0          0         0         -0
    0.0078125 0.00390625 0.0433217  0.0433217  0.0866434 0.0433217 -0] 

\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{poly}{Create a 1D polynomial function}
\begin{ahargs}
\ahaddarg[in]{order}{polynomial degree}{0}{integer}
\ahaddarg[in]{params}{factors of terms}{all 1}{numeric}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

Create a polynomial of specified degree. The default parameters are
all 1. (Note that using the generic {\em functional} function the
parameters are all set to zero).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- dfs.poly(2).f([1,2])
[3 7]  
- dfs.poly(2).state() 
[type=5, order=2, ndim=1, npar=3, params=[1 1 1] ] 
- dfs.poly(2).type() 
polynomial 
-
\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{oddpoly}{Create an odd 1D polynomial function}
\begin{ahargs}
\ahaddarg[in]{order}{polynomial degree}{0}{integer}
\ahaddarg[in]{params}{factors of terms}{all 1}{numeric}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

Create an odd polynomial of specified degree. The default parameters are
all 1. (Note that using the generic {\em functional} function the
parameters are all set to zero).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- dfs.oddpoly(2).f([1,2])
[2 10]  
- dfs.oddpoly(2).npar()  
2 

\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{evenpoly}{Create an even 1D polynomial function}
\begin{ahargs}
\ahaddarg[in]{order}{polynomial degree}{0}{integer}
\ahaddarg[in]{params}{factors of terms}{all 1}{numeric}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

Create an even polynomial of specified degree. The default parameters are
all 1. (Note that using the generic {\em functional} function the
parameters are all set to zero).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- dfs.evenpoly(2).fdf([1,2])
[[1:2,]
    2 1 1
    5 1 4] 
- dfs.evenpoly(2).state()   
[type=6, order=3, ndim=1, npar=2, params=[1 1] ] 

\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{chebyshev}{Create a 1D Chebyshev polynomial function}
\begin{ahargs}
\ahaddarg[in]{order}{order of the polynomial}{0}{integer}
\ahaddarg[in]{params}{the Chebyshev coefficients}{all 0}{numeric}
\ahaddarg[in]{xmin}{the minimum value of the interval of interest}{-1}{numeric}
\ahaddarg[in]{xmax}{the maximum value of the interval of interest}{-1}{numeric}
\ahaddarg[in]{ooimode}{the ``out-of-interval'' mode.  This controls
what gets returned when an input value to the function is outside the
interval of interest.}{a minimum match to the following values:
'constant' -- the value of the def argument; 'zeroth' -- the value of
the zero-th order coefficient; 'extrapolate' -- the function evaluated
explicitly at the input value; 'cyclic' -- the function evaluated at
the input value after ``folding'' it into the interval of interest;
'edge' -- the function evaluated at the nearest edge of the interval
of interest}{'constant'}
\ahaddarg[in]{def}{the default value to return for input values
outside of the interval of interest when ooimode='constant'}{0}{numeric}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

This function creates a functional representing a Chebyshev series, a
linear combination of so-called Chebyshev polynomials. 

\bigskip
\textbf{About Chebyshev Polynomials}
\bigskip

Chebyshev polynomials are a special type of ultraspheric polynomials 
that are useful in such contexts as numerical analysis and circuit
design. They form an orthogobnal set.  A (type I) Chebyshev
polynomial, $T_n$, is generated via the equation:

\begin{equation}
  T_n(x) = \cos n(\arccos x)
\end{equation}

Through clever use of trigometric identities, one can express $T_n$
as a real polynomial expression of the form

\begin{equation}
  T_n(x) = \sum_{i=0}^{n} C_i t^i
\end{equation}
The low order polynomials look like this:
\begin{eqnarray}
  T_0 & = & 1 \\
  T_1 & = & x \\
  T_2 & = & 2x^2 - 1 \\
  T_3 & = & 4x^3 - 3x \\
  T_4 & = & 8x^4 - 8x^2 + 1 \\
  T_5 & = & 16x^5 - 20x^3 + 5x 
\end{eqnarray}
Higher order polynomials satisfy the recurrance relation,
\begin{equation}
  T_{n+1} = 2xT_n - T_{n-1}.
\end{equation}

A common use of Chebyshev polynomials is in approximating
functions.  In particular, any function that is approximated by
a power series,
\begin{equation}
  f(x) \sim \sum P_i x^i,
\end{equation}
over the interval [-1, 1] can be approximated by a linear
combination of Chebyshev polynomials:
\begin{equation}
  f(x) \sim \sum C_i T_i(x),
\end{equation}
where $C_i$ is the set of so-called Chebyshev coefficients.

Approximating a function with Chebyshev polynomials has some
important advantages.  For one, if the function is well approximated
by a converging power series, one can obtain an equally accurate
estimate using fewer terms of the corresponding Chebyshev series.
More important, though, is the property over the interval [-1, 1],
each polynomial has a domain of [-1, 1]; thus, the series is nicely
bounded.  And because of this bounded property, approximations
calculated from a Chebyshev series are less susceptible to machine
rounding errors than the equivalent power series.  

\bigskip
\textbf{The ``Interval of Interest''}
\bigskip

Of course, in most real applications of these polynomials, one doesn't
want to be limited to the [-1, 1] interval; thus, it is necessary to
map the actual \emph{interval of interest} into [-1, 1] before
evaluating the series.  The \texttt{chebyshev} functional supports
this automatically when one sets the \texttt{xmin} and \texttt{xmax}
arguments to this function.  The mapping of values within this
interval into [-1, 1] is done as follows:

\begin{equation}
x^\prime = x - (\mathtt{min} + \mathtt{max})/2) / 
((\mathtt{max} - \mathtt{min})/2)
\end{equation}

When the functional is evaluated via \texttt{f()}, the input values are
first tranformed in the above way, and then the series is evaluated
using the given coefficients.  This is assuming the input value is
within the interval of interest.  

The behavior of the function when the value is outside the interval of
interest is configurable via the \texttt{ooimode}.  The choices are as
follows: 

\begin{description}
\item[constant] the value returned is the value set with the
\texttt{def} argument.
\item[zeroth] the value returned is the value of the zero-th order
coefficient.  Thus, if \texttt{params=[3,1,1]}, 3 is returned.
\item[extrapolate] the function is evaluated based on its coefficients
just as it would be inside the interval.  Thus, the function's range is not
guaranteed to remain within the characteristic bounds of the
Chebyshev interval.  As the input value departs from the interval, the
returned value diverges toward +/- infinity.  
\item[cyclic] the function is evaluated as if the range is cyclic,
repeating the range values from its canonical domain.  The period of
the cycle will be equal to $\mathtt{xmax}-\mathtt{xmin}$.  When the 
function is evaluated outside this interval, the input value will 
shifted an integer number of periods until it falls within the 
Chebyshev interval; the value returned is the polynomial evaluated 
at the shifted value.  
\item[edge] the value of the nearest edge of the interval of interest
is returned.
\end{description}

The default out-of-interval mode is \texttt{constant}.  

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cheb := dfs.chebyshev(2, [2, 3, 4])
- cheb.state()
[type=9, order=2, ndim=1, npar=3, params=[2 3 4] , masks=[T T T] , 
mode=[interval=[-1 1] , default=0, intervalMode=constant]] 
- cheb.f([0, 0.5, 1, 2, 5])
[-2 1.5 9 0 0]  
- cheb := dfs.chebyshev(2, [2, 3, 4], xmin=0, xmax=2, ooimode='extrap')
[type=9, order=2, ndim=1, npar=3, params=[2 3 4] , masks=[T T T] , 
mode=[interval=[0 2] , default=0, intervalMode=extrapolate]] 
- cheb.state()
- cheb.f([0, 0.5, 1, 2, 5])
[3 -1.5 -2 9 138]  
\end{verbatim}
\end{ahexample}

\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{butterworth}{Create an approximation of butterworth
bandpass}
\begin{ahargs}
\ahaddarg[in]{minorder}{the order of the minimum (high-pass) cutoff of
the curve}{1}{integer}
\ahaddarg[in]{maxorder}{the order of the maximum (low-pass) cutoff of
the curve}{1}{integer}
\ahaddarg[in]{mincut}{the characteristic cutoff value of the minimum
(high-pass) portion of the curve.}{-1.0}{numeric}
\ahaddarg[in]{maxcut}{the characteristic cutoff value of the maximum
(low-pass) portion of the curve.}{1.0}{numeric}
\ahaddarg[in]{center}{the location of the peak of the bandpass
curve}{0.0}{numeric} 
\ahaddarg[in]{peak}{the maximum value of the bandpass
curve}{1.0}{numeric} 
\end{ahargs}
\ahreturns{Functional}

\begin{ahdescription}
This function creates a functional that simulates the (amplitude)
transfer function for a wideband bandpass filter constructed from the
combination of a low-pass and a high-pass Butterworth filter.  It is
not an exact representation.  In particular is includes a
discontinuity at the bandpass peak.  Thus, care should be taken when
evaluating derivatives of or fitting this function.  

In analog electronic filter design, a Butterworth low-pass filter is 
one in which the amplitude transfer function, $|H(j\omega)|$ (where 
$j = \sqrt{-1}$ and $\omega$ is the angular frequency), is given by:
\begin{equation}
  |H(j\omega)| = \frac{1}{\sqrt{1 + (\omega/\omega_c)^{2n}}}
\end{equation}
where $n$ refers to the filter "order" and $\omega_c$ is the "cutoff
frequency".  When $\omega = \omega_c$, the filter output is $1/\sqrt{2}$
that of the input, and the higher the order, the steeper the drop off
towards zero and the closer the approximation to a idealized step
function. 

Filter theory provides transformations for deriving transfer functions 
of high-pass and band-pass filters which reflect how the electrical 
circuits actually work.  However, to simplify this class's implementation 
and to make the transfer function behavior more predictable by the naive 
user, this functional does not actually use the proper transformations.
Instead, the Butterworth bandpass transfer function is approximated by 
low pass component, given above, combined with a pseudo high-pass function
that is of the same form but with $\omega$ substituted with $-\omega$.
Both components are shifted such that its peak transfer point is at a
given "center" position.  

The character of the band edges can be set independently for both ends
of the passband.  The cuttoff value--where the signal is attenuated to
$1/\sqrt{2}$ of the peak--is set with the \texttt{mincut} and
\texttt{maxcut} arguments for the low end (i.e. high-pass) and high
end (i.e. low-pass) portions of the curve, respectively.  This value
is the value of $\omega_c$ for each side of the passband.  The order of
the attenuation curve--$n$ in the above formula--can be set using
\texttt{minorder} and \texttt{maxorder}.  
\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- butt := dfs.butterworth(minorder=4, maxorder=4, mincut=10,
                          maxcut=50, center=30, peak=1)
- butt.state()
[type=10, order=-1, ndim=1, npar=4, params=[30 10 50 1] , masks=[T T T T] , 
mode=[minOrder=4, maxOrder=4]]
- butt.f([0, 7, 10, 13, 30, 47, 50, 53, 60])
[0.193786 0.496351 0.707107 0.886488 1 0.886488 0.707107 0.496351 0.193786]  
\end{verbatim}

To plot this function...
\begin{verbatim}
- include 'pgplotter.g'
- pg := pgplotter()
- x := [-30:90]
- y := butt.f(x)
- pg.plotxy1(x, y, ylab='Bandpass')
\end{verbatim}
\end{ahexample}

\end{ahfunction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{combi}{Create a combination function}
\begin{ahargs}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

Create a function consisting of a combination of one or more
functions. Each partaking function will be defined as a normal
function with its own parameters. The combination function will have
parameters equal to the number of functions added. I.e. the added
functions are considered encapsulated simple functions.
Only functions with the same number of dimensions can be
combined. See also {\em compound}.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.poly(2,[1,2,3])        # a polynomial
- a.f(1)                        # its value at x=1
6 
- b:=dfs.gaussian1d(10, 0.5, 1) # a Gaussian with height, center, width
- b.f(1)
5 
- c:=dfs.combi(); c.add(a); c.add(b)  # combine them
T 
T 
- c.f(1)                        # value is the sum (default parameters are 1)
11 
- c.setpar(1, 2.5)              # set the first parameter of combi to 2.5
[2.5 1]  
- c.f(1)                        # now value is 2.5*poly + 1*gauss
20 
-

\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{compound}{Create a compound function}
\begin{ahargs}
\end{ahargs}
\ahreturns{Functional}
\begin{ahdescription}

Create a function consisting of a combination of one or more
functions, creating a compound function. The compound resulting
functions is a function with the sum of all the parameters of the
partaking functions. If a parameter of the compound function is
changed, the parameter of the constituting function is changed as well.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.poly(2,[1,2,3])        # a polynomial
- a.f(1)                        # its value at x=1
6 
- b:=dfs.gaussian1d(10, 0.5, 1) # a Gaussian with height, center, width
- b.f(1)
5 
- c:=dfs.compound(); c.add(a); c.add(b) # compound them
T 
T 
- c.f(1)                        # result is sum
11 
- c.state()                     # the function description
[type=11, order=-1, ndim=1, npar=6, params=[1 2 3 10 0.5 1] ,
    nfunc=2, funcs=[__*0=[type=5, order=2, ndim=1, npar=3,
                          params=[1 2 3] ],
                    __*1=[type=0, order=-1, ndim=1, npar=3,
                          params=[10 0.5 1] ]]] 
- c.setpar(1, 2.5)              # set the first parameter of compound to 2.5
[2.5 2 3 10 0.5 1]  
- c.f(1)                        # now value is 1.5 greater since zeroeth
                                # order of poly is now 2.5 i.s.o. 1
12.5
-

\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{compiled}{Create your own function}
\begin{ahargs}
\ahaddarg[in]{code}{programmable expression string}{''}{string}
\ahaddarg[in]{params}{optionally parameters to be set}{unset}{double
array}
\end{ahargs}
\ahreturns{Functional or fail}
\begin{ahdescription}

Create a function based on the programable string. The string should
be a single expression, which can use the standard operators and
functions and parentheses, having a single value as a result. The
{\em parameters} of the function can be addressed with the $p$
variable. This variable can be indexed in two ways. The first way is
using the standard algebraic way, where the parameters are: $p$ (or
$p0$), $p1$, $p2$, ... . The second way is by glish indexing, where
the parameters are addressed as: $p[1]$, $p[2]$, ... . The arguments
are accessed in the same way, but using the variable name $x$. The
compilation determines the number of dimensions and parameters of
the produced function.\\
Operators are the standard operators (including comparisons, which
produce a zero or one result; and conditional expression).\\
In addition to the standard expected functions, there is an $atan$
with either one or two arguments (although $atan2$ exists as well),
and $pi$ and $ee$ with no or one argument. The functional created
behaves as all other functionals, and hence can be used in combinations.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.compiled('sin(pi(0.5) ) +pi'); # an example
- a.state()                             # and its result
[type=12, order=-1, progtext=sin(pi(0.5) ) +pi, ndim=0, npar=0, params=] 
- a.f(0)                                # note that a value is
                                        # necessary to produce non-empty 
                                        # result
4.14159 
-  a.fdf([0])                           # no derivatives: sine no parameters
[1:1,]
    4.14159] 
- b:= dfs.functional('compil','p*exp(-(x/p[2])^2') # try one to show error
SEVERE: Method define fails!
Illegal compiled expression:
No closing function paranethesis at: 
'p*exp(-(x/p[2])^2'''
- b:= dfs.functional('compil','p*exp(-(x/p[2])^2)') # try again
				        # Now a Gaussian with height
					# and halfwidth 0
- b.parameters()
[0 0] 
- b.setparameters([10 1])		# change to height 10 and
					# halfwidth 1 
10 1]
- b.f([-1,-0.5,0,.5,1])
[3.67879 7.78801 10 7.78801 3.67879] 
- # the next one is sync(x), catering for x=0
- # using the fact that comparisons deliver values. Note
- # the extensive calculation to make sure no divison by 0 
- synca:=
 dfs.compiled('( (x==0) * 1)+( (x!=0) * sin(x+(x==0)*1)/(x+(x==0)*1) )')
- synca.f([-1,0,1])
[0.841471 1 0.841471]  
- sin(1)/1
0.841471 

- # using conditional expressions:
- dfs.compiled('x==0 ? 1 : sin(x)/x').f([-1,0,1])
[0.841471 1 0.841471]  


\end{verbatim}

\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{id}{identification of tool}
\begin{ahargs}
\end{ahargs}
\ahreturns{object id}
\begin{ahdescription}
id will return the object identification. Its use is meant for the
toolmanager.
\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- dfs.id()
[sequence=1, pid=6053, time=1020745837, host=cetus, agentid=4] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%

\begin{ahfunction}{type}{type of tool}
\begin{ahargs}
\end{ahargs}
\ahreturns{string}
\begin{ahdescription}
type will return the tool name.
\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- dfs.type()
functionals 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%

\begin{ahfunction}{done}{free resources used by tool}
\begin{ahargs}
\ahaddarg[in]{kill}{force kill of the default tool}{F}{bool}
\end{ahargs}
\ahreturns{bool}
\begin{ahdescription}
done will free the resources used by the tool. If the tool is the
default tool ({\em dm}) the done will only be executed if the kill
argument is true.
\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=functionals()
- a.done()
T 
- dfs.done()
F 
- dfs.done(kill=T)
NORMAL: Successfully closed empty server: functionals
T 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{ahobject}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahobject}{functional}{functional tool}
\ahcategory{utility}
\ahkeyword{functionals}{}

\ahfuncs{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{type}{Show the type name}
\begin{ahargs}
\end{ahargs}
\ahreturns{String}
\begin{ahdescription}

Return the known functional type.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.type()
gaussian1d 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{npar}{Show the number of parameters}
\begin{ahargs}
\end{ahargs}
\ahreturns{integer}
\begin{ahdescription}

Return the number of parameters.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.npar()
3
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{ndim}{Show the number of dimensions}
\begin{ahargs}
\end{ahargs}
\ahreturns{integer}
\begin{ahdescription}

Return the number of dimensions.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.ndim()
1
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{order}{Show the order or similar information}
\begin{ahargs}
\end{ahargs}
\ahreturns{integer or -1}
\begin{ahdescription}

Return the order of the functional when relevant (e.g. of polynomial).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- b:=dfs.poly(2)      
- a.order()
-1 
- b.order()
2 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{parameters}{Show the functional parameters}
\begin{ahargs}
\end{ahargs}
\ahreturns{value array or fail}
\begin{ahdescription}

Return the parameter values.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.parameters()
[1 0 1]  
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{setparameters}{Set the functional parameters}
\begin{ahargs}
\ahaddarg[in]{par}{parameters to be set}{unset}{value array}
\end{ahargs}
\ahreturns{bool or fail}
\begin{ahdescription}

Set all the parameter values

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T 
- a.parameters()           
[2 1 3]  
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{par}{Show a single parameter}
\begin{ahargs}
\ahaddarg[in]{n}{parameter index}{1}{integer}
\end{ahargs}
\ahreturns{value or fail}
\begin{ahdescription}

Show a parameter value

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T 
- a.parameters()           
[2 1 3]  
- a.par(2)
1 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{setpar}{Set a single parameter}
\begin{ahargs}
\ahaddarg[in]{n}{parameter index}{1}{integer}
\ahaddarg[in]{v}{parameter values to be set}{1}{value}
\end{ahargs}
\ahreturns{value array or fail}
\begin{ahdescription}

Set a parameter value, and return the new suite of values

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T 
- a.parameters()           
[2 1 3]  
- a.setpar(2,5)
[2 5 3]  
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{masks}{Show the functional masks}
\begin{ahargs}
\end{ahargs}
\ahreturns{boolean array or fail}
\begin{ahdescription}

Return the mask values. The mask is used when the functional is
fitted. A false ($F$) mask indicates that the parameter is not to be
solved. It also indicates (by the same token) that no derivative is
calculated for that parameter by {\em fdf}.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.masks()
[T T T]  
- a.fdf([0,1])
[[1:2,]
    1      1      0        0
    0.0625 0.0625 0.346574 0.346574] 
- a.setmask(2,F)
[T F T]  
- a.fdf([0,1])   
x0: 
[[1:2,]
    1      1      0 0
    0.0625 0.0625 0 0.346574] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{setmasks}{Set the functional masks}
\begin{ahargs}
\ahaddarg[in]{mask}{masks to be set}{unset}{boolean array}
\end{ahargs}
\ahreturns{bool or fail}
\begin{ahdescription}

Set all the parameter masks

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setmasks([T,F,F])
T 
- a.masks()           
[T F F]  
- a.fdf([0,1])        
[[1:2,]
    1      1      0 0
    0.0625 0.0625 0 0] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{mask}{Show a single mask}
\begin{ahargs}
\ahaddarg[in]{n}{parameter index}{1}{integer}
\end{ahargs}
\ahreturns{value or fail}
\begin{ahdescription}

Show a parameter mask

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setmasks([T,F,F])
T 
- a.masks()           
[T F F]  
- a.mask(2)
F 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{setmask}{Set a single mask}
\begin{ahargs}
\ahaddarg[in]{n}{parameter index}{1}{integer}
\ahaddarg[in]{v}{parameter mask to be set}{T}{boolean}
\end{ahargs}
\ahreturns{boolean array or fail}
\begin{ahdescription}

Set a parameter mask, and return the new suite of masks

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setmasks([T,F,F])
T 
- a.masks()           
[T F F]  
- a.setmask(2,T)
[T T F]  
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{state}{Show complete state of the functional}
\begin{ahargs} 
\end{ahargs}   
\ahreturns{state record}     
\begin{ahdescription}      

Show the complete state of the functional

\end{ahdescription}   

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T
- a.state()
[type=0, order=-1, ndim=1, npar=3, params=[2 1 3] , masks=[T T F] ]
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{copyfrom}{Copy the complete state of a functional}
\begin{ahargs}         
\ahaddarg[in]{funcin}{functional to be copied from}{unset}{functional}
\end{ahargs} 
\ahreturns{bool or fail}
\begin{ahdescription} 

Show the complete state of the functional

\end{ahdescription} 

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d() 
- a.setparameters([2,1,3])
T 
- a.state()
[type=0, order=-1, ndim=1, npar=3, params=[2 1 3] , masks=[T T T] ] 
- b:=dfs.compiled('p0+p1*x0')
- b.state()
[type=13, order=-1, progtext=p0+p1*x0, ndim=1, npar=2,
	   params=[0 0], masks=[T T] ] 
- b.copyfrom(a)
T 
- b.state()
[type=0, order=-1, ndim=1, npar=3, params=[2 1 3] , masks=[T T T] ] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{f}{Calculate the value of the functional}
\begin{ahargs}
\ahaddarg[in]{x}{argument values}{$[]$}{real}
\end{ahargs}
\ahreturns{scalar or array of doubles}
\begin{ahdescription}

Calculate the value of the functional.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T
- a.f(1)              
2
- a.f([1,2])
[2 1.46973]
\end{verbatim}                                                                 
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{cf}{Calculate the value of the complex functional}
\begin{ahargs}
\ahaddarg[in]{x}{argument values}{$[]$}{complex}
\end{ahargs}
\ahreturns{scalar or array of complexs}
\begin{ahdescription}

Calculate the complex value of the functional.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T 
- a.cf(1)
2+0i 
- a.cf(1+1i)
2.72158+0i 
- a.cf(1i)
1.63224+1.15576i 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{fdf}{Calculate the value and derivatives of the functional}
\begin{ahargs}
\ahaddarg[in]{x}{argument values}{$[]$}{real}
\end{ahargs}
\ahreturns{vector or array of doubles}
\begin{ahdescription}

Calculate the value of the functional for the specified arguments,
and the derivatives with respect to the parameters (taking any
specified mask into account).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T
- a.fdf(1)
[[1:1,]
    2 1 0 0] 
- a.fdf([1,2])
[[1:2,]
    2       1        0        0
    1.46973 0.734867 0.905549 0.30185]
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{cfdf}{Calculate the value and derivatives of the
complex functional}  
\begin{ahargs}
\ahaddarg[in]{x}{argument values}{$[]$}{complex}
\end{ahargs}
\ahreturns{vector or array of complex}           
\begin{ahdescription}

Calculate the value of the functional for the specified complex arguments,
and the derivatives with respect to the parameters (taking any
specified mask into account).
\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T
- a.cfdf(1)
[[1:1,]
    2+0i 1+-0i 0+0i 0+0i] 
- a.cfdf([1,2])
[[1:2,]
    2+0i       1+-0i        0+0i        0+0i
    1.46973+0i 0.734867+-0i 0.905549+0i 0.30185+0i] 
- a.cfdf(1i)   
[[1:1,]
    1.63224+1.15576i 0.81612+0.577882i -1.71778+0.293572i
    0.474734-0.670449i] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{add}{Add a functional to a combi or compound functional}
\begin{ahargs}
\ahaddarg[in]{x}{functional to be added}{}{functional}
\end{ahargs}
\ahreturns{bool}
\begin{ahdescription}

Add another functional to a combi or compound functional.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.poly(2,[1,2,3])        # a polynomial
- a.f(1)                        # its value at x=1
6 
- b:=dfs.gaussian1d(10, 0.5, 1) # a Gaussian with height, center, width
- b.f(1)
5 
- c:=dfs.combi(); c.add(a); c.add(b)  # combine them
T 
T 
- c.f(1)                        # value is the sum (default
parameters are 1)
11 
- c.setpar(1, 2.5)              # set the first parameter of combi
to 2.5
[2.5 1]  
- c.f(1)                        # now value is 2.5*poly + 1*gauss
20 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ahfunction}{done}{Free resources of the functional}
\begin{ahargs}
\end{ahargs}
\ahreturns{bool}
\begin{ahdescription}

Free the functional's resources.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- a:=dfs.gaussian1d()
- a.setparameters([2,1,3])
T 
- a.state()
[type=0, order=-1, ndim=1, npar=3, params=[2 1 3] , masks=[T T T] ] 
- a.done()
T 
- is_functional(a)
F 
- a
F 
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{ahobject}

\end{ahmodule}
\end{document}
