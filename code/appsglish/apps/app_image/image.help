\%% Copyright (C) 1999,2000,2001,2002,2003,2004
%% Associated Universities, Inc. Washington DC, USA.
%%
%% This library is free software; you can redistribute it and/or modify it
%% under the terms of the GNU Library General Public License as published by
%% the Free Software Foundation; either version 2 of the License, or (at your
%% option) any later version.
%%
%% This library is distributed in the hope that it will be useful, but WITHOUT
%% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
%% License for more details.
%%
%% You should have received a copy of the GNU Library General Public License
%% along with this library; if not, write to the Free Software Foundation,
%% Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
%%
%% Correspondence concerning AIPS++ should be addressed as follows:
%%        Internet email: aips2-request@nrao.edu.
%%        Postal address: AIPS++ Project Office
%%                        National Radio Astronomy Observatory
%%                        520 Edgemont Road
%%                        Charlottesville, VA 22903-2475 USA
%%
%% $Id: image.help,v 19.36 2005/11/22 17:59:14 kgolap Exp $
\documentclass{article}
\usepackage{aips2help,html}
\begin{document}
%%
%%--------------------------------------------------------------------------
%%
%% Tool template
%%
%%--------------------------------------------------------------------------
%%

\begin{ahobject}{image}{Operations on images}

\ahinclude{image.g}

\ahcategory{image}

   %
   %ahkeyword registers module keywords
   %
\ahkeyword{image}{}
\ahkeyword{calculator}{}
\ahkeyword{FITS}{}
\ahkeyword{pixels}{}
\ahkeyword{statistics}{}
\ahkeyword{histograms}{}
\ahkeyword{moments}{}
\ahkeyword{convolution}{}
\ahkeyword{smoothing}{}
\ahkeyword{display}{}

\ahmethods{}


%
%

\medskip
\noindent{\bf Summary}

Image tools provides access to \aipspp\ images.    Currently only single
precision floating point \aipspp\ images are supported by the Image \tool. In the
future, complex images will also be supported.

Image tools also provide direct (native) access to \fits\ and Miriad images.
You can also convert these foreign formats to \aipspp\ format (for
optimum processing speed).


\bigskip
{\bf Overview of Image \tool\ functionality}


\begin{itemize}

\item {\bf Conversion - } There is functionality to interconvert between
\aipspp\ images and FITS files. There is also  native access to
a \fits\ file:

\begin{itemize}

\item \ahlink{imagefromfits}{images:image.imagefromfits.constructor} - Convert a FITS image file to an \aipspp\ image

\item \ahlink{tofits}{images:image.tofits} - convert the image to a \fits\ file

\item \ahlink{image}{images:image.image} - native access to a \fits\ file

\end{itemize}



\begin{itemize}

\item \ahlink{imagefromascii}{images:image.imagefromascii.constructor} - Convert an ascii image file to an \aipspp\ image

\item \ahlink{imagefromarray}{images:image.imagefromarray.constructor} - Convert a Glish array into an \aipspp\ image

\item \ahlink{imagefromshape}{images:image.imagefromshape.constructor} - Convert a shape into an \aipspp\ image


\end{itemize}


Finally, some foreign image formats (e.g. Miriad, GIPSY) can be converted to \aipspp\
(if the foreign packages are installed locally) via an intermediate
\fits\ file.   


\begin{itemize}

\item \ahlink{imagefromforeign}{images:image.imagefromforeign.constructor} - Currently
supported are Miriad and GIPSY files.

\end{itemize}



\item {\bf Analysis - } 


\begin{itemize}

\item \ahlink{decompose}{images:image.decompose} - separate a complex image into individual components

\item \ahlink{deconvolvecomponentlist}{images:image.deconvolvecomponentlist} - deconvolve a Componentlist from the restoring beam

\item \ahlink{fft}{images:image.fft} - FFT the image

\item \ahlink{findsources}{images:image.findsources} - Find strong point sources in sky

\item \ahlink{fitsky}{images:image.fitsky} - fit 2-dimensional models to the sky
(see also the \ahlink{imagefitter}{images:imagefitter} \tool.

\item \ahlink{fitpolynomial}{images:image.fitpolynomial} - fit 1-d polynomials 
to profiles and subtract (see also the \ahlink{imageprofilefitter}{images:imageprofilefitter} \tool.

\item \ahlink{fitprofile}{images:image.fitprofile} - fit a 1-d profile with varying
combinations of functional forms (see also the \ahlink{imageprofilefitter}{images:imageprofilefitter} \tool.

\item \ahlink{fitallprofile}{images:image.fitallprofiles} - fit all the
1-d profiles in a region with varying combinations of functional forms 
and write out the fitted and residual images (see also the
\ahlink{imageprofilefitter}{images:imageprofilefitter} \tool.

\item \ahlink{histograms}{images:image.histograms} - compute histograms from the image

\item \ahlink{insert}{images:image.insert} - insert specified image into this image 

\item \ahlink{maxfit}{images:image.maxfit} - Find maximum and do simple parabolic fit to sky

\item \ahlink{modify}{images:image.modify} - modify image by a model

\item \ahlink{moments}{images:image.moments} - compute moments from image

\item \ahlink{momentsgui}{images:image.momentsgui} - compute moments from image via custom GUI interface

\item \ahlink{regrid}{images:image.regrid} - regrid the image to the
specified Coordinate System 

\item \ahlink{rotate}{images:image.rotate} - rotate the coordinate system
and regrid the image to the rotated Coordinate System 

\item \ahlink{rebin}{images:image.rebin} - rebin an image by the specified binning factors

\item \ahlink{statistics}{images:image.statistics} - compute statistics from the image

\item \ahlink{twopointcorrelation}{images:image.twopointcorrelation} - compute
two point autocorrelation functions from the image

\item \ahlink{subimage}{images:image.subimage.function} (function) -
Create a (sub)image from a region of the image


\end{itemize}



\item {\bf Coordinates - } Manipulation of the coordinate system is handled through

\begin{itemize}

\item \ahlink{coordmeasures}{images:image.coordmeasures} - convert from
pixel to world coordinate wrapped as Measures

\item \ahlink{coordsys}{images:image.coordsys} - recover the Coordinate System into
a \ahlink{Coordsys}{images:coordsys} \tool.

\item \ahlink{setcoordsys}{images:image.setcoordsys} - set a new Coordinate System

\item \ahlink{topixel}{images:image.topixel} - convert from world coordinate to pixel coordinate

\item \ahlink{toworld}{images:image.toworld} - convert from pixel coordinate to world coordinate


\end{itemize}

The  \ahlink{coordsys}{images:coordsys} \tool\ provides more extensive
coordinate system manipulation.





\item {\bf Filtering - } Images may be filtered via

\begin{itemize}

\item \ahlink{convolve}{images:image.convolve} - Convolve image with a Glish array or by another image

\item \ahlink{convolve2d}{images:image.convolve2d} - Convolve image by a 2D kernel

\item \ahlink{sepconvolve}{images:image.sepconvolve} - Separable convolution

\item \ahlink{sepconvolvegui}{images:image.sepconvolvegui} - Separable convolution via custom GUI interface

\item \ahlink{hanning}{images:image.hanning} - Hanning convolution along one axis

\end{itemize}

In the future filtering other than convolution will be provided



\item {\bf Display - } 


\begin{itemize}

\item \ahlink{view}{images:image.view} - display image with the  \viewer\

\end{itemize}



\item {\bf Masks - }   Masks may be manipulated via

\begin{itemize}

\item \ahlink{calcmask}{images:image.calcmask.function} - Image mask calculator 

\item \ahlink{maskhandler}{images:image.maskhandler} - handle masks (set, copy, delete, recover names)

\item \ahlink{maskhandlergui}{images:image.maskhandlergui} - handle masks via a GUI interface

\item \ahlink{replacemaskedpixels}{images:image.replacemaskedpixels} - replace the values of pixels
which are masked bad

\item \ahlink{set}{images:image.set} - set pixel and/or mask values with
a scalar in a \region\ of the image

\item \ahlink{summary}{images:image.summary} - lists the mask names
\end{itemize}



\item {\bf Pixel access - }  The pixel and mask values for an image may be
accessed and calculated with via


\begin{itemize}

\item \ahlink{imagecalc}{images:image.imagecalc.constructor} - Create image tool with image calculator

\item \ahlink{image}{images:image.image.constructor} - Create an image tool from an \aipspp\ image

\item \ahlink{calc}{images:image.calc} - Image pixel calculator 

\item \ahlink{calcmask}{images:image.calcmask.function} - Image mask calculator 

\item \ahlink{getchunk}{images:image.getchunk} - get the pixel values
from a regular region of the image into a Glish array

\item \ahlink{getregion}{images:image.getregion} - get pixels and mask from a \region\ of the image

\item \ahlink{getslice}{images:image.getslice} - get a 1-D slice from the image

\item \ahlink{pixelvalue}{images:image.pixelvalue} - get image value for specified pixel

\item \ahlink{putchunk}{images:image.putchunk} - put pixels from a Glish
array into a regular region of the image

\item \ahlink{putregion}{images:image.putregion} - put pixels and mask
into a \region\ of the image

\item \ahlink{set}{images:image.set} - set pixel and/or mask values with
a scalar in a \region\ of the image

\end{itemize}




\item {\bf Inquiry - } Functions to report basic information about the
image are
  
\begin{itemize}
\item \ahlink{boundingbox}{images:image.boundingbox} - find bounding box of a \region.

\item \ahlink{brightnessunit}{images:image.brightnessunit} - Get image brightness unit

\item \ahlink{haslock}{images:image.haslock} - does this image have a lock set

\item \ahlink{history}{images:image.history} - recover/list history file

\item \ahlink{id}{images:image.id} - Return the fundamental identifier of this \tool\

\item \ahlink{ispersistent}{images:image.ispersistent} - is the image persistent (on disk)

\item \ahlink{name}{images:image.name} - name of the \imagefile\ this tool is attached to

\item \ahlink{restoringbeam}{images:image.restoringbeam} - Get restoring beam

\item \ahlink{shape}{images:image.shape} - the length of each axis in the image

\item \ahlink{summary}{images:image.summary} - summarize basic information about the image

\item \ahlink{type}{images:image.type} - the type of this Image \tool\

\end{itemize}




\item {\bf Utility - }  There is wide range of utility services available
through the functions

\begin{itemize}

\item \ahlink{adddegaxes}{images:image.adddegaxes} - Add degenerate axes

\item \ahlink{addnoise}{images:image.addnoise} - Add noise to the image

\item \ahlink{brightnessunit}{images:image.brightnessunit} - Get image brightness unit

\item \ahlink{close}{images:image.close} - Close the \imagetool\ (but don't destroy it)

\item \ahlink{convertflux}{images:image.convertflux} Convert flux density between
peak and integral

\item \ahlink{convertsm}{images:image.convertsm} Convert the image so that older
versions can read it

\item \ahlink{delete}{images:image.delete} - delete the \imagefile\ associated with this Image \tool\

\item \ahlink{done}{images:image.done} - destroy this \imagetool\

\item \ahlink{haslock}{images:image.haslock} - does this image have a lock set

\item \ahlink{history}{images:image.history} - recover/list history file

\item \ahlink{imagefiles}{images:image.imagefiles} - Find the names of all image files in the given directory

\item \ahlink{imagetools}{images:image.imagetools} - Find the names of all global image \tools\

\item \ahlink{imagedones}{images:image.imagedones} - Run the done function on the given (or all) global image \tools\

\item \ahlink{is\_image}{images:image.is_image} - Is this variable an Image \tool\

\item \ahlink{isopen}{images:image.isopen} - Is this Image \tool\ open ?

\item \ahlink{lock}{images:image.lock} - acquire a lock on the image

\item \ahlink{makecomplex}{images:image.makecomplex} - make a complex image from two real images

\item \ahlink{miscinfo}{images:image.miscinfo} - recover miscellaneous information record

\item \ahlink{open}{images:image.open} - open a new \imagefile\ with this image tool

\item \ahlink{rename}{images:image.rename} - rename the \imagefile\ associated with this Image \tool\

\item \ahlink{restoringbeam}{images:image.restoringbeam} - Get restoring beam

\item \ahlink{setbrightnessunit}{images:image.setbrightnessunit} - Set image brightness unit

\item \ahlink{sethistory}{images:image.sethistory} - set the history file

\item \ahlink{setmiscinfo}{images:image.setmiscinfo} - set the miscellaneous information record

\item \ahlink{setrestoringbeam}{images:image.setrestoringbeam} - Set new restoring beam

\item \ahlink{unlock}{images:image.unlock} - release lock on this \imagefile\

\end{itemize}


\item {\bf Reshaping - }  Images can be reshaped via

\begin{itemize}

\item \ahlink{imagefromimage}{images:image.imagefromimage.constructor} (constructor)
- Create a (sub)image from a region of an \aipspp\ image

\item \ahlink{subimage}{images:image.subimage.function} (function) -
Create a (sub)image from a region of the image

\item \ahlink{insert}{images:image.insert} - insert specified image into this image 

\item \ahlink{imageconcat}{images:image.imageconcat.constructor} - Concatenate \aipspp\ images

\end{itemize}




\item {\bf Tests and demos - }  

\begin{itemize}

\item \ahlink{imagetest}{images:imagetest.function} - Run test suite for Image \tool\

\item \ahlink{imagedemo}{images:imagedemo.function} - Demonstrate the use of an image

\end{itemize}

\end{itemize}




\medskip
\noindent{\bf General}

We refer to an \aipspp\ \imagefile\ when we are referring to the actual
data stored on disk.  The name that you give an \aipspp\ \imagefile\ is
actually the name of a directory containing a collection of \aipspp\
tables which together constitute the \imagefile.  But you only need to
refer to the directory name and you can think of it as one {\it logical}
file.  

Whenever we use the word ``image'', we are just using it in a generic
sense.  \aipspp\ images are manipulated with an \ahlink{Image}{images:image.image.constructor}
tool.  An \imagetool\ is associated with, or bound to, the actual
\imagefile\ via a \constructor.   Note that some \imagetools\ don't have
a disk file associated with them.  These are called ``virtual'' images
and are discussed \htmlref{below}{IMAGES:VIRTUALIMAGES}

When an image is stored on disk, it can, in principle, be stored in a
variety of ways.  For example, the image could be stored row by row;
this is the way that most older generation packages store images.  It
makes for very fast row by row access, but very slow in other directions
(e.g.  extract all the profiles along the third axis of an image).  An
\aipspp\ \imagefile\ is stored with what is called tiling.  This means
that small multi-dimensional chunks (a tile) are stored sequentially. 
It means that row by row access is a little slower, but access speed is
essentially the same in all directions.  This in turn means that you
don't need to (and can't !) reorder images. 


Here are some simple examples using image tools.

\begin{ahexample} 
\begin{verbatim}
- include 'image.g'                    # Load image tool functionality
- include 'logger.g'                   # Load logger tool functionality
- dl.gui()                             # Display logger GUI
- im := imagemaketestimage('zz')       # Make test image; writes disk file called 'zz'
- im.summary()                         # Summarize (to logger)
- im.view()                            # Display image 
- im.statistics()		       # Evaluate statistics over entire image
#
- box := drm.box([10,10], [50,50])     # Make a pixel box region with regionmanager
- im2 := im.subimage('zz2', box)       # Make a subimage  called 'zz2'
- im2.statistics()                     # Evaluate statistics
- im2.fft (amp='zz2.amp', phase='zz2.phase')  # FFT subimage and store amp and phase
#
- im.done()                            # Release tool resources (destroys it) - disk file unaffected
- im2.done()   
\end{verbatim}
\end{ahexample}


\medskip
\noindent {\label{IMAGE:FOREIGNIMAGES}\bf Foreign Images}

The Image \tool\ also provides you with native access to some foreign
image formats.  Presently, these are \fits\ (Floar, Double, Short and Long
are supported) and Miriad.   This means
that you don't have to convert  the file to native \aipspp\ format
in order to access the image.   For example:

\begin{ahexample} 
\begin{verbatim}
- include 'image.g'     
- ima := image('im.app')        # Access aips++ image
- imf := image('im.fits')       # Access FITS image
- imm := image('im.mir')        # Access Miriad image
-
- ims := imagefromimage(infile='im.fits', region=drm.quarter())
\end{verbatim}
Each of these Image tools has access to all the same \toolfunctions.
\end{ahexample}

Where ever you see an argument in an Image \tool\ constructor which is
an input image disk file, that disk file can be an \aipspp, \fits, or
Miriad image file. 

There are some performance penalties that you should be aware of. 
Firstly, because \aipspp\ images are tiled (see above) you get the same
access speed regardless of how you access the image.  \fits\ and Miriad
images are not tiled.  This means that the performance for these Image
tools will be poorer for certain operations.  For example, extracting a
profile along the third axis of an image, or re-ordering an image with
the display library. 

Secondly, for \fits\ images, masked values are indicated via ``magic
value''.  This means that the mask is worked out on the fly every time
you access the image. 

If you find performance is not good enough or you want a writable image,
then use appropriate constructor
(\ahlink{imagefromfits}{images:image.imagefromfits.constructor} or
\ahlink{imagefromforeign}{images:image.imagefromforeign.constructor}) to
convert to a native \aipspp\ image. 


\medskip
\noindent {\label{IMAGE:VIRTUALIMAGES}\bf Virtual Images}

We also have Image \tools\ that are not associated one-to-one with disk
files; these are called ``virtual'' images (see also the article in the
\htmladdnormallink{AugustNewsLetter}{../../newsletters/aug00/aug00.html}). 
For example, with the image calculator,
\ahlink{imagecalc}{images:image.imagecalc.constructor}, one can create
an expression which may contain many images.  You can write the result
of the expression out to a disk \imagefile, but if you wish, you can
also just maintain the expression, evaluating it each time it is needed
- nothing is ever written out to disk in this case.  There are other
Image constructors and functions like this (the documentation for each
one explains what it does).  The rules are:

\begin{itemize}

\item  If you specify the {\stfaf outfile} argument, then
the image is always written to the specified disk \imagefile. 

\item If you leave the {\stfaf outfile} argument unset, then if
possible, a virtual image will be created.  Sometimes this virtual image
will be an expression as in the example above (i.e.  it references other
images) or a temporary image in memory, or a temporary image on disk. 
(the \ahlink{summary}{images:image.summary} function will list for you
the type of image you have). When you destroy that Image tool, the
virtual image will be destroyed as well.   

\item If you leave {\stfaf outfile} unset, and the function or
constructor cannot make a virtual image, it will create a disk file for
you with a name of its choice (usually input plus function name). 

\item You can always write a virtual image to disk with the
\htmlref{subimage}{images:image.subimage.function} \toolfunction.  

\end{itemize}


\medskip
\noindent {\bf Coordinate Systems}

An image contains a Coordinate System.  A
\ahlink{Coordsys}{images:coordsys} \tool\ is used to manipulate the
Coordinate System.  An Image \tool\ allows you to recover the Coordinate
System into a Coordsys \tool\ through the
\ahlink{coordsys}{images:image.coordsys}) function.  You can set a new
Coordinate System with the
\ahlink{setcoordsys}{images:image.setcoordsys} function. 

You can do some direct coordinate conversion via the Image \tool\
functions \ahlink{toworld}{images:image.toworld},
\ahlink{topixel}{images:image.topixel}, and
\ahlink{coordmeasures}{images:image.coordmeasures}.  The actual work is
done by a Coordsys \tool, for which these Image \tool\ functions are
just wrappers.


\medskip
\noindent {\bf Lattice Expression Language (LEL)}

LEL allows you to manipulate expressions involving images.  For
example, add this image to that image, or multiply the miniumum value of
that image by the square root of this image.  The LEL syntax is quite
rich and is described in detail in \htmladdnormallink{note
223}{../../notes/223/223.html}. 
          
LEL is accessed via the \ahlink{imagecalc}{images:image.imagecalc.constructor}
constructor and the  \ahlink{calc}{images:image.calc} \tool\ function.
Here are some examples.

\begin{ahexample} 
\begin{verbatim}
- include 'image.g'
- im := imagemaketestimage()       # Make virtual test image
- im.calc('$im + min($im)')        # Make the minimum value zero 
-
- im2 := imagemaketestimage('zz')   # Make nonvirtual test image
- im2.calc('zz + min(zz)')          # Make the minimum value zero 
-
- im.done()
- im2.done()
\end{verbatim}

In the first example, the Image \tool\ {\stf im} is associated with
a virtual image.  We use the \$ syntax in the expression accessing
this image via its \tool.  In the second example, the Image \tool\
{\stf im2} is associated with the non-virtual disk file {\sff zz}.
We could still have used the \$ syntax if we wanted, but we show
here how you can also use the \imagefile\ name in the expression.

\end{ahexample}


Note that for image file names  with special characters in them
(like \- for example), you should (double) escape those characters or put
the file name in double quotes. E.g.

\begin{ahexample} 
\begin{verbatim}
- im1 := imagecalc(pixels='test\\-im')     # Note double escape required
- im2 := imagecalc(pixels='"test-im"')
\end{verbatim}
\end{ahexample}
          


\medskip
\noindent{\bf Region-of-interest}

A \region\, or simply, region, designates which pixels of the image you
are interested in for some (generally) astrophysical reason.  This
complements the \pixelmask\ (see below) which specifies which pixels are
good or bad (for statistical reasons).  \Regions\ are generated and
manipulated with the \ahlink{Regionmanager}{images:regionmanager} tool.

Briefly, a \region\ may be either a simple shape such as a
multi-dimensional box, or a 2-D polygon, or some compound combination of
\regions.  For example, a 2-D polygon defined in the X and Y axes
extended along the Z axis, or perhaps a union or intersection of
regions. 

See the \ahlink{Regionmanager}{images:regionmanager} documentation for
more details on regions.

Regions are always supplied to constructors and \toolfunctions\ via the
{\stfaf region} argument.



\medskip
\noindent{\bf Pixel mask}

A \pixelmask\ specifies which pixels are to be considered good (value
{\cf T}) or bad (value {\cf F}).  For example, you may have  imported a
\fits\ file which has blanked pixels in it.  These will be converted
into \pixelmask\ elements whose values are bad ({\cf F}).  Or  you may
have made an error analysis of an image and computed via a statistical
test that certain pixels should be masked out for future analysis.

If there is no \pixelmask, all pixels are considered good (if you
retrieve the \pixelmask\ when there is none, you will get an all good
mask).  Pixels for which the \pixelmask\ value is bad are not used in
computations (e.g. in the calculation of statistics, moments or
convolution).

The image may contain zero, one, or more \pixelmasks.  However, only one
mask will be designated as the default mask.  This is the \pixelmask\
that is actually applied to the data.  You can also indicate that none
of the \pixelmasks\ are the default, so that effectively an all good
\pixelmask\ is applied.  The function
\ahlink{summary}{images:image.summary} includes in its summary of the
image the names of the masks (the first listed, if not in square
brackets, is the default). 

\Pixelmasks\ are handled with the function
\ahlink{maskhandler}{images:image.maskhandler}.  This allows you to find
the names of \pixelmasks, delete them, copy them, nominate the default and so
on.  It is not used to change the value of \pixelmasks. 

The functions with which you can change \pixelmask\ values are
\ahlink{putregion}{images:image.putregion} (put Boolean array),
\ahlink{calcmask}{images:image.calcmask} (put result of Boolean
LEL expression), and \ahlink{set}{images:image.set} (put scalar Boolean). 



\medskip
\noindent {\bf The argument 'mask'}

There is an argument, {\stfaf mask}, which can be supplied to many
constructors and functions.  It is supplied with either a mask \region\
(generated via the function \ahlink{wmask}{images:regionmanager.wmask})
or a \htmladdnormallink{LEL}{../../notes/223/223.html} Boolean
expression string (the same string you would have supplied to the above
Regionmanager function).   Generally, one just supplies the expression
string.

The LEL expression is simply used to generate a \pixelmask\ which is then applied
in addition to any default \pixelmask\ in the image (a logical OR). For example

\begin{verbatim}
- im := imagemaketestimage('zz')
- im.statistics(mask='zz>0')        # Only evaluate for positive values
- im.calcmask (mask='(2*$im) > 0')  # Create a new mask which is T (good) when twice the 
                                    # image values are positive, else F
\end{verbatim}


The {\stfaf mask} expression must in general conform (shape and
coordinates) with the image (i.e.  that associated with the Image tool). 
You can use the \$ substitution syntax for Image tools (see example
above) which is necessary for virtual images and useful otherwise. 

When {\stfaf mask} is used with function
\ahlink{calcmask}{images:image.calcmask}, a persistent \pixelmask\ is
created and stored with the image.  With all other functions and
constructors, the {\stfaf mask} argument operates as a transient (or
On-The-Fly [OTF]) \pixelmask.  It can be very handy for analysing or
displaying images with different masking criteria. 

Often I will refer to the ``total input mask''.  This is the
combination (logical OR) of the default \pixelmask\ (if any)
and the OTF mask (if any).

In the following example we open a Rotation Measure image.  We then
evaluate statistics and display it where only those pixels whose error
in the Rotation Measure (\imagefile\ {\sff rmerr}) is less than the specified
value are shown; the others are masked.  The nice thing is you can
experiment with different \pixelmasks\ until you are satisfied, whereupon you
might then make the \pixelmask\ persistent with the
\ahlink{calcmask}{images:image.calcmask} function. 

\begin{ahexample} 
\begin{verbatim}
- include 'image.g'
- im := image('rm')
- im.statistics(mask='rmerr<10')
- im.view(mask='rmerr<20')
- im.calcmask (mask='rmerr<20')     # Make persistent mask
\end{verbatim}
\end{ahexample}

\medskip
Finally, a subtlety that is worth explaining.

\begin{ahexample} 
\begin{verbatim}
- im.statistics(mask='zz>0')                 # Mask of zz ignored
- im.statistics(mask='mask(zz) && zz>0')     # Mask of zz used
\end{verbatim}

In the first example, any default mask associated with the image {\sff
zz} is ignored.  Only the pixel values are looked at.  In the second
example, the mask of {\sff zz} is also taken into account via the LEL
{\cf mask} function. That is, the transient output mask is T (good) only when
the mask of {\sff zz} is T and the expression {\cf zz>0} is T.

\end{ahexample}


\begin{ahexample} 

A useful part of LEL to use with the {\stfaf mask} argument is the
{\cf indexin} function.  This enables the user to specify a mask
based  upon selected pixel coordinates (or indices) rather than
image values.  For example


\begin{verbatim}
- im := imagefromshape(shape=[20])
- local pp,mm
- im.getregion (pp,mm, mask='indexin(1, [5:10, 15, 19:20])')
- print mm
[F F F F T T T T T T F F F F T F F F T T] 
\end{verbatim}

You can see the mask is good (T) for the specified indices along the
specified axis.  You can also pass in a premade variable for the
specification if you like, viz.

\begin{verbatim}
- im := imagefromshape(shape=[20])
- axis := 1
- sel := [5:10, 15, 19:20]
- local pp,mm
- im.getregion (pp,mm, mask='indexin($axis, $sel)')
- print mm
[F F F F T T T T T T F F F F T F F F T T]
\end{verbatim}


This capability is useful for fitting functions.
See the example in the \ahlink{fitpolynomial}{images:image.fitpolynomial} function. 
\end{ahexample}


\medskip
\noindent{\label{IMAGE:MASKSANDREGIONS}\bf Pixel masks and Regions}

Some comment about the combination of \pixelmasks\ and \regions\ is useful
here.    See the \ahlink{Regionmanager}{images:regionmanager} tool
for basic information about \regions\ first.  

Regions are provided to Image \toolfunctions\ via the standard {\stfaf region}
constructor and function argument.

Consider a simple polygonal region.  This \region\ is defined by
a bounding box, the polygonal vertices, and a mask called a \regionmask.
The \regionmask\ specifies whether a pixel within the bounding box is
inside or outside the polygon.  For a simple box \region, there is
obviously no need for a \regionmask.

Now imagine that you wish to recover the \pixelmask\ of an image from a
polygonal \region.  The mask is returned to you in
regular Boolean array.  Thus, the shape of the returned mask array reflects the
\ahlink{bounding-box}{images:image.boundingbox} of the polygonal region. 
If the actual \pixelmask\ that you apply is all good, then the retrieved
mask would be good inside of the polygonal region and bad outside of it. 
If the actual \pixelmask\ had some bad values in it as well, the
retrieved mask would be bad outside of the polygonal region.  Inside the
polygonal region it would be bad if the \pixelmask\ was bad. 
More simply put, the mask that you recover is just a logical ``and'' of
the \pixelmask\ and the \regionmask; if the \pixelmask\ is T {\it and} the
\regionmask\ is T then the retrieved mask is T (good), else it is F (bad).

Finally, note that if you use the {\stfaf region} and {\stfaf mask} (the OTF
mask) arguments together then they operate as follows.  The shape
of the Boolean expression provided by  {\stfaf mask} must be the same
shape as the image to which it is being applied.  The {\stfaf region}
is applied equally to the image and the {\stfaf mask} expression.
For example

\begin{ahexample} 
\begin{verbatim}
include 'image.g'
- rm1 := image('rm')
- rm2 := image('rmerr')
- rm1.shape(); rm2.shape()
[128 128]
[128 128]
- r := drm.box([10,10], [50,50])
- rm1.statistics(region=r, mask='rmerr<10')       # region applied to 'rmerr' and 'rm'
\end{verbatim}
\end{ahexample}




\bigskip
\noindent{\bf Error Handling}

All the constructors and functions for Image \tools\ return a variable by
value.  Because of the weak typing of \glish, this variable may take on
different forms depending upon the outcome.  For example, a constructor
such as {\cf im := image('hcn.xyv')} normally returns an \imagetool. 
However, if the operation failed (e.g.  the \imagefile\ {\sff hcn.xyv})
does not exist, them the return variable will be what is called a
\glish\ fail.  You can check any \glish\ variable with the {\cf
is\_fail(variable)} function; it returns T or F.  With an Image tool,
all errors will cause the returned variable, whether it comes from a
constructor or a method, to be a fail.  You will not get a false ({\cf
F}) return unless this is a legal return value for the function.  This is so
that you always know what to check the return variables value for if
you are doing careful error checking in a script.  The documentation for
each constructor and function always tells you what the return variable
type could potentially be. 


\begin{ahexample} 
\begin{verbatim}
- include 'image.g'
- im := image('rm')
- if (is_fail(im)) {
  note (im::message, origin='myscript', priority='SEVERE')
  return;
}
\end{verbatim}
The scoping operator :: enables to extract out a diagnostic
message from the variable {\cf im} when it is a fail.
\end{ahexample}



\bigskip
\noindent{\label{IMAGE:VECTORINPUT}\bf Vector Inputs}

Many of the functions of an Image \tool\ take vectors (numeric or
strings) as their arguments.  We take advantage of the weak-typing of
Glish so that whenever you see a vector argument, you can assume that

\begin{itemize}

\item For numeric vectors you can enter as an actual numeric vector
(e.g. [1.2,2.5,3]), a vector of strings (e.g. "1.2 2.5 3") or even
a string with white space and/or comma delimiters (e.g. '1.2 2.5 3').

\item For string vectors you can enter as an actual vector of strings
(e.g.  "1.2 2.5 3") or a string with white space or comma delimiters
(e.g.  '1.2 2.5 3'). 

\end{itemize}




\bigskip
\noindent{\bf Events}

An \imagetool\ may emit five events.  These are generated by the
\ahlink{view}{images:image.view} display function.  See it for details
of the event values. 

\begin{itemize}
\item A {\tt region} event.   This signifies that
a \region\ has been interactively generated 
via the \viewer.

\item A {\tt position} event.   This signifies that
a position has been interactively generated 
via the \viewer.

\item A {\tt statistics} event.   This signifies that
statistics have been interactively generated 
via the \viewer.

\item a {\tt breakfromviewer} event.  This signifies that
the user has pressed the `break' button on the 
\viewer\ display panel.

\item a {\tt viewerdone} event.  This signifies that
the private \viewer\ inside the Image \tool\ has been
destroyed.


\end{itemize}

\bigskip
{\bf Short-hand names for functions}

Many of the function names are rather long to type (e.g.  boundingbox,
replacemaskedpixels).  This doesn't matter with a GUI interface, but can
be annoying if you are writing scripts or using Glish interactively. 
For such long-winded function names, a short-hand synonym is defined and
given at the beginning of the documentation for each function.



\bigskip
{\bf Miscellaneous}

At present only real-valued (single precision) images are supported. 
Complex images will be supported in the future. 

Besides the functions available as \toolfunctions, you may of
course add functionality through \glish\ programming.  \glish\ computing
speed will be adequate for many ``chunk-by-chunk'' algorithms.  Beware
putting large images into an array -- this can use up a lot of memory!

Some of the \toolfunctions\ in this module can be run asynchronously
(usually things that might take a long time).  This is controlled by the
argument {\stfaf async} which defaults to {\stfaf !dowait} (i.e.  the
opposite to the value of this \glish\ Boolean variable).  By default
when you start \glish\ {\stfaf dowait=F}.  You can enter {\stfaf dowait
:= T} if you wish the default to be that these tool functions run
synchronously.  If you don't want to type this in every time you start
\glish\, then put this statement in your {\sff .glishrc} resource file
that lives in your home directory. 

Note that if the \toolfunction\ is run asynchronously, you have to recover the
result in a more indirect fashion as follows in the following example.

\begin{verbatim}
- jobnum := im.statistics(async=T) 
- statsout := defaultservers.result(jobnum) 
\end{verbatim}





\begin{ahconstructor}{image}{Construct an image tool from an \aipspp\ image file}
\begin{ahargs}
  \ahaddarg[in]{infile}{Input image file name}{}{String}
\end{ahargs}
\ahreturns{\imagetool\ or fail}
\begin{ahdescription}

This is the most commonly used constructor.  It constructs (creates) a 
\imagetool\ associated with disk \imagefile.

The disk image file may be a native \aipspp, \fits\ (Float, Double,
Short, Long are supported) , or Miriad
\imagefile.  Look \htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
information on foreign images.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('myimage')         # Access native aips++ image
- im.view()
-
- im2 := image('hcn.fits')       # Access FITS image
- im2.view()
\end{verbatim}
\end{ahexample}
\end{ahconstructor}




\begin{ahconstructor}{imagecalc}{Construct an \aipspp\ image via the image calculator}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{pixels}{LEL expression}{}{String}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{Image tool}

\begin{ahdescription} 

This constructor is used to evaluate a mathematical expression involving
existing \imagefiles, assigning the result to the newly created output
image.  The syntax of the expression supplied via the {\stfaf pixels}
argument (in what is called the Lattice Expression Language, or LEL) is
explained in detail in \htmladdnormallink{note
223}{../../notes/223/223.html}.

Any image files embedded in the expression may be native \aipspp\ or
\fits\ (but not yet Miriad) \imagefiles.  Look
\htmlref{here}{IMAGES:FOREIGNIMAGES} for more information on foreign
images. 


If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ actually
references all of the input files in the expression.  So if you deleted
any of the input image disk files, it would render this \tool\ useless. 
When you destroy this \tool\ (with the \ahlink{done}{images:image.done}
function), the reference connections are broken.  

If you make a reference \tool, the expression is re-evaluated every time
you use it.   So it takes no extra storage, but takes longer
to access the pixel values (they must be recomputed).


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
im:= imagecalc(outfile='cF', pixels='aF + min(float(pi()), mean(bF))')
\end{verbatim}

Suppose {\sff aF} and {\sff bF} are \imagefiles\ with single precision
data.  They do not need to have conforming shapes and coordinates,
because only the mean of {\sff bF} is used.  Note that {\tt pi} is
explicitly converted to single precision, because {\cf pi()} results in
a Double.  If that was not done, the expression result would be a Double
with the effect that all data of {\sff aF} had to be converted to
Double.  So this expression first computes a scalar, the minimum of
$\pi$ and the mean of the \imagefile\ {\sff bF}.    That scalar is then
added to the value of each pixel in the \imagefile\ {\sff aF}.  The
resultant is put in the \imagefile\ called {\sff cF} to which access is
provided via the \imagetool\ called {\stf im}.

If the expression is masked, that mask will be copied to the new image.

\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- im:=imagecalc('cF', 'min(aF, (min(aF)+max(aF))/2)')
\end{verbatim}

This example shows that there are 2 {\cf min} functions.  One with a
single argument returning the minimum value of that image.  The other
with 2 arguments returning an image containing {\sff aF} data clipped at
the value of the 2nd argument. 

\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- im := imagecalc('eF', 'sin(aD)+(aF*2)+min(bF)+real(aC)')
\end{verbatim}
This shows a mixed type expression.  The real part of the Complex image
{\sff aC}  is used in an expression that otherwise uses Float
type.  The result of the expression is written out to the
disk file called {\sff eF}.
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- im := imagecalc(pixels='sin(aD)+(aF*2)+min(bF)+real(aC)')
\end{verbatim}
This shows a mixed type expression.  The real part of the Complex image
{\sff aC}  is used in an expression that otherwise uses Float
type.  The result of the expression is not written out to disk
in this case.  It is evaluated each time it is needed.
\end{ahexample}
\end{ahconstructor}



\begin{ahconstructor}{imageconcat}{Construct an \aipspp\ image by concatenating images}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{infiles}{List of input \aipspp\ image files to concatenate; wild cards accepted}{}{String or vector of strings}
  \ahaddarg[in]{axis}{Concatenation pixel axis}{Spectral axis if there is one}{positive integer}
  \ahaddarg[in]{relax}{Relax constraints that axis coordinate descriptors match}{F}{Bool}
  \ahaddarg[in]{tempclose}{Keep all lattices closed until needed}{T}{Bool}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{Image tool}

\begin{ahdescription} 

This constructor is used to concatenate two or more input \aipspp\
images into one output image.  For example, if you have two image cubes
which are contiguous along one axis (say a spectral axis) and you would
like to glue them together along this axis, then this constructor is the
appropriate thing to use. 

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ actually
references all of the input files.   So if you deleted any of the input
image disk files, it would render this \tool\ useless.   When you
destroy this tool (with the \ahlink{done}{images:image.done} function)
the reference connections are broken.

The input and output images must be of the same dimension.  Therefore,
if you wish to concatenate 2-D images into a 3-D image, the 2-D images
must have a third axis (of length unity) so that the output image
coordinates are known along the concatenation axis. 

The input images are concatenated in the order in which they are listed. 
Therefore, the Coordinate System of the output image is given by that of the
first input image.  The input images are checked to see that they are
contiguous along the concatenation axis and an error is generated if
they are not.  In addition, the coordinate descriptors (e.g.  reference
pixel, reference value etc) for the non-concatenation axes must be the
same or an error will result. 

The input disk image files may be in native \aipspp, \fits, or Miriad
formats.  Look \htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
information on foreign images.

The contiguous criterion and coordinate descriptor equality criteria can
be relaxed by setting {\stfaf relax=T} whereupon only warnings will be
issued.  Dimension and shape must still be the same though.  When the
concatenation axis is not contiguous (but still monotonically increasing
or decreasing) and {\stfaf relax=T}, a tabular coordinate will be used
to correctly describe the axis.  But be aware that it means adjacent
pixels are not regularly spaced.  However, functions like
\ahlink{toworld}{images:image.toworld} and
\ahlink{topixel}{images:image.topixel} will correctly interconvert world
and pixel coordinates. 

In giving the input image names, the {\stfaf infiles} argument can be a
single string if you wild card it with standard shell symbols.  For
example, {\stfaf infiles='cena\_???.*'}, where the ``?'' represents one
character and ``*'' any number of characters. 

Otherwise, you must input a vector of strings such as {\stfaf
infiles="cena1 cena2 cena3"}.  An input such as {\stfaf
infiles='files1,file2'} will be interpreted as one string naming one
file and you will get an error.  The reason for this is that although
the latter could be parsed to extract two file names by recognizing
comma delimiters, it is not possible because an expression such as
{\stfaf infiles='cena.\{a,b\}'} (meaning files of name ``cena.a'' and
``cena.b'') would confuse such parsing (you would get two files of name
{\sff cena.\{a} and {\sff b\}}. 

You can look at the Coordinate System of the output image with
\ahlink{summary}{images:image.summary} to make sure it's correct.

The argument {\stfaf tempclose} is, by default, True.  This means that
all internal reference copies of the input images are  kept closed until
they are needed. Then they are opened temporarily and then closed again.
This enables you to effectively concatenate as many images as you like
without encountering any operating system open file number limits.  However, it
comes at some performance loss, because opening and closing all those
files takes time.  If you are concatenating a smallish number of files,
you might use {\stfaf tempclose=F}.  This will leave all internal
reference copies permanently open, but performance, if you don't hit the
file limit, will be better.

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := imageconcat(outfile='bigimage', infiles=''im1 im2 im3'', axis=3, relax=T, tempclose=F)
\end{verbatim}
The \imagefiles\ {\sff im1}, {\sff im2}, and {\sff im3} are concatenated along
the third axis to form the output \imagefile\ {\sff bigfile}.
Only warnings are issued if axis descriptors mismatch.
Access to the output image is provided via the \tool\ called {\stf im}.
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- im := imageconcat(infiles='$ADATA/cena*.1344')
\end{verbatim}
All images whose file names begin with {\sff cena} and terminate with
{\sff .1344} that reside in the directory given by the translation of the
environment variable {\tt \$ADATA} are concatenated along the spectral axis
if there is one.  The image must be contiguous along the spectral axis
and all image coordinate descriptors must match.  If there is no spectral
axis an error will result.  Because an output file name is
not given, the Image tool just references the input files,
it does not copy them.

\end{ahexample}
\end{ahconstructor}



\begin{ahconstructor}{imagefromarray}{Construct an \aipspp\ image from a Glish array}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{pixels}{Numeric Glish array}{}{}
  \ahaddarg[in]{csys}{Coordinate System}{unset}{Coordsys tool}
  \ahaddarg[in]{linear}{Make a linear Coordinate System if csys not given}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{log}{Write image creation messages to logger}{T}{T or F}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This constructor converts a \glish\ array of any size into an \aipspp\
\imagefile. 

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated
with a temporary image.  This temporary image may be in memory or on
disk, depending on its size.  When you destroy the Image \tool\ 
(with the \ahlink{done}{images:image.done} function) this
temporary image is deleted.

At present, no matter what type the {\stfaf pixels} array is, a
real-valued image will be written (the input pixels will be converted to
Float with the \glish\ as\_float function).  In the future, Complex images
will be supported.

The Coordinate System, provided as a \ahlink{Coordsys}{images:coordsys}
\tool, is optional.  If you provide it, it must be dimensionally
consistent with the pixels array you give (see also
\ahlink{coordsys}{images:image.coordsys}).

If you don't provide the Coordinate System (unset), a default Coordinate System
is made for you.  If {\stfaf linear=F} (the default) then it is a
standard RA/DEC/Stokes/Spectral Coordinate System depending exactly upon
the shape of the {\stfaf pixels} array (Stokes axis must be no longer
than 4 pixels and you may find the spectral axis coming out before the
Stokes axis if say, {\cf shape=[64,64,32,4]}).  Extra dimensions are
given linear coordinates.  If {\stfaf linear=T} then you get a linear
Coordinate System. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := imagefromarray(outfile='test.data', pixels=array(0, 64, 64, 4, 128))
- cs := im.coordsys(axes=[1,2])
- im.done()
- im2 := imagefromarray(pixels=array(1.0, 32, 64), csys=cs)
- cs.done()
\end{verbatim}

The first example creates a zero-filled \imagefile\ named {\sff
test.data} which is of shape [128,256].  If you examine the header with
{\stff im.summary()} you will see the default RA/DEC/Stokes/Frequency coordinate information. 
In the second example, a Coordinate System describing the first two axes
of the image {\sff test.data} is created and used to create a 2D image
temporary image.

\end{ahexample}
\end{ahconstructor}



\begin{ahconstructor}{imagefromascii}{Construct an \aipspp\ image by conversion from an ascii file}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{infile}{Input ascii disk file name}{}{String}
  \ahaddarg[in]{shape}{Shape of image}{}{Vector of integers}
  \ahaddarg[in]{sep}{Separator in ascii file}{' '}{String}
  \ahaddarg[in]{csys}{Coordinate System}{unset}{Coordsys tool}
  \ahaddarg[in]{linear}{Make a linear Coordinate System if csys not given}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{Image tool or fail}
\begin{ahdescription}

This constructor is used to convert an ascii disk file to an
\aipspp\ \imagefile.  If {\stfaf outfile} is given, the image is written
to the specified disk file.  If {\stfaf outfile} is unset, the Image
\tool\ is associated with a temporary image.  This temporary image may
be in memory or on disk, depending on its size.  When you destroy the
Image \tool\ (with the \ahlink{done}{images:image.done} function) this
temporary image is deleted. 

You must specify the shape of the image.  The image must be stored
in the ascii file, one row at a time.  This row must be of the
correct length and there must be the correct number of rows.
For example, let us say the shape of your image is 
{\cf [nx,ny,nz] = [3,4,2]}, then
the image should be stored as 

\begin{verbatim}
1 1 1                   # row 1; y = 1, z = 1
2 2 2                   # row 2; y = 2, z = 1
3 3 3                   # row 3; y = 3, z = 1
4 4 4                   # row 4; y = 4, z = 1
1.5 1.5 1.5             # row 5; y = 1, z = 2
2.5 2.5 2.5             # row 6; y = 2, z = 2
3.5 3.5 3.5             # row 7; y = 3, z = 2
4.5 4.5 4.5             # row 8; y = 4, z = 2
\end{verbatim}


The Coordinate System, provided as a \ahlink{Coordsys}{images:coordsys}
\tool, is optional.  If you provide it, it must be dimensionally
consistent with the pixels array you give (see also
\ahlink{coordsys}{images:image.coordsys}).

If you don't provide the Coordinate System (unset), a default Coordinate System
is made for you.  If {\stfaf linear=F} (the default) then it is a
standard RA/DEC/Stokes/Spectral Coordinate System depending exactly upon
the shape of the {\stfaf pixels} array (Stokes axis must be no longer
than 4 pixels and you may find the spectral axis coming out before the
Stokes axis if say, {\cf shape=[64,64,32,4]}).  Extra dimensions are
given linear coordinates.  If {\stfaf linear=T} then you get a linear
Coordinate System. 



\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagefromascii('myimage.app', 'myimage.ascii', shape=[128,128])
\end{verbatim}
\end{ahexample}
\end{ahconstructor}




\begin{ahconstructor}{imagefromfits}{Construct an \aipspp\ image by conversion from a FITS image file}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{infile}{Input FITS disk file name}{}{String}
  \ahaddarg[in]{whichrep}{If this FITS file contains multiple coordinate representations, which one should we read}{1}{positive integer}
  \ahaddarg[in]{whichhdu}{If this FITS file contains multiple images, which one should we read}{1}{positive integer}
  \ahaddarg[in]{zeroblanks}{If there are blanked pixels, set them to zero instead of NaN}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{old}{Use old non-WCS based FITS parser?}{F}{T or F}
\end{ahargs}
\ahreturns{Image tool or fail}
\begin{ahdescription}

This constructor is used to convert a FITS disk image file (Float,
Double, Short, Long are supported) to an
\aipspp\ \imagefile.  If {\stfaf outfile} is given, the image is written
to the specified disk file.  If {\stfaf outfile} is unset, the Image
\tool\ is associated with a temporary image.  This temporary image may
be in memory or on disk, depending on its size.  When you destroy the
Image \tool\ (with the \ahlink{done}{images:image.done} function) this
temporary image is deleted. 

This constructor reads from the FITS primary array (when the image is at
the beginning of the FITS file; {\stfaf whichhdu=1}), or an image
extension (when the image is elsewhere in the FITS file, {\stfaf
whichhdu $>$ 1}). 

By default, any blanked pixels will be converted to a mask value which
is false, and a pixel value that is NaN.  If you set {\stfaf
zeroblanks=T} then the pixel value will be zero rather than NaN.  The
mask will still be set to false.  See the function
\ahlink{replacemaskedpixels}{images:image.replacemaskedpixels} if you
need to replace masked pixel values after you have created the image. 

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := imagefromfits('data/myimage', 'fits/MYIMAGE.FITS')
- mi := im.miscinfo()
print 'fields=', field_names(mi)
\end{verbatim}

The FITS image is converted to an \aipspp\ \imagefile\ and access is provided
via the \imagetool\ called {\stf im}.  Any FITS header keywords which were
not recognized or used are put in the miscellaneous information bucket accessible with
the \ahlink{miscinfo}{images:image.miscinfo} function.  In the example
we  list the names of the fields in this record.

\end{ahexample}
\end{ahconstructor}



\begin{ahconstructor}{imagefromforeign}{Construct an \aipspp\ image from a foreign package image file}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{infile}{Input foreign image disk file name}{}{String}
  \ahaddarg[in]{format}{Format type}{'miriad'}{String from 'miriad', 'gipsy'}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{Image tool or fail}
\begin{ahdescription}

This constructor is used to convert a foreign package image file to an
\aipspp\ image.  This is done via an intermediary \fits\ file which is
created by the foreign package.  In order for this constructor to work,
you must have the foreign package installed; it is not part of \aipspp. 
Currently supported are Miriad and Gipsy files. 

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated
with a temporary image.  This temporary image may be in memory or on
disk, depending on its size.  When you destroy the Image \tool\ 
(with the \ahlink{done}{images:image.done} function) this
temporary image is deleted. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := imagefromforeign('im.app', 'im.miriad', format='miriad')
\end{verbatim}

\end{ahexample}
\end{ahconstructor}


\begin{ahconstructor}{imagefromimage}{Construct a (sub)image from a region of an \aipspp\ image}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output sub-image file name}{unset}{String}
  \ahaddarg[in]{infile}{Input image file name}{}{String}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{dropdeg}{Drop degenerate axes}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{Image tool or fail}
\begin{ahdescription}

This constructor applies a \region\ to an \imagefile, creates a new
\imagefile\ containing the (sub)image, and associates a new \imagetool\
with it. 

The input image file may be in native \aipspp, \fits, or Miriad
format.  Look \htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
information on foreign images.

If {\stfaf outfile} is given, the (sub)image is written to the specified
disk file.  

If {\stfaf outfile} is unset, the Image \tool\ actually references
the input image file.  So if you deleted the input image disk file, it
would render this \tool\ useless.  When you destroy this \tool\
(with the \ahlink{done}{images:image.done} function)
the reference connection is broken.  

Sometimes it is useful to drop axes of length one (degenerate axes).
Use the {\stfaf dropdeg} argument if you want to do this.

The output mask is the combination (logical OR) of the default input
\pixelmask\ (if any) and the OTF mask.  Any other input \pixelmasks\
will not be copied.  Use function
\ahlink{maskhandler}{images:image.maskhandler} if you need to copy other
masks too. 

See also the \ahlink{subimage}{images:image.subimage} function.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagefromimage(outfile='image.small', infile='image.large', region=drm.quarter())
\end{verbatim}
The specified \region\ takes a quarter by area of the first two axes
of the image, and all pixels of other axes.
\end{ahexample}
\end{ahconstructor}



\begin{ahconstructor}{imagefromshape}{Construct an empty \aipspp\ image from a shape}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Name of output image file}{unset}{}
  \ahaddarg[in]{shape}{Shape of image}{}{}
  \ahaddarg[in]{csys}{Coordinate System}{unset}{Coordsys tool}
  \ahaddarg[in]{linear}{Make a linear Coordinate System if csys not given ?}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{log}{Write image creation messages to logger}{T}{T or F}
\end{ahargs}
\ahreturns{Image tool}
\begin{ahdescription}

This constructor creates an \aipspp\ \imagefile\ with the specified shape.  All
the pixel values in the image are set to 0.  

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated with
a temporary image.  This temporary image may be in memory or on disk,
depending on its size.  When you destroy the Image \tool\  (with the
\ahlink{done}{images:image.done} function) this temporary image is
deleted.

The Coordinate System, provided as a \ahlink{Coordsys}{images:coordsys}
\tool, is optional.  If you provide it, it must be dimensionally
consistent with the pixels array you give (see also
\ahlink{coordsys}{images:image.coordsys}).

If you don't provide the Coordinate System, a default Coordinate System
is made for you.  If {\stfaf linear=F} (the default) then it is a
standard RA/DEC/Stokes/Spectral Coordinate System depending exactly upon
the shape (Stokes axis must be no longer than 4 pixels and you may find
the spectral axis coming out before the Stokes axis if say, {\cf
shape=[64,64,32,4]}).  Extra dimensions are given linear coordinates. 
If {\stfaf linear=T} then you get a linear Coordinate System. 



\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := imagefromshape('test.data', [64,64,128])
- cs := im.coordsys(axes=[1,3])
- im2 := imagefromshape(shape=[10, 20], csys=cs)
\end{verbatim}

The first example creates a zero-filled \imagefile\ named {\sff
test.data} of shape [256,512].  If you examine the header with {\stff
im.summary()} you will see the RA/DEC/Spectral coordinate information. 
In the second example, a Coordinate System describing the first and third axes
of the image {\sff test.data} is created and used to create a 2D temporary image.
\end{ahexample}
\end{ahconstructor}


\begin{ahconstructor}{imagemaketestimage}{Construct an \aipspp\ image from a test FITS file}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
\end{ahargs}

\ahreturns{Image tool}

\begin{ahdescription}
This function converts a \fits\ file resident in the \aipspp\ system
into an \aipspp\ image.

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated
with a temporary image.  This temporary image may be in memory or on
disk, depending on its size.  When you destroy the Image \tool\ 
(with the \ahlink{done}{images:image.done} function) this
temporary image is deleted. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage()     # make virtual image
- im.view()                      # view it
\end{verbatim}
\end{ahexample}
\end{ahconstructor}




%%% Functions

\begin{ahfunction}{adddegaxes}{Add degenerate axes of the specified type to the image}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{direction}{Add direction axes ?}{F}{T or F}
  \ahaddarg[in]{spectral}{Add spectral axis ?}{F}{T or F}
  \ahaddarg[in]{stokes}{Add Stokes axis ?}{''}{Stokes}
  \ahaddarg[in]{linear}{Add linear axis ?}{F}{T or F}  
  \ahaddarg[in]{tabular}{Add tabular axis ?}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function (short-hand name {\stff ada}) adds degenerate axes (i.e.
axes of length 1) of the specified type.  Sometimes this can be useful
although you will generally need to modify the coordinate system of the
added axis to give it the coordinate you want (do this with the
\ahlink{Coordsys}{images:coordsys} \tool).

You specify which type of axes you want to add.  You can't add
an axis type that already exists in the image.  For the Stokes axis,
the allowed value (a string such as  I, Q, XX, RR) can be found in the
\ahlink{Coordsys}{images:coordsys.coordsys} constructor. 

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated
with a temporary image.  This temporary image may be in memory or on
disk, depending on its size.  When you destroy the Image \tool\ 
(with the \ahlink{done}{images:image.done} function) this
temporary image is deleted.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im1 := imagemaketestimage() 
- im1.shape()
[113 76]
- im1.coordsys().axiscoordinatetypes()
Direction Direction 
-
- im2 := im1.adddegaxes(spectral=T)
- im2.shape()
[113 76 1] 
- im2.coordsys().axiscoordinatetypes()
Direction Direction Spectral
-
- im3 := im2.adddegaxes(stokes='Q')
- im3.shape()
[113 76 1 1]
- im3.coordsys().axiscoordinatetypes()
Direction Direction Spectral Stokes 
\end{verbatim}
In this example, all the images are virtual (temporary images).
\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{addnoise}{Add noise to the image}
\begin{ahargs}
  \ahaddarg[in]{type}{Type of distribution}{'normal'}{String - see below}
  \ahaddarg[in]{pars}{Parameters of distribution}{[0,1]}{Numeric vector}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{zero}{Zero image first ?}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function adds noise to the image.  You may zero the image first
before the noise is added if you wish.

The noise can be drawn from one of many distributions, which are also
available in the \ahlink{randomnumbers}{mathematics.randomnumbers} \tool.

For each distribution, you must supply the type via the {\stfaf type}
argument (minimum match is active) and parameters via the {\stfaf pars}
argument.  Each distribution type is described in detail in the
\ahlink{randomnumbers}{mathematics.randomnumbers} \tool.   Briefly:

\begin{itemize}

\item {binomial} -- the binomial distribution models successfully drawing
items from a pool. Specify two parameters, $n$ and $p$, respectively.
$n$ is the number of items in the pool, and $p$, is the probability of
each item being successfully drawn. It is required that $n > 0$ and 
$0 \le p \le 1$.

\item {discreteuniform} -- models a uniform random variable over the closed interval. Specify 
two parameters, the low and high values, respectively.
The low parameter is the lowest possible return value and
the high parameter is the highest. It is required that $low < high$.

\item {erlang} -- Specify two parameters, the  mean and variance,
respectively. It is required that the mean is non-zero and the variance
is positive.

\item {geometric} -- Specify one parameter, the probability.
It is required that $0 \le mean < 1$.

\item {hypergeometric} -- Specify two parameters, the mean and the variance.
It is required that the variance is positive and that the mean is non-zero
and not bigger than the square-root of the variance.

\item {normal} -- Specify two parameters, the mean and the variance.
It is required that the variance is positive.   

\item {lognormal} -- Specify two parameters, the mean and the variance.   
It is required that the supplied variance is positive and that the mean is non-zero.

\item {negativeexponential} -- Supply one parameter, the mean.

\item {poisson} -- Specify one parameter, the mean.
It is required that the mean is non-negative.

\item {uniform} -- Model a uniform random variable over a closed
interval. Specify two parameters, the low and high values.    The low
parameter is the lowest possible return value and the high parameter can
never be returned. It is required that $low < high$.

\item {weibull} -- Specify two parameters, alpha and beta.
It is required that the alpha parameter is not zero.

\end{itemize}


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im1 := imagemaketestimage() 
- im1.addnoise(type='normal', pars=[0.5, 1], zero=T)
- im1.statistics()
NORMAL: Starting image::statistics
NORMAL: Selected bounding box [1, 1] to [113, 76]
NORMAL: Creating new statistics storage lattice of shape [9]
NORMAL: 
NORMAL: Number points =   8.588000e+03       Sum      =   4.258988e+03
NORMAL: Flux density  =   1.972103e+02 Jy
NORMAL: Mean          =   4.959231e-01
NORMAL: Variance      =   9.983749e-02       Sigma    =   3.159707e-01
NORMAL: Rms           =   5.880184e-01
NORMAL: 
NORMAL: Minimum value  -6.234988e-01 at [4, 39] (00:00:27.733, +00.00.12.000)
NORMAL: Maximum value   1.664114e+00 at [105, 11] (23:59:33.867, -00.05.24.000)
NORMAL: 
NORMAL: Finished image::statistics
       0.07 real        0.03 user           0 system
T
\end{verbatim}
\end{ahexample}
A test image is created, zeroed, and noise of mean
0.5 and variance 1 from a normal distribution added.
\end{ahfunction}




\begin{ahfunction}{convolve}{Convolve image with a Glish array or another image}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{kernel}{Convolution kernel - array or image filename}{}{Numeric Glish array or string}
  \ahaddarg[in]{scale}{Scale factor}{Autoscale}{Float}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function does Fourier-based convolution of an \imagefile\ by the
given kernel.  

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated
with a temporary image.  This temporary image may be in memory or on
disk, depending on its size.  When you destroy the Image \tool\ 
(with the \ahlink{done}{images:image.done} function) this
temporary image is deleted.

The kernel is provided as a multi-dimensional \glish\ array or as the 
filename of a disk-based \imagefile.   The provided kernel can have less
dimensions than the image being convolved.  In this case, it will be
padded with degenerate axes.  An error will result if the kernel has
more dimensions than the image.   No additional scaling of the kernel is
provided yet.

The scaling of the output image is determined by the argument {\stfaf scale}.
If you leave it unset, then the kernel is normalized to unit sum.
If you do not leave {\stfaf scale} unset, then the convolution kernel
will be scaled (multipled) by this value.

Masked pixels will be assigned the value 0.0 before convolution. 

The output mask is the combination (logical OR) of the default input 
\pixelmask\ (if any) and the OTF mask.  Any other input \pixelmasks\
will not be copied.  Use function
\ahlink{maskhandler}{images:image.maskhandler} if you need to copy other
masks too.

See also the other convolution functions
\ahlink{convolve2d}{images:image.convolve2d},
\ahlink{sepconvolve}{images:image.sepconvolve} and
\ahlink{hanning}{images:image.hanning}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- dowait := T
- r1 := drm.quarter()
- im := image('pks1333-33.6cm')
- kernel := mykernel(...)                          # Your code to generate the kernel
- im2 := im.convolve(kernel=kernel, region=r1)     # Makes temporary image
-
- im3 := im.convolve (kernel=im.name(F))           # Convolve by self
\end{verbatim}

\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{boundingbox}{Get the bounding box of the specified region}
\begin{ahargs}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
\end{ahargs}
\ahreturns{Glish Record or fail}
\begin{ahdescription}

This function (short-hand name {\stff bb}) finds the bounding box of a
region of interest when it is applied to a particular image.  It is
returned in a \glish\ record which has fields {\cf `blc', `trc', `inc',
`bbShape', `regionShape', `imageShape', `blcf'} and {\cf `trcf'}
containing the bottom-left corner, the top-right corner (in absolute
image pixel coordinates), the increment (stride) of the region, the
shape of the boundingbox, the shape of the region, the shape of the
image,  the blc in formatted absolute world coordinates and the trc in
formatted absolute world  coordinates, respectively. 

Note that the shape of the bounding box will be different from the shape
of the region if a non-unit stride (increment) is involved (see the example
below).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('hcn')                          # Create image tool
- x := dq.quantity([3,6,9,6,5,5,3],'pix')       # X vector, in absolute pixels
- y := dq.quantity([3,4,7,9,7,5,5],'pix')       # Y vector, in absolute pixels
- r1 := drm.wpoly(x,y,csys=im.coordsys())     # Create polygonal world region
- bb := im.boundingbox(r1)                    # Find bounding box
- print bb
[blc=[3 3] , trc=[9 9] , inc=[1 1], bbShape=[7 7] , regionShape=[7 7], imageShape=[155 178] ]

\end{verbatim}
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- im := image('z1.app')
- b := drm.box([10,10],[20,20],[2,3])
- im.boundingbox(b)
[blc=[10 10] , trc=[20 19] , inc=[2 3] , bbShape=[11 10] , regionShape=[6 4] , imageShape=[113 76] ]
\end{verbatim}
In this example we see the difference between bbShape and regionShape because
of the increment (stride).  See also that the trc is modified by
the increment.
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{brightnessunit}{Get the image brightness unit}
\ahreturns{String or fail}
\begin{ahdescription}

This function (short-hand name {\stff bu}) gets the image brightness unit.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('hcn')      
- im.brightnessunit()
Jy/beam
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{calc}{Image calculator}
\begin{ahargs}
  \ahaddarg[in]{pixels}{LEL expression}{}{String}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription} 

This function is used to evaluate a mathematical expression involving
\aipspp\ images, assigning the result to the current (already existing) 
image.  It complements the \ahlink{imagecalc}{images:image.imagecalc.constructor}
constructor.  See \htmladdnormallink{note 223}{../../notes/223/223.html}
which describes the the syntax and functionality in detail.

If the expression, supplied via the {\stfaf pixels} argument, is not a
scalar, the shapes and coordinates of the image and expression must
conform. 

If the image (that associated with the tool) has a \pixelmask, then only
pixels for which that mask is good will be changed.  See the function
\ahlink{maskhandler}{images:image.maskhandler} for managing image \pixelmasks. 

See the related functions \ahlink{set}{images:image.set} and
\ahlink{putregion}{images:image.putregion}.


\end{ahdescription}


\begin{ahexample}
\begin{verbatim}
- im.calc('min(aF, (min(aF)+max(aF))/2)')
- im.calc('1.0')
\end{verbatim}

The first example shows that there are 2 {\cf min} functions.  One with a
single argument returning the minimum value of that image.  The other
with 2 arguments returning an image containing ``aF'' data clipped at
the value of the 2nd argument.   The second example sets all good
pixels to unity.

\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- im.calc('sin(aD)+(aF*2)+min(bF)+real(aC)')
\end{verbatim}
This shows a mixed type expression.  The real part of the complex image
``aC''  is used in an expression that otherwise uses Float type.
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{calcmask}{Image mask calculator}
\begin{ahargs}
  \ahaddarg[in]{mask}{Boolean LEL expression}{}{Boolean LEL expression or mask region}
  \ahaddarg[in]{name}{Mask name}{Auto new name}{String}
  \ahaddarg[in]{default}{Make specified mask the default mask ?}{T}{Bool}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription} 

This function is used to create a new \pixelmask\ via a Boolean LEL expression.
This gives you much more scope than the simple
\ahlink{set}{images:image.set} and
\ahlink{putregion}{images:image.putregion} functions. 

See \htmladdnormallink{note 223}{../../notes/223/223.html}
which describes the the syntax and functionality of LEL in detail. 

If the expression is not a scalar, the shapes and coordinates of the
image and expression must conform.    If the expression is a scalar
then the entire \pixelmask\ will be set to that value.

By default (argument {\stfaf name}) the name of a new \pixelmask\ is made up
for you.  However, you specify a \pixelmask\ name (use function
\ahlink{summary}{images:image.summary} or
\ahlink{maskhandler}{images:image.maskhandler} to see the mask names)
then it is used.  If the \pixelmask\ already exists, it is overwritten. 

You can specify whether the new \pixelmask\ should be the default mask or not.
By default, it is made the default \pixelmask\ !


\end{ahdescription}

\begin{ahexample}
\begin{verbatim} 
- im.calcmask(T)                  # Automatically converted to a string
- im.calcmask('zz>0')             # Mask of zz ignored
- im.calcmask('mask(zz) && zz>0') # Mask of zz included
- im.calcmask('$im>min($im)')     # Use tool names
- im.calcmask('zz>min(zz:nomask)')  # Mask of zz not used in scalar function
\end{verbatim}

The first example is the equivalent of {\cf im.set(pixelmask=T)}.  It sets
the entire mask to True.  

The second example creates a new \pixelmask\ which is True when
the pixel values in image {\sff zz} are greater than 0.  

Now for some subtlety.  Read carefully !  Any LEL expression can be
thought of as having a value and a mask.  Usually the value is Float and
the mask Boolean.  In this case, because the expression is Boolean
itself, the value is also Boolean.  The expression mask would just be
the mask of {\sff zz}.  Now what {\stfaf calcmask} does is create a mask
from the expression value (which is Boolean) and discards the expression
mask.  Therefore, the resulting mask is independent of any mask
that {\sff zz} might have.

If you wish the mask of the expression be honoured as well,
then you can do as in the third example.   It says the output \pixelmask\ 
will be True if the current \pixelmask\ of {\sff zz} is True and the expression
value is True.

The fourth example is like the second, except that we use the pixel
values associated with the {\stf im} Image tool itself rather than
using its disk name (the Image tool might be virtual so there might
not be a disk file).  Note one further subtlety here.  When the scalar
function {\cf min} evaluates a value from {\cf \$im}, the default
mask of {\cf \$im} {\it will} be used.  All the scalar functions
look at the mask.   If you didn't want the mask to be used you
can use the special {\cf :nomask} syntax shown in the  final example.

\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{close}{Close the image tool}
\ahreturns{T or fail}
\begin{ahdescription}

This function closes the \imagetool.  This means that it detaches the
tool from its \imagefile\ (flushing all the changes first).  The
\imagetool\ is ``null'' after this change (it is not destroyed) and
calling any \toolfunction\ other than \ahlink{open}{images:image.open}
will result in an error. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := image('myimage')  # Starts server and creates Image tool
- im.close()              # Closes Image tool
- im.summary()            # `im' is now null, this results in an error.
- im.open('myotherimage') # `im' is valid again
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{continuumsub}{Image plane continuum subtraction}
\begin{ahargs}
  \ahaddarg[in]{outline}{Output line image filename}{unset}{String}
  \ahaddarg[in]{outcont}{Output continuum image filename}{'continuumsub.im'}{String}
  \ahaddarg[in]{region}{Region over which continuum subtraction is desired}{whole image}{Region}
  \ahaddarg[in]{channels}{Channels to use for continuum estimation}{All}{Vector<Int>}
  \ahaddarg[in]{pol}{Polarization to process}{unset}{String from "I Q U V XX RR" etc.}
  \ahaddarg[in]{fitorder}{Polynomial order for continuum estimation}{0}{Int}
  \ahaddarg[in]{overwrite}{Auto-overwrite output files if they exist?}{F}{Boolean}
\end{ahargs}
\ahreturns{Image tool containing the continuum-subtracted result.}

\begin{ahdescription} 

This function packages the relevant image tool functionality for simple
specification and application of image plane continuum subtraction.  All
that is required of the input image is that it have a non-degenerate
Spectral axis.  

The user specifies region, the region of the input image over which
continuum subtraction is desired (otherwise the whole image will be
treated); channels, the subset of channels on the spectral axis to use
in the continuum estimation, specified as a vector; pol, the desired
single polarization to treat (otherwise all pols, if a polarization axis
exists, will be treated); fitorder, the polynomial order to use in the
estimation.  Optionally, output line and continuum images may be written
by specifying outline and outcont, respectively.  If outline is not
specified, a virtual image tool is all that is produced.  If outcont is
not specified, the output continuum image will be written in
'continuumsub.im'. 

In principle, the region may be specified interactively, e.g., using
the viewer. At the moment, such regions are typically degenerate on
the spectral axis, and so must be manually extended along the this
axis, or continuumsub will complain about insufficient spectral
channels in the region of interest.  Interface improvements in the
management of regions currently under consideration will improve the
mechanism for doing this.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim} 
- im1 := image('test1.im');
- im1csub:=im.continuumsub(region=drm.quarter(),channels=[3:8,54:60],fitorder=0);
\end{verbatim}
In this first example, the continuum emission in each pixel of the inner
quarter of the input image is estimated by averaging (fitorder=0)
channels 3-8 and 54-60.  im1csub is an image tool containing the result
(only the inner quarter of the original image).


\begin{verbatim} 
- im2 := image('test2.im');
- im2csub:=im.continuumsub(channels=[3:8,54:60],pol='I',fitorder=2);
\end{verbatim}
In this second example, the Stokes I continuum emission in each pixel 
of the whole input image is estimated with a 2nd-order polynomial
fit to channels 3-8 and 54-60.  The output image tool (im2csub) contains
only Stokes I, even if the original image had other stokes planes.

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{convertflux}{Convert flux density between peak and integral}
\begin{ahargs}
  \ahaddarg[in]{value}{Flux density to convert}{}{Quantity}
  \ahaddarg[in]{major}{Major axis of component}{}{Quantity}
  \ahaddarg[in]{minor}{Minor axis of component}{}{Quantity}
  \ahaddarg[in]{type}{Type of component}{Gaussian}{String from Gaussian, Disk}
  \ahaddarg[in]{topeak}{Convert to peak or integral flux desnity}{T}{Bool}
\end{ahargs}
\ahreturns{Quantity or fail}

\begin{ahdescription} 

This function interconverts between peak and integral flux density for a
Gaussian or Disk component.  The image must hold a restoring beam. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim} 
- im := image('in.im');
- p1 := dq.quantity('1mJy/beam')
- i1 := im.convertflux(p1, major='30arcsec', minor='10arcsec', topeak=F);
- p2 := im.convertflux(i1, major='30arcsec', minor='10arcsec', topeak=T)
- print 'peak, integral, peak = ', p1, i1, p2
peak, integral, peak =  [value=1, unit=mJy/beam] [value=0.000163961301, unit=Jy] [value=0.001, unit=Jy/beam]
\end{verbatim}

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{convertsm}{Convert image for older versions}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output file name}{unset}{String}
  \ahaddarg[in]{overwrite}{Overwrite output file if already exists ?}{T}{Bool}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription} 

\imagefiles\ created by some versions of \aipspp\ since release 1.3
cannot be be read by versions 1.3 and earlier.   The period for which
development versions of \aipspp\ were creating \imagefiles\ which were
unreadable by earlier versions was a 2-3 weeks so it is very unlikely
you will ecnounter this problem.

This function converts the image disk file (actually just the Storage
Manager of the logtable) so that it can be read by all versions.

If the {\stfaf outfile} is unset, the conversion is done in-situ.
Otherwise you should specify the name of a new disk file.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim} 
- im := image('in.im');
- im.convertsm()                       # in-situ
- im.convertsm('out.im', overwrite=T)  # new output file
\end{verbatim}

\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{convolve2d}{Convolve image by a 2D kernel}
 \begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{axes}{Axes to convolve}{[1,2]}{Vector (length 2) of integers}
  \ahaddarg[in]{type}{Type of convolution kernel}{'gaussian'}{String from 'gaussian'}
  \ahaddarg[in]{major}{Major axis}{}{Quantity, string, numeric}
  \ahaddarg[in]{minor}{Minor axis}{}{Quantity, string, numeric}
  \ahaddarg[in]{pa}{Position Angle}{0deg}{Quantity, string, numeric}
  \ahaddarg[in]{scale}{Scale factor}{Autoscale}{Float}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function (short-hand name {\stff c2d}) does Fourier-based
convolution of an \imagefile\ by the given 2D kernel.  

If {\stfaf outfile} is unset, the image is written to the specified disk
file.  If {\stfaf outfile} is not given, the Image \tool\ is associated
with a temporary image.  This temporary image may be in memory or on
disk, depending on its size.  When you destroy the Image \tool\ 
(with the \ahlink{done}{images:image.done} function) this
temporary image is deleted.

You specify which 2 pixel axes of the image you wish to convolve via the
{\stfaf axes} argument.

You specify the type of convolution kernel with {\stfaf type} (minimum
match is active); currently only {\cf 'gaussian'}  is available.  With
time others will be implemented.

You specify the parameters of the convolution kernel via the arguments
{\stfaf major}, {\stfaf minor}, and {\stfaf pa}.   These arguments can
be specified in one of three ways

\begin{itemize}

\item Quantity - for example {\stfaf major=dq.quantity(1, 'arcsec')}
Note that you can use pixel units, viz. {\stfaf major=dq.quantity(1, 'pix')},
see below.

\item String - for example {\stfaf minor='1km'} (i.e. one that the
Quanta \ahlink{Constructor}{quanta:quanta} accepts).
  
\item Numeric - for example {\stfaf major=10}.  In this case, the units
of {\stfaf major} and {\stfaf minor} are assumed to be in pixels.  Using
pixel units allows you to convolve unlike axes. For the position angle,
units of degrees are assumed.
           
\end{itemize}

The interpretation of {\stfaf major} and {\stfaf minor} depends upon the
kernel type.


\begin{itemize}

\item Gaussian - {\stfaf major} and {\stfaf minor} are
the Full Width at Half Maxiumum (FWHM) of the major and minor
axes of the Gaussian.

\end{itemize}

The position angle is measured North through East when you convolve a
plane holding a celestial coordinate (the usual astronomical
convention).  For other  axis/coordinate combinations, a positive
position angle is measured  from +x to +y in the
absolute pixel coordinate frame  (x is the first axis that you
specify with argument {\stfaf axes}). 

The scaling of the output image is determined by the argument {\stfaf scale}.
If you leave it unset, then autoscaling will be invoked.  

If you are not convolving the sky, then autoscaling means that the convolution
kernel will be normalized to have  unit volume so as to conserve flux.

If you are convolving the sky, then there are two cases 
for which autoscaling is useful.

Firstly, if the input image units are Jy/pixel, then the output image
will have units of Jy/beam and be appropriately scaled.  In addition,
the restoring beam of the output image will be the same as the
convolution kernel.

Secondly,if the input image units are Jy/beam, then
the output image will also have units of Jy/beam and be appropriately
scaled.  In addition, the restoring beam of the output image
will be the convolution of the input image restoring beam and the
convolution kernel.

If you do not leave {\stfaf scale} unset, then the convolution kernel
will be scaled by this value (it has peak unity before application
of this scale factor).

Masked pixels will be assigned the value 0.0 before convolution. 
The output mask is the combination (logical OR) of the default input 
\pixelmask\ (if any) and the OTF mask.  Any other input \pixelmasks\
will not be copied.  Use function
\ahlink{maskhandler}{images:image.maskhandler} if you need to copy other
masks too.

See also the other convolution functions
\ahlink{convolve}{images:image.convolve},
\ahlink{hanning}{images:image.hanning}, and
\ahlink{sepconvolve}{images:image.sepconvolve}.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
dowait := T
im := image('xfy')                                                # RA/Freq/DEC
im2 := im.convolve2d(outfile='xyf.con', axes=[1,3], type='gauss',
                     major='20arcsec', minor='10arcsec', pa=45);
#
im := image('xyf')                                                # RA/DEC/Freq
im2 := im.convolve2d(outfile='xyf.con', axes=[1,3], type='gauss',
                     major='20pix', minor='10pix', pa=45);

\end{verbatim}
In the second example we must use pixel units because axes 1 and 3
are unlike.
\end{ahexample}
\end{ahfunction}







\begin{ahfunction}{coordsys}{Get the Coordinate System of the image}
\begin{ahargs}
  \ahaddarg[in]{axes}{Axes to which the Coordinate System pertains}{All axes}{Vector of integers}
\end{ahargs}

\ahreturns{coordsys tool or fail}
\begin{ahdescription}

This function stores the Coordinate System of an image in a {\stf
Coordsys} tool.  

By default, the Coordinate System describes all of the axes in the
image.  If you desire, you can select a subset of the axes, thus
reducing the dimensionality of the Coordinate System.   This may be
useful if you are supplying a Coordinate System to the
constructors  \ahlink{imagefromarray}{images:image.imagefromarray.constructor} or
\ahlink{imagefromshape}{images:image.imagefromshape.constructor}.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('hcn')
- im.summary()
Image name       : hcn
Date observation : 2002/12/31/15:15:36
Image mask       : None
Image units      : JY/BEAM

Direction system : J2000
Frequency system : LSRK
Velocity  system : RADIO
Rest Frequency   : 1.414e+09 Hz

Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
--------------------------------------------------------------------------- 
Right Ascension   SIN   155   31  17:42:29.303    90.00 -1.000000e+00 arcsec
Declination       SIN   178   30 -28.59.18.600    90.00  1.000000e+00 arcsec
Frequency               256   32  1.413350e+09     1.00  1.968717e+04 Hz
Velocity                          1.378053e+02     1.00 -4.174021e+00 km/s
-
-
- cs := im.coordsys([1,2])
- imshape := im.shape()[[1,2]]
- im2 := imagefromshape(outfile='test', shape=imshape, csys=cs)
- im2.summary()
Image name       : test
Image mask       : None
Direction system : J2000
Rest Frequency   : Absent

Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
--------------------------------------------------------------------------- 
Right Ascension   SIN   155  155  17:42:29.303    90.00 -1.000000e+00 arcsec
Declination       SIN   178  178 -28.59.18.600    90.00  1.000000e+00 arcsec


\end{verbatim}

In this example, we create a Coordinate System pertaining to the first two axes
of the image and create a new (empty) 2D image with it with the {\cf imagefromshape}
constructor.
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{coordmeasures}{Convert from pixel to world coordinate wrapped as Measures}
\begin{ahargs}
\ahaddarg[in]{pixel}{Absolute pixel coordinate}{Reference pixel}{Numeric vector}
\ahaddarg[out]{intensity}{Returned intensity quantity for pixel}{}{Quantity}
\ahaddarg[out]{direction}{Returned direction measure for pixel}{}{Direction measure}
\ahaddarg[out]{frequency}{Returned frequency measure for pixel}{}{Frequency measure}
\ahaddarg[out]{velocity}{Returned radial velocity measure for pixel}{}
	{Radio definition RadialVelocity measure}
\end{ahargs}
\ahreturns{\glish\ record or fail}

\begin{ahdescription}

You can use this function to get the world coordinates for a specified
absolute pixel coordinate in the image.  You specify a pixel coordinate
(1-rel) for each axis in the image.    

If you supply fewer pixel values then there are axes in the image, your
value will be padded out with the reference pixel for the missing axes. 
Excess values will be ignored. 

The world coordinate is returned as a record of measures.  This function
is just a wrapper for \ahlink{toworld}{images:coordsys.toworld} (invoked
with argument {\stfaf format='m'}.   Please see its documentation for
discussion about the formatting and meaning of the measures.

This Image \tool\ function adds two additional fields to the return record.

The {\cf mask} field contains the value of the image \pixelmask\ at the
specified position. It is either T (pixel is good) or F (pixel is masked
as bad or the specified position was off the image). 

The {\cf intensity} field contains the value of the image (at the
nearest pixel to that given) and its units.  This is actually stored
as a \ahlink{Quantity}{quanta:quanta}. This field does not exist
if the specified pixel coordinate is off the image.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('myimage')
- meas := im.coordmeasures(im.shape()/2)     
- field_names(meas)                           # Names of measures fields in record
intensity mask direction 
- print meas.intensity
[value=-0.1478955, unit=JY/BEAM]
- print meas.direction
[type=direction, refer=J2000, m1=[value=-0.505949617, unit=rad], 
- m0=[unit=rad, value=-1.64713591]] 
-
- dir := meas.direction                      # Get direction coordinate
-
- dm.doframe(dm.observatory('ATCA'))         # Set location on earth
T
- dm.doframe(dm.epoch('utc', '16jun1999/12:30:20'))   # Set epoch
T
- azel := dm.measure(dir, 'azel')            # Convert to azimuth/elevation
- 
- print 'az,el=', dq.angle(azel.m0), dq.angle(azel.m1)     # Format nicely
az,el= +092.54.56.777 +068.59.59.576

\end{verbatim}

In this example we first find the world coordinates of the centre of the
image.  Then we use the default Measures \tool\ {\stf dm} to convert the
{\cf direction coordinate} field from J2000 to an azimuth and elevation
at a particular location at a particular time. 

\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{decompose}{Separate a complex image into individual components}
\begin{ahargs}
  \ahaddarg[in]{region}{}{unset}{Region tool}
  \ahaddarg[in]{mask}{}{unset}{Boolean LEL expression or mask region}
  \ahaddarg[in]{simple}{Skip contour deblending and scan for local maxima}{F}{T or F}
  \ahaddarg[in]{threshold}{Value of minimum contour}{unset}{Positive Float}
  \ahaddarg[in]{ncontour}{Number of contours to use in deblending}{11}{Int of 2 or greater}
  \ahaddarg[in]{minrange}{Minimum number of closed contours in a component}{1}{Positive Integer}
  \ahaddarg[in]{naxis}{Max number of perpendicular steps between contiguous pixels}{2}{1, 2, or 3}
  \ahaddarg[in]{fit}{Fit to the components after deblending?}{T}{T or F}
  \ahaddarg[in]{maxrms}{Maximum RMS of fit residuals to not retry fit}{unset}{Positive Float}
  \ahaddarg[in]{maxretry}{Maximum number of times to retry the fit}{unset}{Non-negative Integer}
  \ahaddarg[in]{maxiter}{Maximum number of iterations allowed in a single fit}{256}{Positive Integer}
  \ahaddarg[in]{convcriteria}{Criterion to establish convergence}{0.0001}{Positive Float}
\end{ahargs}
\ahreturns{Nothing useful yet - component list is printed to screen}

\begin{ahdescription}
The function decompose is an image decomposition tool that performs several tasks,
with the end result being that a strongly blended image is separated into
components - both in the sense that it determines the parameters for each
parameter (assuming a Gaussian model) and that is physically assigns each
pixel in the image to an individual object.  The products of these two
operations are called the component list and the component map, 
respectively.  The fitting process (which determines the component list) and 
the pixel-decomposition process (which determines the component map) are
designed to work cooperatively to increase the efficiency and accuracy of
both.
 
The algorithm between the decomposition is based on the function clfind
described in Williams et al 1994, which uses a contouring procedure whereby
a closed contour designates a separate component.  The program first 
separates the image into clearly distint 'regions' of blended emission, then
contours each region to determine the areas constituting each component and
passes this information on to the fitter, which determines the component 
list.  

The contour deblending can optionally be replaced with a simpler local maximum
scan, and the fitting can be replaced with a moment-based estimation method to
speed up calculations on very large images or if either primary method causes
trouble, but in general this will impede the accuracy of the fit.

The function works with both two and three dimensional images.
\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage()
- im.decompose(threshold=2.5, maxrms=1.0)
\end{verbatim}
\end{ahexample}
\end{ahfunction} 




\begin{ahfunction}{deconvolvecomponentlist}{Deconvolve a componentlist from the restoring beam}
\begin{ahargs}
  \ahaddarg[in]{complist}{Componentlist to deconvolve}{}{Componentlist tool}
\end{ahargs}
\ahreturns{Componentlist tool or fail}


\begin{ahdescription}

This function (short-hand name {\stff dcl}) deconvolves a Componentlist
\tool\  from the restoring beam, returning a new Componentlist \tool.
If there is no restoring beam, a fail is generated. 

Currently, only deconvolution of Gaussian components is supported.

See also functions \ahlink{setrestoringbeam}{images:image.setrestoringbeam} and
See also \ahlink{restoringbeam}{images:image.restoringbeam}.



\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- local p,m,c;
- cl := im.fitsky(p,m,c, deconvolve=F)
- cl2 := im.deconvolvecomponentlist(cl)
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{delete}{Delete the image file associated with this image tool}
\begin{ahargs}
  \ahaddarg[in]{done}{Destroy this tool after deletion}{T}{T or F}
\end{ahargs}

\ahreturns{T or fail}
\begin{ahdescription}

This function first \ahlink{closes}{images:image.close} the
\imagetool\ which detaches it from its underlying \imagefile.  It then
deletes that \imagefile.  If {\stfaf done=F}, the \imagetool\ is still
viable, and can be used with function \ahlink{open}{images:image.open}
to open a new \imagefile.  Otherwise the \imagetool\ is destroyed. 

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := image('myimage')        # Attach to `myimage'
- im.delete(F)                  # Close imagetool and delete `myimage'
- im.open('myotherimage')       # Open new imagefile `myotherimage'
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{done}{Destroy this image tool}
\begin{ahargs}
  \ahaddarg[in]{delete}{Delete disk file as well ?}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

If you no longer need to use an \imagetool, calling this function will
free up its resources.  That is, it destroys the \tool.  You can no
longer call any functions on the \tool\ after it has been {\stff done}. 

If the Image \tool\ is associated with a disk file,
you can also delete that if you wish by setting
{\stfaf delete=T}.  By default any associated disk
file is not deleted.

This function is different from the {\stff close} function
because the latter does not destroy the \imagetool.  For example, you
can use function {\stff open} straight after {\stff close} on the
same \tool. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage()
- im.done()
- im.open('myfile')      # Error: tool `im' has been destroyed
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{fft}{FFT the image}
\begin{ahargs}
  \ahaddarg[in]{real}{Output real image file name}{}{String}
  \ahaddarg[in]{imag}{Output imaginary image file name}{}{String}
  \ahaddarg[in]{amp}{Output amplitude image file name}{}{String}
  \ahaddarg[in]{phase}{Output phase image file name}{}{String}
  \ahaddarg[in]{axes}{Specify pixel axes to FFT}{Sky plane(s)}{Vector of integers}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function fast Fourier Transforms the image to the Fourier plane. 
If you leave {\stfaf axes} unset, then the sky plane of the image (if
there is one) is transformed.  Otherwise, you can specify which
axes you wish to transform.  Note that if you specify a sky axis, you
must specify both of them. 

You specify which form you wish to see the result in by specifying the
desired output image file name(s).  At some point, an output complex
image will also be allowed (when the Image \tool\ can deal with it). 

Before the FFT is taken, any masked pixels are replaced by zero. 
The output mask is the combination (logical OR) of the default input
\pixelmask\ (if any) and the OTF mask.  Any other input \pixelmasks\
will not be copied.  Use function
\ahlink{maskhandler}{images:image.maskhandler} if you need to copy other
masks too.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- myim := image('gc.small')
- myim.fft(real='r.im', amp='a.im')
\end{verbatim}
This transforms only the sky plane(s).  The real and amplitude 
images only are written out.
\end{ahexample}


\begin{ahexample}
\begin{verbatim}
myim := image('gc.small')
myim.fft(amp='amp.im', phase='p.im', axes=[3])
\end{verbatim}
This transforms only the third axis of the image. The amplitude and phase
images only are written out.
estimate. 
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{findsources}{Find point sources in the sky}
\begin{ahargs}
  \ahaddarg[in]{nmax}{Maximum number of sources to find}{20}{Positive Integer}
  \ahaddarg[in]{cutoff}{Fractional cutoff level}{0.1}{Float}
  \ahaddarg[in]{region}{The 2-D region of interest to fit}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{point}{Find only point sources ?}{T}{T or F}
  \ahaddarg[in]{width}{Half-width of fit grid when point=F}{5}{Integer}
  \ahaddarg[in]{negfind}{Find negative sources as well as positive ?}{F}{T or F}
\end{ahargs}
\ahreturns{Componentlist tool or fail}

\begin{ahdescription}

This function (short-hand name {\stff fs}) finds strong point sources in
the image.  The sources are returned as a
\ahlink{Componentlist}{componentmodels:componentlist} \tool. 

An efficient method is used to locate sources under the assumption that
they are point-like and not too close to the noise.  Only sources with a
peak greater than the {\stfaf cutoff} fraction of the strongest source
will be found.  Only positive sources will be found, unless the {\stfaf
negfind=T} whereupon positive and negative sources will be found. 

After the list of point sources has been made, you may choose to make a
Gaussian fit for each one ({\stfaf point=F}) so that shape information
can be recovered as well.    You can specify the half-width of the
fitting grid with argument {\stfaf width} which defaults to 5 (fitting
grid would then be [11,11] pixels). If you set {\stfaf width=0}, this is
a signal that you would still like Gaussian components returned, but a
default  width should be used for the Gaussian shapes.  The default is
such that the component is circular with a FWHM of {\stfaf width}
pixels.

Thus, if {\stfaf point=T}, the components in the returned Componentlist
are Point components.  If {\stfaf point=F}  then Gaussian components are
returned.

The \region\ must be 2-dimensional and it must hold a region of the sky.
Any degenerate trailing dimensions in the region are discarded.

See also the function \ahlink{fitsky}{images:image.fitsky} (for which
{\stff findsources} can provide an initial estimate) and the
\ahlink{Imagefitter}{images:imagefitter} \tool. 



\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- myim := imagemaketestimage()
- cl := myim.findsources(nmax=5, cutoff=0.5)
- cl.edit(1)
\end{verbatim}

All sources stronger than 0.5 of the strongest will be found.
We use the Componentlist GUI to look at the strongest component.

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{fitallprofiles}{Fit all 1-dimensional profiles in a region}
\begin{ahargs}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{axis}{The profile axis}{Spectral}{Integer or unset}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{ngauss}{Number of Gaussian elements}{1}{Int}
  \ahaddarg[in]{poly}{Order of polynomial element}{None}{Int}
  \ahaddarg[in]{sigma}{Weights image}{unset}{String or unset}
  \ahaddarg[in]{fit}{Output fitted image file name}{None}{String or unset}
  \ahaddarg[in]{resid}{Output fitted residuals image file name}{None}{String or unset}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}
This function fits all of the 1-dimensional profiles in the
specified region with a given combination of Gaussians and a polynomial.
It makes a separate automatic estimate for each profile before making
the fit.

Any masked input pixels do not contribute to the fit. The output mask is
a copy of the default input \pixelmask\ (if any); the OTF mask does not
contribute. Any other input \pixelmasks\ will not be copied.  Use
function \ahlink{maskhandler}{images:image.maskhandler} if you need to
copy other masks too.  Use function
\ahlink{calcmask}{images:image.calcmask} if you need to  apply the OTF
mask to the output.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- myim := image('gc.small')
- myim.fitallprofiles (axis=3, fit='gc.fit')
\end{verbatim}
\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{fitprofile}{Fit 1-dimensional profile with functional forms}
\begin{ahargs}
  \ahaddarg[out]{values}{Output fitted or estimated profile}{None}{Numeric Glish array}
  \ahaddarg[out]{resid}{Output residual profile}{}{Numeric Glish array}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{axis}{The profile axis}{Spectral}{Integer or unset}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{estimate}{Initial estimate}{Unset}{Record}
  \ahaddarg[in]{ngauss}{Number of Gaussian elements}{1}{Int}
  \ahaddarg[in]{poly}{Order of polynomial element}{Unset}{Int}
  \ahaddarg[in]{fit}{Do fit or get estimate}{T}{T or F}
  \ahaddarg[in]{sigma}{Weights image}{unset}{String or unset}
\end{ahargs}
\ahreturns{Record or fail}

\begin{ahdescription}
This function fits 1-dimensional models to profiles.  All data in the specified
region (except along the fitting axis) are averaged.

The behaviour is primarily controlled by argument {\stfaf fit}.

If {\stfaf fit==T} then you need an estimate.  If {\stfaf estimate}
is unset, then that estimate is automatically provided by
fitting {\stfaf ngauss} gaussians.  If {\stfaf estimate}
is set then it is used to provide the initial estimate.

The functional form that is actually fit for will be any polynomial
specified by the {\stfaf poly} argument, plus the number of gaussians 
present in the estimate.

If {\stfaf fit==F} then an estimate is created and returned.
If {\stfaf estimate} is empty, than an estimate for {\stfaf ngauss}
gaussians is made.  If {\stfaf estimate} is not empty, then
it is just evaluated.


After calling this function, argument {\stfaf values} holds the fitted or estimated 
profile values, and argument  {\stfaf resid} holds the fitted or estimated residual 
profile values.

The output mask is a copy of the default input \pixelmask\ (if any); the
OTF mask does not contribute. Any other input \pixelmasks\ will not be
copied.  Use function \ahlink{maskhandler}{images:image.maskhandler} if
you need to copy other masks too.  Use function
\ahlink{calcmask}{images:image.calcmask} if you need to  apply the OTF
mask to the output.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- myim := image('gc.small')
- local values, resid
- fit := myim.fitprofile(values, resid, axis=3, fit=T)     # Auto-est and fit
\end{verbatim}
\end{ahexample}

\end{ahfunction}



\begin{ahfunction}{fitpolynomial}{Fit 1-dimensional polynomials to profiles}
\begin{ahargs}
  \ahaddarg[in]{residfile}{Output fitted residuals image file name}{unset}{String or unset}
  \ahaddarg[in]{fitfile}{Output fitted image file name}{unset}{String or unset}
  \ahaddarg[in]{sigmafile}{Input weights image for fitting}{unset}{String or unset}
  \ahaddarg[in]{axis}{The profile axis to fit}{Spectral axis if exists else last}{Integer or unset}
  \ahaddarg[in]{order}{The order of the polynomial}{0}{Integer or unset}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output files ?}{F}{T or F}
\end{ahargs}
\ahreturns{Image tool or fail}
\begin{ahdescription}

This function fits 1-dimensional polynomials to profiles and subtracts the fits.
You specify the order of the polynomial via the {\stfaf order} argument.
The returned Image tool holds the residual image. You can optionally
also write out the fitted image.

The output mask is a copy of the default input \pixelmask\ (if any); the
OTF mask does not contribute to the output mask. Any other input
\pixelmasks\ will not be copied.  Use function
\ahlink{maskhandler}{images:image.maskhandler} if you need to copy other
masks too.  Use function \ahlink{calcmask}{images:image.calcmask} if you
need to  apply the OTF mask to the output.

\begin{ahexample}
\begin{verbatim}
- myim := image('hcn')
- myim2 := myim.fitpolynomial(order=2, axis=3)      # Image tool is virtual
\end{verbatim}
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- myim := image('hcn')
- mask := 'indexin(3, [1:20, 30, 35, 50:60, 90:128])'        # Specify pixels to fit via mask on 
- myim2 := myim.fitpolynomial(order=2, mask=mask, axis=3)    # axis 3
\end{verbatim}
\end{ahexample}

This example could be thought of, for example, as an image-based continuum substraction.
You specify the axis and the pixels where the spectrum is line free
(continuum), do the fit and write out the residual (continuum subtracted)
image.

\end{ahfunction}



\begin{ahfunction}{fitsky}{Fit 2-dimensional models to the sky}
\begin{ahargs}
  \ahaddarg[out]{pixels}{Output residual pixels}{}{Numeric Glish array}
  \ahaddarg[out]{pixelmask}{Output mask of region}{}{Boolean Glish array}
  \ahaddarg[out]{converged}{Did the fit converge ?}{}{T or F}
  \ahaddarg[in]{region}{The 2-D region of interest to fit}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{models}{The model types to fit simultaneously}{gaussian}
           {Vector of strings from `gaussian'}
  \ahaddarg[in]{estimate}{Initial estimate for the model}{Internal estimate made}{Componentlist tool}
  \ahaddarg[in]{fixed}{Parameters to hold fixed per model}{All parameters vary}
           {String or vector of strings, one per model. Choose from ``fxyabp''}
  \ahaddarg[in]{includepix}{Range of pixel values to include}{See below}{Vector of 1 or 2 Floats}
  \ahaddarg[in]{excludepix}{Range of pixel values to exclude}{See below}{Vector of 1 of 2 Floats}
  \ahaddarg[in]{fit}{Do fit or get estimate}{T}{T or F}
  \ahaddarg[in]{deconvolve}{Deconvolve from restoring beam}{F}{T or F}
  \ahaddarg[in]{list}{List informative messages to the logger}{T}{T or F}
\end{ahargs}
\ahreturns{Componentlist tool or fail}

\begin{ahdescription}

This function fits 2-dimensional models to regions of the
sky.  You can fit multiple models simulataneously, although only
Gaussian models are currently implemented.  The fit is returned as a
\ahlink{Componentlist}{componentmodels:componentlist} \tool.  See also
the \ahlink{imagefitter}{images:imagefitter} \tool\ which is an
interactive high-level \tool\ based around this function. 


\begin{itemize}

\item If {\stfaf fit=T} the fit is done and returned.
If {\stfaf fit=F} the fit is not done.  Instead, the initial
auto-determined estimate is returned (this is used as the
starting guess of the actual fit); in this case, arguments
{\stfaf pixels, pixelmask, converged, estimate} and {\stfaf fixed} are
ignored.   The auto-fit can only be determined for a single
model.

\item The {\stfaf pixels} array is returned to you with the residual of
the fit.  The {\stfaf pixelmask} array is returned to you with the \pixelmask\ of
the specified region (this reflects both the underlying \pixelmask\ that
you applied [if any] as well as the shape of the region). 

\item If the fit converged, {\stfaf converged=T} on return.

%\item Currently, the Componentlist \tool\ does not contain 
%error values.  Therefore the errors are returned in a second Componentlist
%\tool\ (argument {\stfaf error}) where the values are the errors
%(does not account for spatial correlation yet).

\item The \region\ must be 2-dimensional and it must hold a region of the
sky.   Any degenerate trailing dimensions in the region are discarded.

\item The {\stfaf models} argument specifies the simultaneous  model
types you would like to fit to the specified region.  Currently you can
only choose from `gaussian' (minimum match).  Specify the {\stfaf
models} argument as a vector of strings, or a string with comma or space
delimiters.  Thus, to fit 3 simultaneous gaussians, you would give
{\stfaf models='gaussian gaussian gaussian'}.

\item An initial automatically determined estimate of the parameters of
the model can be made for you (only for single model fits).  However, if
this turns out to be poor, or if you want to hold some parameters fixed,
then you can enter your estimate with the {\stfaf estimate} argument to
which you supply a \ahlink{Componentlist}{componentmodels:componentlist}
\tool\ (the same type of \tool\ that is returned by this function).  The
estimate doesn't have to be the same type as the model you are fitting. 
For example you can give a Point model estimate for a Gaussian fit. 
The other parameter estimates will be filled in for you. 
The function \ahlink{findsources}{images:image.findsources} can
be used to get rough point source estimates.  You must supply
one estimate component for every model component that you wish to fit
when fitting multiple simultaneous models.


\item When you fit a model, you can choose which parameters you hold
fixed in the fit and which you solve for.  The {\stfaf fixed} argument
enables you to specify which parameters of the fit you hold fixed.  It
is entered as a vector of strings, one string for each model specifying
which parameters of the fit are fixed.

For gaussian models, that string should contain letters chosen from

\begin{itemize}
\item `f' - hold the flux (intensity) of the model fixed
\item `x' - hold the X location of the model fixed
\item `y' - hold the Y location of the model fixed
\item `a' - hold the major axis width fixed
\item `b' - hold the minor axis width fixed
\item `p' - hold the position angle fixed
\end{itemize}

If you hold any parameters fixed, you may need to specify an
input estimate.

\item Often when fitting, it is advisable to exclude noise pixels.  The
{\stfaf includepix} (pixel value range to include) or {\stfaf
excludepix} (pixel value range to exclude) arguments (you can't specify
them both) allow you to select a subset of the pixels for the fit.  If
you only give one value for either of these vectors, say {\stfaf
includepix=[b]}, then this is interpreted as {\stfaf
includepix=[-abs(b),abs(b)]}.  

For total intensity (Stokes I) images, if neither of these are specified
and  the peak in the region is positive, then all
pixels below zero are discarded.  If the peak is negative (a negative
source), all pixels above zero are discarded.  For other Stokes
parameters all pixels are included by default. 


\end{itemize}


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- myim := image('gc.small')
- local pixels, pixelmask, converged
- cl1 := myim.fitsky(pixels, pixelmask, converged, models="gaussian")
- if (!is_fail(cl1) && converged) {
  myim2 := image('gc.big')
  cl2 := myim2.fitsky(pixels, pixelmask, converged, models="gaussian", estimate=cl1)
}
\end{verbatim}

In this example we assume the image is 2-dimensional.  We fit the first
image using the internal starting estimate for the model parameters.  We
fit the second image using the result of the first fit as the starting
estimate. 


\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{getchunk}{Get the pixel values from a regular region of the image into a Glish array}
\begin{ahargs}
  \ahaddarg[in]{blc}{Bottom-Left-Corner (beginning) of pixel section}{Start of image}{Vector of integers}
  \ahaddarg[in]{trc}{Top-Right-Corner (end) of pixel section}{End of image}{Vector of positive integers}
  \ahaddarg[in]{inc}{increment (stride) along axes}{1}{Vector of positive integers}
  \ahaddarg[in]{axes}{Axes to average over}{None}{Vector of positive integers}
  \ahaddarg[in]{list}{List bounding box to logger ?}{F}{T or F}
  \ahaddarg[in]{dropdeg}{Drop degenerate axes ?}{F}{T or F}
  \ahaddarg[in]{getmask}{Get the pixel mask as well}{F}{T or F}
\end{ahargs}
\ahreturns{Glish array, Record, or fail}
\begin{ahdescription}

This function returns the pixels (and opionally the pixel mask) from the
\imagefile\ between {\stfaf blc} and {\stfaf trc} inclusively.  An
increment may be specified with {\stfaf inc}.  Note that if you retrieve
too many pixels, you might cause swapping since the pixels are kept in
memory. 

Any illegal {\stfaf blc} values are set to unity.  Any illegal {\stfaf
trc} values are set to the end of the image.  If any {\stfaf trc $<$
blc}, you get the whole image for that axis.  Any illegal {\stfaf inc}
values are set to unity. 

The argument {\stfaf axes} can be used to reduce the dimensionality of
the output array. It specifies which pixel axes of the image
{\bf average} the data over.  For example, consider a 3-D image.
With {\stfaf axes=[1,2]} and all other arguments left at their defaults,
the result would be a 1-D vector, a profile along the third axis,
with the data averaged over the first two axes.

A related function is \ahlink{getregion}{images:image.getregion} which
retrieves the pixels and \pixelmask\ from a potentially more complex \region. 
Function {\stff getchunk} is retained because it is faster and therefore
preferable for repeated operation in loops if the \pixelmask\ is not required
and the region is a simple box.

If you ask for the pixel mask as well, the return value is
a record holding two fields, 'pixel' and 'pixelmask'.  If
you do not ask for the pixel mask (default), the pixels
are returned directly.

\end{ahdescription}

\begin{ahexample}
Suppose that we have a 3-dimensional image called {\sff im}. Then:
\begin{verbatim}
- pix := im.getchunk()                      # all pixels
- pix := im.getchunk([1,1,1], [10,10,1])    # 10 by 10 section of plane # 1
- pix := im.getchunk([1,1], [1,1])          # first spectrum
- pix := im.getchunk(inc=[1,5])             # all planes, decimated by 5 in y
#
- rec := im.getchunk(getmask=T)             # Get pixels and pixelmask
- print field_names(rec)                    # into named fields of record
pixel pixelmask                             
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{getregion}{Get pixels and mask from a region-of-interest of the image}
\begin{ahargs}
  \ahaddarg[out]{pixels}{The recovered pixel values}{}{Glish array}
  \ahaddarg[out]{pixelmask}{The recovered pixel mask values}{}{Glish array}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{axes}{Axes to average over}{None}{Vector of positive integers}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{list}{List the bounding box to the logger}{F}{T or F}
  \ahaddarg[in]{dropdeg}{Drop degenerate axes}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function recovers the image pixel and \pixelmask\ values in the
given \ahlink{region-of-interest}{images:regionmanager}.  You can
recover either or both of these by specifying the appropriate argument.
Regardless of the shape of the {\stfaf region} you have specified, the
shape of the {\stfaf pixels} and {\stfaf pixelmask} arrays must
necessarily be the bounding box of the specified region.  If the region
extends beyond the image, it is truncated.

Recall that the recovered \pixelmask\ will reflect both the \pixelmask\
stored in the image, and the \region\ (their masks are `anded') -- see
the \htmlref{discussion}{IMAGE:MASKSANDREGIONS} in the introduction
about this. 

The argument {\stfaf axes} can be used to reduce the dimensionality of
the output array. It specifies which pixel axes of the image
average the data over.  For example, consider a 3-D image.
With {\stfaf axes=[1,2]} and all other arguments left at their defaults,
the result would be a 1-D vector, a profile along the third axis,
with the data averaged over the first two axes.

This function differs in three ways from {\stff getchunk}.  First, the
region can be much more complex (e.g.  a union of polygons) than the
simple {\stfaf blc}, {\stfaf trc}, and {\stfaf inc} of {\stff getchunk}
(although such a region can be created of course).  Second, it recovers
the \pixelmask\ as well as the pixels.  Third, it is less efficient than {\stff
getchunk} for doing the same thing as {\stff getchunk}.  So if you are
interested in say, iterating through an image, getting a regular
hyper-cube of pixels and doing something with them, then {\stff
getchunk} will be faster.  This would be especially noticeable if you
iterated line by line through a large image. 

\end{ahdescription}

\begin{ahexample}
Suppose that we have a 3-dimensional image called {\sff cube} and wish
to recover the pixel and \pixelmask\ values from a simple regular region.
\begin{verbatim}
- im := image('cube')
- r1 := drm.box(blc=[10,10,10], trc=[30,40])  # Create region 
- local pixels, pixelmask
- im.getregion(pixels, pixelmask, r1)
\end{verbatim}
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- im := image('cube')
- local mm, pp
- im.getregion(pixels=pp)  
- im.getregion(pixelmask=mm)  
\end{verbatim}
In these examples we recover first the pixels only and then the pixel mask only.
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{getslice}{Get 1-D slice from the image}
\begin{ahargs}
  \ahaddarg[in]{x}{Polyline x vertices in absolute pixel coordinates}{}{Vector of float}
  \ahaddarg[in]{y}{Polyline y vertices in absolute pixel coordinates}{}{Vector of float}
  \ahaddarg[in]{axes}{Pixel axes of plane holding slice}{First two axes}{Vector of integers}
  \ahaddarg[in]{coord}{Specify pixel coordinate for other axes}{Unity}{Vector of integers}
  \ahaddarg[in]{npts}{Number of points in slice}{Auto determination}{Integer}
  \ahaddarg[in]{method}{The interpolation method}{'linear'}{String from 'nearest', 'linear', 'cubic'}
  \ahaddarg[in]{plot}{Make a plot of the slice}{F}{T or F}
\end{ahargs}
\ahreturns{Glish Record, or fail}
\begin{ahdescription}

This function returns a 1-D slice (the pixels and opionally the pixel mask) from the
\imagefile.   The slice is constrained to lie in a plane of two  cardinal axes
(e.g. XY or YZ).  At some point this constraint will be relaxed.
A range of interpolation schemes are available.

You specify the slice as a polyline giving the x ({\stfaf x}) and y ({\stfaf y} 
coordinates and the axes of the plane holding that slice ({\stfaf axes}).
As well, you must specify the absolute pixel coordinates of the other
axes ({\stfaf coord}).  This defaults to the first pixel (e.g. first plane).

The return value is a Glish record with fields 'pixels' (interpolated intensity), 
'mask' (interpolated mask), 'xpos' (x-location in absolute pixel coordinates), 
'ypos' (y-location in absolute pixel coordinates), 'distance' (distance along
slice in pixels), 'axes' (the x and y axes of slice).

You can optionally plot the slice via argument {\stfaf plot} which defaults
to False.


\end{ahdescription}

\begin{ahexample}
Suppose that we have a 3-dimensional image called {\sff im}. Then:
\begin{verbatim}
- im := imagemaketestimage();
- rec := im.getslice (x=[1,20], y=[2,30])             # SLice from [1,2] -> [20,30]
- print field_names(rec)              
pixel mask xpos ypos distance axes      
-
- rec := im.getslice (x=[1,20,25,11], y=[2,30,32,40]) # Polyline slice
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{hanning}{Convolve one axis of image with a Hanning kernel}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{axis}{Axis to convolve}{Spectral axis if there is one}{Positive integer}
  \ahaddarg[in]{drop}{Drop every other pixel on output ?}{T}{Bool}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function performs Hanning convolution ($z[i] = 0.25*y[i-1] +
0.5*y[i] + 0.25*y[i+1]$) of one axis of an image.  The convolution is
done in the image domain (i.e., not with an FFT). You can optionally drop
every other pixel on output. If you do this, the first output
pixel is centred on the second input pixel. 

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated
with a temporary image.  This temporary image may be in memory or on
disk, depending on its size.  When you destroy the Image \tool\ 
(with the \ahlink{done}{images:image.done} function) this
temporary image is deleted.

Masked pixels will be assigned the value 0.0 before convolution. 
The output mask is the combination (logical OR) of the default input
\pixelmask\ (if any) and the OTF mask.  Any other input \pixelmasks\
will not be copied.  Use function
\ahlink{maskhandler}{images:image.maskhandler} if you need to copy other
masks too.


See also the other convolution functions
\ahlink{convolve2d}{images:image.convolve2d},
\ahlink{sepconvolve}{images:image.sepconvolve} and
\ahlink{convolve}{images:image.convolve}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- dowait := T
- im := image('x')
- im2 := im.hanning(outfile='x.hann')
\end{verbatim}

This would Hanning smooth the spectral axis of the image associated with
the \imagetool\ {\stf im}, if there is one.  Every other pixel on the
convolution axis is dropped on output, by default. 

\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{haslock}{Does this image have any locks set ?}
\ahreturns{Vector of Bool or fail}
\begin{ahdescription}

This function can be used to find out whether the image has a read or a
write lock set.  It is not of general user interest.   It returns
a vector of Booleans of length 2.  Position 1 says whether
a read lock is set, position 2 says whether a write lock is set.

In general locking is handled automatically, with a built in lock
release cycle.  However, this function can be useful in scripts when a
file is being shared between more than one process.  See also functions
\ahlink{unlock}{images:image.unlock} and
\ahlink{lock}{images:image.lock}. 


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('xx')
- im.lock(write=T)
- im.haslock()
[T T]
- im.unlock()
- im.haslock()
[F F]
- im.lock(F)
- im.haslock()
[T F]
\end{verbatim}
This acquires a read/write lock on the file and then unlocks it
and acquires just a read lock.
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{histograms}{Compute histograms from the image}

\begin{ahargs}
  \ahaddarg[out]{histout}{Glish record containing the histograms}{No retrieval}{Glish variable}
  \ahaddarg[in]{axes}{List of axes to compute histograms over}{All axes}{Vector of integers}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{nbins}{Number of bins in histograms}{25}{Positive integer}
  \ahaddarg[in]{includepix}{Range of pixel values to include}{Include all pixels}{A vector of 1 or 2 Floats}
  \ahaddarg[in]{gauss}{If T overlay a Gaussian on each histogram}{F}{Bool}
  \ahaddarg[in]{cumu}{If T plot cumulative histograms, otherwise plot non-cumulatively}{F}{Bool}
  \ahaddarg[in]{log}{If T plot the ordinate logarithmically, otherwise plot linearly}{F}{Bool}
  \ahaddarg[in]{list}{If T then list some statistics as well}{T}{Bool}
  \ahaddarg[in]{plotter}{The PGPLOT device name to make plots on}{No plotting}{Any valid PGPLOT device}
  \ahaddarg[in]{nx}{The number of subplots per page in the x direction}{1}{Positive integer}
  \ahaddarg[in]{ny}{The number of subplots per page in the y direction}{1}{Positive integer}
  \ahaddarg[in]{size}{Size of plotter}{[600,450]}{Vector of integers}
  \ahaddarg[in]{force}{If T then force the stored statistical accumulations to be regenerated}{F}{Bool}
  \ahaddarg[in]{disk}{If T then force the storage image to disk}{F}{Bool}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait - but always F if plotting}{Bool}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function (short-hand name is {\stff histo}) computes histograms of
the pixel values in the \imagefile.  You can plot them and retrieve them
(into a \glish\ record) for further analysis or display. 

The chunk of the image over which you compute the histograms is
specified by a vector of axis numbers (argument {\stfaf axes}).  For
example, consider a 3-dimensional image for which you specify {\stfaf
axes=[1,3]}.  The histograms would be computed for each XZ (axes 1 and
3) plane in the image.  You could then examine those histograms as a
function of the Y (axis 2) axis.  Or perhaps you set {\stfaf axes=[3]},
whereupon you could examine the histogram for each Z (axis 3) profile as
a function of X and Y location in the image. 

You have control over the number of bins for each histogram ({\stfaf 
nbins}).  The bin width is worked out automatically for each histogram
and may vary from histogram to histogram (the range of pixel values is
worked out for each chunk being histogrammed). 

You have control over which pixels are included in the histograms via
the {\stfaf includepix} argument.  This vector specifies a range of
pixel values to be included in the histograms.  If you only give one
value for this, say {\stfaf includepix=[b]}, then this is interpreted as
{\stfaf includepix=[-abs(b),abs(b)]}.  If you specify an inclusion
range, then the range of pixel intensities over which the histograms are
binned is given by this range too.  This is a way to make the bin width
the same for each histogram. 

You have control over the form of the histogram; the ordinate can be
linear or logarithmic ({\stfaf log=T}), and cumulative or non-cumulative
({\stfaf cumu=T}). 

You can overlay a Gaussian on each histogram ({\stfaf gauss=T}). It has
the same mean and standard deviation about the mean of the pixels that
were binned and the same integral as the histogram. 

You can list some additional statistical information about the data in
each image chunk that is being histogrammed ({\stfaf list=T}). 

You can retrieve the histograms into a \glish\ record (the counts and
the abcissa values for each histogram).  The names of the fields in the
record are {\cf `values'} and {\cf `counts'}.  The shape of the first
dimension of those arrays contained in those fields is {\stfaf nbins}. 
The number and shape of the remaining dimensions are those in the image
for which you did not compute the histograms.  For example, in the
second example above, we set {\stfaf axes=[3]} and asked for histograms
as a function of the remaining axes, in this case, the X and Y (axes 1
and 2) axes.  The shape of each histogram array is then [nbins,nx,ny]. 
The form of the retrieved histograms is that specified by the {\stfaf
cumu} and {\stfaf log} arguments. 

The plotting is done directly on a PGPLOT plotting device (function
is always run synchronously when plotting). 
The syntax is {\stfaf plotter=name/type}.  For example
{\stfaf plotter='plot1.ps/ps'} (disk postscript file)
or {\stfaf plotter='plot1/glish'} (Glish PGplotter).

This function generates ``storage'' images, into which the histograms
and statistics are written.  They are only regenerated when necessary.
For example, if you run the function twice successively with identical arguments,
the histograms will be directly retrieved from the storage image.
However, you can force regeneration of the storage image
if you set {\stfaf force=T}.   The storage medium is either in memory
or on disk, depending upon its size.  You can force it to
disk if you set {\stfaf disk=T}, otherwise it decides for itself.



\end{ahdescription}

\begin{ahexample} 
\begin{verbatim} 
- im.histograms(plotter='plot/glish')
\end{verbatim} 
In this example we plot the histogram of the entire image
on a PGPLOT X-windows device.
\end{ahexample}

\begin{ahexample} 
\begin{verbatim} 
- im.histograms(histout=myhist,axes=[1,3],nbins=30,includepix=1e-3,
                cumu=T,gauss=T,plotter='plot/glish',nx=4,ny=3)
\end{verbatim} 

In this example, let us assume the image has 3 dimensions.  We
generate cumulative histograms of XZ (axes 1 and 3) planes for pixels
with values in the range $-0.001$ to $0.001$ and plot them with Gaussian
overlays as a function of Y-axis location on the standard PGPLOT
X-windows device with 12 plots per page.  The histograms are retrieved
into a \glish\ record called {\gvf myhist} for further use (because
we are plotting the function is run synchronously).

\end{ahexample}

\end{ahfunction} 


\begin{ahfunction}{history}{Recover and/or list the history file}

\begin{ahargs}
  \ahaddarg[in]{list}{List history to the logger ?}{F}{T or F}
  \ahaddarg[in]{browse}{Browse history with table browser?}{T}{T or F}
\end{ahargs}
\ahreturns{Vector of strings, T, or fail}


\begin{ahdescription}

This function allows you to access the history file.

By default, you browse it with the Table browser ({\stfaf browse=T})
and the return value is T or a fail.

If {\stfaf browse=F}, then if {\stfaf list=F},
the history is returned by the function as a vector of strings.  
If {\stfaf list=T}, the history is sent to the logger
and the function returns T or a fail.

Currently, \aipspp\ does not write new history information (although 
you can set directly set a new history file with the function
\ahlink{sethistory}{images:image.sethistory}). Only that which has come
from \fits\ file conversions will be stored and listable here. 


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im.history();                       # Browse
- h := im.history(list=F, browse=F)   # Recover history in variable h
- im.history(list=T, browse=F)        # List  history to logger
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{id}{Return the fundamental identifier of this tool}
\begin{ahdescription}

This function should be of little interest to users. It returns the 
fundamental identifier of the tool.

\end{ahdescription}

\ahreturns{ToolID - a record}

\begin{ahexample}
\begin{verbatim}
- id := im.id()
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{insert}{Insert specified image into this image}
\begin{ahargs}
  \ahaddarg[in]{infile}{Image file name or Image tool to insert}{unset}{String}
  \ahaddarg[in]{region}{The region of interest of the input image}{Whole image}{Region tool}
  \ahaddarg[in]{locate}{Location of input image in output image}{Centrally located}{Vector}
\end{ahargs}
\ahreturns{Image tool or fail}


\begin{ahdescription}

This function inserts the specified image (or part of it) into this image.
The specified image may be given via argument {\stfaf infile}
as a disk file name (it may be in native \aipspp, \fits, or Miriad
format; Look \htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
information on foreign images) or directly as an Image tool. 

If the {\stfaf locate} vector is not given, then the images are
aligned (to an integer pixel shift) by their reference pixels.

If {\stfaf locate} vector is given, then those values that are given,
give the absolute pixel in the output (this) image of the bottom left
corner of the input (sub)image.  For those values that are not given,
the input image is symmetrically placed in the output image. 

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- dowait := T
- im := imagefromshape(shape=[200,200])
- im.insert(infile='myfile.insert')              # Align by reference pixel
- im.set(0.0)
- im2 := image('myfile.insert')
- im.insert(infile=im2, locate=[])               # Align centrally, specify as Image tool
- im.set(0.0)
- im.insert(infile='myfile.insert', locate=[20]) # Align axis 1 as given and axis 2 centrally
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{isopen}{Is this Image \tool\ open ?}
\ahreturns{Bool}
\begin{ahdescription}

This function can be used to find out whether the Image \tool\
is open or not.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage('zz')
- im.isopen()
T
- im.close()
- im.isopen()
F
- im.open('zz')
F
- im.isopen()
T
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{ispersistent}{Is the image persistent ?}
\ahreturns{Bool or fail}
\begin{ahdescription}

This function can be used to find out whether the image is persistent on
disk or not.  There is a subtle difference from the image being
virtual.  For example, a virtual image which references another
which is on disk is termed persistent.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagefromshape(outfile='tmp', shape=[10,20])
- im.ispersistent()
T
- im2 := imagefromimage(infile='tmp', region=drm.box())
- im2.ispersistent()
F
- im3 := im2.subimage()
- im3.ispersistent()                  # Persistent virtual image !
T
- im4 := imagecalc(pixels='tmp+tmp2')
- im4.ispersistent()
F
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{lock}{Acquire a lock on the image}

\begin{ahargs}
  \ahaddarg[in]{write}{Acquire a read/write (T) or a readonly (F) lock}{T}{T or F}
  \ahaddarg[in]{nattempts}{Number of attempts}{Forever}{Non-negative integer}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function can be used to acquire a Read or a Read/Write lock
on the \imagefile.   It is not of general user interest.  

In general locking is handled automatically, with a built in lock
release cycle.  However, this function can be useful in scripts when a
file is being shared between more than one process.  See also functions
\ahlink{unlock}{images:image.unlock} and \ahlink{haslock}{images:image.haslock}.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('xx')
- im.lock(write=T)
- im.unlock()
- im.lock(write=F)
\end{verbatim}
This acquires a read/write lock on the file. Then we unlock it
and acquire a readonly lock.
\end{ahexample}

\end{ahfunction}




\begin{ahfunction}{makecomplex}{Make a complex image}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output Complex (disk) image file name}{}{String}
  \ahaddarg[in]{imag}{Imaginary image file name}{}{String}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function combines the current image with another image to make
a complex image.  The current image (i.e. that associated with this
Image \tool\ is assumed to be the Real image).  You supply
the Imaginary image; it must be disk-based at this time.

The output image cannot be associated with an Image \tool\ (does
not handle Complex images yet) and so the best you can do is
write it to disk.  The Viewer can view it.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- myim := image('im.real')
- myim.makecomplex('im.complex', 'im.imag')
\end{verbatim}
\end{ahexample}

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{maskhandler}{Handle pixel masks}
\begin{ahdescription}

\begin{ahargs}
  \ahaddarg[in]{op}{The operation}{}{String, one of `set', `default', `delete', `rename', `get', `copy'}
  \ahaddarg[in]{name}{Name of mask or masks}{}{Vector of strings}
\end{ahargs}
\ahreturns{Vector string, string, T or fail}

This function (short-hand name {\stff mh}) is used to manage or handle
\pixelmasks\ (there is also a custom GUI interface through the
\ahlink{maskhandlergui}{images:image.maskhandlergui} function).  An
\aipspp\ image may contain zero, one or more \pixelmasks.  Any of these
masks can be designated the default \pixelmask.  The
default mask is acted upon by \aipspp\ applications.  For example, if
you ask for statistics from an image, pixels which are masked as bad (F)
will be excluded from the calculations. 

This function has an argument ({\stfaf op}) that specifies the
behaviour.  In all cases, you can shorten the operation string to three
characters.  It is not the job of this function to modify the values of
masks. 

\begin{itemize} 

\item{default - } this retrieves  the name of the default \pixelmask\
as the return value of the function call.

\item{get - } this retrieves the name(s) of the existing \pixelmasks\
as the return value of the function call (string or vector of strings).

\item{set - } this lets you change the default \pixelmask\ to that given by the
{\stfaf name} argument.  If {\stfaf name} is empty, then the default
mask is unset (i.e. an all good mask is effectively applied).

\item{delete - } this lets you delete the \pixelmasks\ specified by the
{\stfaf name} argument.  To delete more than one mask, {\stfaf name} can
be a vector of strings.    Any supplied \pixelmask\ name that does not
exist is silently ignored.

\item{rename - } this lets you rename the mask specified by {\stfaf name[1]}
to {\stfaf name[2]}.  Thus the {\stfaf name} argument must be a vector of
length 2.

\item{copy - } this lets you copy a mask to another in the same image, or
copy a mask from another image into this image.  Thus the {\stfaf name}
argument must be a vector of length 2.

For the first case, the first element of {\stfaf name} must be the name
of the mask to copy, and the second element must be the name of the
\pixelmask\ to which it will be copied. 

For the second case, the first element of {\stfaf name} must be the name
of the input image and \pixelmask\ with a colon delimiter (e.g. {\cf
hcn:mask2}). The second element must be the name of the \pixelmask\ to
which the input \pixelmask\ will be copied. 

\end{itemize}

Use the \ahlink{summary}{images:image.summary} function to see the
available \pixelmasks.  You can do this either via the logger display, or via
the returned record, which contains the mask names. In the logger display,
any \pixelmask\ which is not the default mask is listed in square brackets.  If
a default mask is set, it is listed first, and is not enclosed in square
brackets. 


\end{ahdescription}



\begin{ahexample}
\begin{verbatim}
- im := image('myimage')
- local names, name
- names := im.maskhandler('get')            # Get the mask names
- name := im.maskhandler('default')         # Get the default mask names
- im.maskhandler('set', 'mask1')            # Make 'mask1' the default mask
- im.maskhandler('set', '')                 # Unset the default mask
- im.maskhandler('delete', 'mask1')         # Delete 'mask1' 
- im.maskhandler('delete', 'mask0 mask1')   # Delete 'mask0' and 'mask1' 
- im.maskhandler('rename', 'mask1 mask0')   # Rename 'mask1' to 'mask0'
- im.maskhandler('copy', 'g1.app:mask1 mask10')   # Copy 'mask1' from image 'g1.app'  to 'mask10' in image 'myimage'
\end{verbatim}
\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{maskhandlergui}{Handle masks using a GUI interface}
\begin{ahargs}
  \ahaddarg[in]{parent}{Parent frame to embed GUI in}{Create stand alone}{\glish\/Tk agent}
  \ahaddarg[in]{widgetset}{The widgetset to use for the GUI}{dws}{A widgetserver tool}
\end{ahargs}
\ahreturns{Agent or fail}

\begin{ahdescription}

\medskip
{\bf General}
This function (short-hand name {\stff mhgui}) starts the custom GUI
interface for the \ahlink{maskhandler}{images:image.maskhandler}
function.  Here is an example of the GUI.

\begin{figure}[h]
\begin{center}
\epsfig{file=imagemaskhandlergui.ps, width=4.5in}
\caption{The maskhandler GUI}
\label{fig:maskhandlergui}
\end{center}
\end{figure}


The left-hand list box shows you the \pixelmasks\ currently available in the
image.  Underneath the list box the default \pixelmask, if any, is listed. 
You have buttons under the left-hand list box to apply the desired
operation.  The sequence is to select a \pixelmask\ or \pixelmasks\ from the list box,
and then click the desired button.  Popuphelp is on each button to tell
you what they do. 

The right-hand list box is used to list the \pixelmasks\ from some other image. 
You enter the \imagefile\ name with the file entry widget and then enter
carriage-return.  You can copy masks from that \imagefile\ to the
current image. 

If you don't provide a parent frame (the {\stfaf parent} argument),
the GUI is made in a standalone mode.  This means it creates
go, reset and dismiss buttons.  If you provide the parent frame,
you must also provide these buttons and act on them.


\medskip
{\bf Recovering the GUI}

When you run this function, it returns an agent which is actually a
reference to the underlying GUI.  In addition, the GUI is left on the
screen.  You can explicitly dismiss it by pressing the Dismiss button or
selecting Dismiss from the File menu.  To recover the GUI you can do one
of two things. 

\begin{enumerate}

\item Run the command {\stfaf maskhandlergui} again.  This will return
another reference of the GUI to you.  However, it will reset some parts
of the GUI because it is possible that the image changed since you last
ran this function (the \pixelmasks\ might have changed, it might even be
a different \imagefile\ attached to this \tool). 

Thus

\begin{verbatim}
- im := image('myimage')
- g := im.maskhandlergui()             # Click Dismiss on GUI
- g := im.maskhandlergui()             # Get GUI back with some reset
\end{verbatim}


\item Apply the {\stfaf gui} function to the reference
returned when you ran the {\stfaf maskhandlergui} function.
This simply recovers the GUI with no resetting.  If the
image {\bf has} changed, this will not reflect it.

\begin{verbatim}
- im := image('myimage')
- g := im.maskhandlergui()             # Click Dismiss on GUI
- g.gui()                              # Get GUI back with no change
\end{verbatim}
\end{enumerate}


If you destroy the GUI (by selecting Done from  the File
menu) then you must run the \ahlink{momentsgui}{images:image.momentsgui} function
again to regenerate it.


\end{ahdescription}
\end{ahfunction}

\begin{ahfunction}{miscinfo}{Get the miscellaneous information record from an image}
\ahreturns{Glish record or fail}

\begin{ahdescription}

An \aipspp\ \imagefile\ can accumulate various miscellaneous information
during its lifetime; it is stored in a \glish\ record called the {\stff
miscinfo} record.  For example, the \fits\ filler puts header keywords
it doesn't otherwise use into the {\stff miscinfo} record.  This {\stff
miscinfo} record is not guaranteed to have any entries, so it's up to
you to check for any fields that you require. 

You can also put things into this record (see
\ahlink{setmiscinfo}{images:image.setmiscinfo}) yourself, to keep
information that the system might not otherwise store for you. 

When the image is written out to \fits, the items in the
{\stff miscinfo} record are written to the \fits\ file
as keywords with the corresponding record field name.


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im.miscinfo()             # print the record
[bscale=1, bzero=0, cellscal=CONSTANT] 
- header := im.miscinfo()   # capture the record for further use
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{modify}{Modify image with a model}
\begin{ahargs}
  \ahaddarg[in]{model}{The model}{}{Componentlist tool}
  \ahaddarg[in]{region}{The 2-D region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{subtract}{Subtract or add the model}{T}{T or F}
  \ahaddarg[in]{list}{List informative messages to the logger}{T}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function applies a model of the sky to the image. You can add or
subtract the model which is contained in a
\ahlink{Componentlist}{componentmodels:componentlist} \tool.

The pixel values are only changed where the total mask
(combination of the default \pixelmask\ [if any] and the OTF mask)
is good (True).   If the computation fails for a particular
pixel (e.g. coordinate undefined) that pixel will be
masked bad.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- myim := image('gc.small')
- cl := componentlist('list')
- myim.modify(cl)
\end{verbatim}

In this example we subtract the model contained in the Table called {\sff list}.

\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{maxfit}{Find maximum and do parabolic fit in the sky}
\begin{ahargs}
  \ahaddarg[in]{region}{The 2-D region of interest to fit}{Whole image}{Region tool}
  \ahaddarg[in]{point}{Find only point sources ?}{T}{T or F}
  \ahaddarg[in]{width}{Half-width of fit grid when point=F}{5}{Integer}
  \ahaddarg[in]{negfind}{Find negative sources as well as positive ?}{F}{T or F}
  \ahaddarg[in]{list}{List the fitted parameters to the logger ?}{T}{T or F}
\end{ahargs}
\ahreturns{Componentlist tool or fail}

\begin{ahdescription}

This function finds the pixel with the maximum value in the region, and
then uses function \ahlink{findsources}{images:image.findsources} 
to generate a Componentlist with one component.   The component
will be of type Point ({\stfaf point=T}) or Gaussian ({\stfaf point=F}).

If {\stfaf negfind=F} the maximum pixel value is found in the region and fit.
If {\stfaf negfind=T} the absolute maximum pixel value is found in the region
and fit.

See function \ahlink{findsources}{images:image.findsources} for
a description of arguments {\stfaf point} and {\stfaf width}.

See also the function \ahlink{fitsky}{images:image.fitsky}.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- myim := imagemaketestimage()
- cl := myim.maxfit()
- cl.edit(1)                  # There is only one component
\end{verbatim}

\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{moments}{Compute moments from an image}
\begin{ahargslong}
  \ahaddarg[in]{moments}{List of moments that you would like to compute}{0 (integrated spectrum)}{Vector of integers}
  \ahaddarg[in]{axis}{The moment axis}{The spectral axis if there is one}{Positive integer}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{method}{List of windowing and/or fitting functions you would like to invoke}
           {Don't invoke the window or fit functions, and don't invoke any interactive functions}{Vector of strings from `window', `fit', and `interactive'}
  \ahaddarg[in]{smoothaxes}{List of axes to smooth}{No smoothing}{Vector of integers}
  \ahaddarg[in]{smoothtypes}{List of smoothing kernel types, one for each axis to smooth}
                    {No smoothing}{Vector of strings from `gauss', `boxcar', `hanning'}
  \ahaddarg[in]{smoothwidths}{List of widths (full width for boxcar, full width at half maximum
            for gaussian, 3 for Hanning) in pixels for the smoothing kernels}{No smoothing}{Vector of numeric, quantity or string}
  \ahaddarg[in]{includepix}{Range of pixel values to include}{Include all pixels}{Vector of 1 or 2 Floats}
  \ahaddarg[in]{excludepix}{Range of pixel values to exclude}{Exclude no pixels}{Vector of 1 of 2 Floats}
  \ahaddarg[in]{peaksnr}{The SNR ratio below which the spectrum will be rejected as noise (used by the window and fit functions only)}{3}{A positive float}
  \ahaddarg[in]{stddev}{Standard deviation of the noise signal in the image (used by the window and fit functions only)}{Automatic noise determination}{Positive float}
  \ahaddarg[in]{doppler}{Velocity doppler definition for velocity computations along spectral axes}{RADIO}{String}
  \ahaddarg[in]{outfile}{Output image file name (or root for multiple moments)}{input + an auto-determined suffix}{String}
  \ahaddarg[in]{smoothout}{Output file name for convolved image}{Don't save the convolved image}{String}
  \ahaddarg[in]{plotter}{The PGPLOT device name to make plots on}{No plotting}{Any valid PGPLOT device}
  \ahaddarg[in]{nx}{The number of subplots per page in the x direction}{1}{Any positive integer}
  \ahaddarg[in]{ny}{The number of subplots per page in the y direction}{1}{Any positive integer}
  \ahaddarg[in]{yind}{Scale the y axis of the profile plots independently}{False}{Bool}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{drop}{Drop moments axis from output images ?}{T}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait - but always F if plotting}{Bool}
\end{ahargslong}
\ahreturns{Image tool or fail}

\begin{ahdescription}

\noindent{\bf Summary}

The primary goal of this function is to enable you to analyze a
multi-dimensional image by generating moments of a specified axis.  This
is a time-honoured spectral-line analysis technique used for extracting
information about spectral lines.  There is also a custom GUI interface
available via the \ahlink{momentsgui}{images:image.moments} function
as the command line interface is presently rather cumbersome.

You can generate one or more output moment images.  The return value
of this function is an Image \tool\ holding the {\bf first}
of the output moment images.  

The word `moment' is used loosely here.  It refers to collapsing an axis
(the moment axis) to one pixel and setting the value of that pixel (for
all of the other non-collapsed axes) to something computed from the data
values along the moment axis.  For example, take an RA-DEC-Velocity
cube, collapse the velocity axis by computing the mean intensity at each
RA-DEC pixel.  This function offers many different moments and a variety
of interactive and automatic methods to compute them. 

We try to make a distinction between a `moment' and a `method'.  This
boundary is a little blurred, but it claims to refer to the distinction
between what you are computing, and how the pixels that were included in
that computation were selected.  For example, a `moment' would be the
average value of some pixel values in a spectrum.  A `method' for
selecting those pixels would be a simple pixel value range specifying
which pixels should be included. 

There are many available moments, and you specify each one with an
integer code as it would get rather cumbersome to refer to them via
strings.  In the list below, the value of the $i$th pixel of the
spectrum is $I_i$, the coordinate of this pixel is $v_i$ (of course it
may not be velocity), and there are $n$ pixels in the spectrum.  The
available moments are:

\begin{itemize}
\item{$-1$} -- the mean value of the spectrum 
\begin{displaymath}
{ {1\over n}  {\sum {I_i}}}
\end{displaymath}
\medskip

\item{0} -- the integrated value of the spectrum 
\begin{displaymath}
M_0 = \Delta v \sum I_i
\end{displaymath}

where $\Delta v$ is the width (in world coordinate units) of a pixel
along the moment axis  
\medskip

\item{1} -- the intensity weighted coordinate (this is
traditionally used to get 'velocity fields')

\begin{displaymath}
M_1 = { {\sum {I_i v_i}} \over {M_0}}
\end{displaymath}
\medskip

\item{2} -- the intensity weighted dispersion of the coordinate 
(this is traditionally used to get 'velocity dispersion fields')

\begin{displaymath}
\sqrt{ { {\sum {I_i \left(v_i - M_1\right)^2}} \over {M_0}}}
\end{displaymath}
\medskip

\item{3} -- the median of $I$
\medskip

\item{4} -- the median coordinate.  Here we treat the spectrum as a
probability distribution, generate the cumulative distribution, and then
find the coordinate corresponding to the 50\% value.  This moment is not
very robust, but it is useful for quickly generating a velocity field in
a way that is not sensitive to noise.  However, it will only give
sensible results under certain conditions.  The generation of the
cumulative distribution and the finding of the 50\% level really only
makes sense if the cumulative distribution is monotonic.  This
essentially means only selecting pixels which are positive or negative. 
For this reason, this moment type is only supported with the basic
method (see below -- i.e.  no smoothing, no windowing, no fitting) with
a pixel selection range that is either all positive, or all negative
\medskip

\item{5} -- the standard deviation about the mean of the spectrum 
\begin{displaymath}
\sqrt{ {1\over {\left(n-1\right)}}  \sum{\left(I_i - \bar{I}\right)^2 }}
\end{displaymath}
\medskip

\item{6} -- the root mean square of the spectrum 
\begin{displaymath}
\sqrt{ {1 \over n} \sum{I_i^2}}
\end{displaymath}
\medskip

\item{7} -- the absolute mean deviation of the spectrum 
\begin{displaymath}
{1 \over n} \sum {|(I_i - \bar{I})|}
\end{displaymath}
\medskip

\item{8} -- the maximum value of the spectrum
\medskip
\item{9} -- the coordinate of the maximum value of the spectrum
\medskip
\item{10} -- the minimum value of the spectrum
\medskip
\item{11} -- the coordinate of the minimum value of the spectrum
\medskip
\end{itemize}

\bigskip
\noindent {Smoothing}

The purpose of the smoothing functionality is purely to provide
a mask.  Thus, you can smooth the input image, apply a pixel
include or exclude range, and generate a smoothed mask which is then
applied before the moments are generated.  The smoothed data
are not used to compute the actual moments; that is always done
from the original data.

\bigskip
\noindent{\bf Basic Method}
 
The basic method is to just compute moments directly from the pixel
values.  This can be modified by applying pixel value inclusion or
exclusion ranges (arguments {\stfaf includepix} and {\stfaf excludepix}).  

You can then also convolve the image (arguments {\stfaf smoothaxes}, {\stfaf
smoothtypes}, and {\stfaf smoothwidths}) and find a mask based on the inclusion
or exclusion ranges applied to the convolved image.  This mask is then
applied to the unsmoothed data for moment computation. 

\bigskip
\noindent{\bf Window Method}

The window method (invoked with argument {\stfaf method='window'}) does
no pixel-value-based selection.  Instead a window is found (hopefully
surrounding the spectral line feature) and only the pixels in that
window are used for computation.  This window can be found from the
convolved or unconvolved image (arguments {\stfaf smoothaxes}, {\stfaf
smoothtypes}, and {\stfaf smoothwidths}).

The moments are always computed from the unconvolved data.  The window
can be found (for each spectrum) interactively or automatically.  The
automatic methods are via Bosma's converging mean algorithm ({\stfaf
method='window'}) or by fitting Gaussians and taking $\pm 3\sigma$ as
the window ({\stfaf method='window,fit'}).  The interactive methods 
are a direct specification of the window with the cursor ({\stfaf
method='window,interactive'}) and by interactive fitting of Gaussians
and taking $\pm 3$-sigma as the window ({\stfaf
method='window,fit,interactive'}). 

In Bosma's algorithm, an initial guess for a range of pixels surrounding
a spectral feature is refined by widening until the mean of the pixels
outside of the range converges (to the noise). 


\bigskip
\noindent{\bf Fit Method}

The fit method ({\stfaf method='fit'}) fits Gaussians to spectral
features either automatically or interactively ({\stfaf
method='fit,interactive'}).  The moments are then computed from the
Gaussian fits (not the data themselves). 

The interactive methods are very user intensive.  You have to do
something for each spectrum.  These are really only useful for images
with a manageably small number of spectra. 


\bigskip
\noindent{\bf Other Arguments}

\begin{itemize} 

\item {\stfaf outfile} - If you are creating just one moment image,
and you specify {\stfaf outfile}, then the image is created
on disk with this name.  If you leave {\stfaf outfile} empty
then a temporary image is created.  In both cases, you can
access this image with the returned Image \tool.  If you are
making more than one moment image, then theses images are always
created on disk.  If you specify {\stfaf outfile} then this is
the root for the output file names.  If you don't specify it,
then the input image name is used as the root.

\item {\stfaf smoothing} - If you smooth the image to generate a
mask, you  specify the kernel widths via the {\stfaf smoothwidths}
argument in the same way as in the
\ahlink{sepconvolve}{images:image.sepconvolve} function.  See it for
details.


\item {\stfaf plotter} - The plotting is done directly on a PGPLOT plotting device.  
The syntax is {\stfaf plotter=name/type}.  For example {\stfaf
plotter='plot1.ps/ps'} (disk postscript file) or {\stfaf plotter='plot/glish'}
(\glish\ PGplotter). 

Note also that if you specify a plotting device but do not ask for an
interactive option, then plots will be made showing you the effect of the
algorithm on each spectrum.  For example, you may have selected the
automatic windowing method.  If you have specified a plotting device,
then each spectrum will be plotted and the window marked on each plot. 

\item {\stfaf stddev} - Some of the automatic methods also require an
estimate of the noise level in the image.  This is used to assess
whether a spectrum is purely noise or not, and whether there is any
signal worth digging out.  If you don't give it via the {\stfaf stddev}
argument, it will be worked out automatically from a Gaussian fit to the
bins above 25\% from a histogram of the entire image.  If you have
specified the plotting device as well, you get the chance to interact
with this fitting process. 

\item {\stfaf includepix, excludepix} - The vectors given by arguments
{\stfaf includepix} and {\stfaf excludepix} specify a range of pixel
values for which pixels are either included or excluded.  They are
mutually exclusive; you can specify one or the other, but not both.  If
you only give one value for either of these, say {\stfaf includepix=b},
then this is interpreted as {\stfaf includepix=[-abs(b),abs(b)]}. 

The convolving point-spread function is normalized to have a volume of
unity.  This means that point sources are depressed in value, but
extended sources that are large with respect to the PSF remain
essentially on the same intensity scale; these are the structures you
are trying to find with the convolution so this is what you want. 
If you convolve the image, then arguments like {\stfaf includepix} select
based upon the convolved image pixel values.  If you are having trouble
getting these right, you can output the convolved image ({\stfaf smoothout})
and assess the validity of your pixel ranges.  Note also that if you are
Hanning convolving (usually used on a velocity axis), then the width for
this kernel must be 3 pixels (triangular smoothing kernels of other
widths have no valid theoretical basis). 

\item {\stfaf doppler} - If you compute the moments along a spectral
axis, it is conventional to compute the world coordinate (needed for
moments 0, 1 and 2) along that axis in "km/s".   The argument {\stfaf
doppler} lets you specify what doppler convention the velocity will be
calculated in. You can choose from {\stfaf doppler=radio, optical,
true}.   See function \ahlink{summary}{images:image.summary} for the
definitions of these codes.  For other moment-axis types, the world coordinate
is computed in the native units.

\item {\stfaf mask} - The total input mask is the combination  of the
default \pixelmask\ (if any) and the OTF mask.  Once this mask
has been established, then the moment method may make additional
pixel selections.   

\item {\stfaf drop} - If this is true (the default) then the moment axis
is dropped from the output image.  Otherwise, the output images have  a
moment axis of unit length and coordinate information that is the same
as for the input image.  This coordinate information may be totally
meaningless for the moment images.


\end{itemize}

Finally, if you ask for a moment which requires the coordinate to be
computed for each profile pixel (these are the intensity weighted mean
coordinate [moment 1] and the intensity weighted dispersion of the
coordinate [moment 2]), and the profile axis is not separable then there
will be a performance loss.  Examples of non-separable axes are RA and
Dec.  If the axis is separable (e.g.  a spectral axis) there is no
penalty.  In the latter case, the vector of coordinates for one profile
is the same as the vector for another profile, and it can be precomputed
(once). 

Note that this function has no ``virtual'' output file capability. All
output files are written to disk.   The output mask for these images is
good (T) unless the moment method fails to generate a value (e.g.  the
total input pixel mask was all bad for the profile) in which case it will be bad (F).


\begin{ahexample} 
\begin{verbatim} 
- im2 := im.moments(moments=[-1,1,2],axis=3,smoothaxes=[1,2,3],
                    smoothtypes="gauss gauss hann",smoothwidths=[5.0,5.0,3], 
                    excludepix=[1e-3], smoothout='smooth')
\end{verbatim} 

In this example, standard moments (average intensity, weighted velocity
and weighted velocity dispersion) are computed via the convolve (spatially
convolved by gaussians and spectrally by a Hanning kernel) and clip
method (we exclude any pixels with absolute value less than $0.001$).
The output file names are automatically created for us and
the convolved image is saved.   The returned image tool holds the first
moment image.

\end{ahexample}

\begin{ahexample} 
\begin{verbatim} 
- im2 := im.moments(moments=[3],method='window',plotter='/glish',
                    nx=5,ny=5)
\end{verbatim} 

In this example, the median of each spectrum is computed, after pixel
selection by the automatic window method.  Each spectrum and the window
are plotted (25 plots per page) on a PGPLOT X-window device.  Because the
plotting device is given and we did not give the noise level of the
image, a histogram of the image is made and fit and we get to
interactively do the Gaussian fit to the histogram.  The output 
image is temporary and accessed via the returned Image tool.

\end{ahexample}
\end{ahfunction} 




\begin{ahfunction}{momentsgui}{Compute moments from image via custom GUI interface}
\begin{ahargs}
  \ahaddarg[in]{parent}{Parent frame to embed GUI in}{Create stand alone}{\glish\/Tk agent}
  \ahaddarg[in]{widgetset}{The widgetset to use for the GUI}{dws}{A widgetserver tool}
\end{ahargs}
\ahreturns{Agent or fail}

\begin{ahdescription}

\medskip

{\bf General}

The \ahlink{moments}{images:image.moments} function takes rather a lot
of inputs, and the need for some of them is context dependent.  This
makes the command-line interface rather cumbersome to use.  Therefore,
this function provides a GUI interface to the {\stff moments} function. 
This interface constrains your actions by disabling appropriate parts of
the GUI depending upon what you choose to do.  When you invoke this
function, it will need to find the minimum and maximum values in your
image, so function \ahlink{statistics}{images:image.statistics} is
automatically run (this may cause you to see a progress meter). 

Here is an example of the GUI.

\begin{figure}[h]
\begin{center}
\epsfig{file=imagemomentsgui.ps, width=4.5in}
\caption{The moments GUI}
\label{fig:momentsgui}
\end{center}
\end{figure}


The GUI is arranged into several `rollups'.  The first one, `basic
settings', contains the basic parameters you need to set.  Other rollups
are `convolution', `data selection' and `plotting'.  See
\ahlink{moments}{images:image.moments} for descriptions of the
parameters contained in these. 

If you don't provide a parent frame (the {\stfaf parent} argument),
the GUI is made in a standalone mode.  This means it creates
go, reset and dismiss buttons.  If you provide the parent frame,
you must also provide the buttons and act on them.

The primary mechanism for the context dependent disabling and enabling
is the choice of method found in the `basic settings' rollup.  This
presents all of the possible method choices via a multi-level menu
(this is different from the \ahlink{moments}{images:image.moments}
function where you give a string containing up to three substrings, the
combination of which dictates the method).  Although this menu has
several levels, it makes it unamibiguous as to what you are doing. 

The methods are

\begin{itemize}

\item Basic method.  This means the pixels are simply selected via a
pixel inclusion or exclusion (or all) range.  Optionally, you may apply
the pixel range to the smoothed image.  This produces a mask which is
applied to the unsmoothed data. 

\item Window methods.  The window method selects pixels in a 
coordinate range which surrounds the spectral feature of interest.
The window can be found from the smoothed or unsmoothed data,
but the moments are always computed from the unsmoothed data.

\begin{itemize}

\item Automatic methods.  The automatic methods do not allow
you to interact with the process.

\begin{itemize}
\item Window, automatic, converging mean method.    This is
Albert Bosma's algorithm.  An initial guess for a range
of pixels surrounding a spectral feature is refined
by widening until the mean of the pixels outside of the
range converges (to the noise).

\item Window, automatic, fit gaussian method.  
The window is found by fitting a Gaussian to the spectral
feature and by taking a coordinate range of $\pm 3 \sigma$
around the centre of the line.

\end{itemize}


\item Interactive methods.  The interactive methods allow
you to interact with the process.  They are very user intensive !

\begin{itemize}
\item Window, interactive, direct method.

You just specify the window directly with the cursor. 

\item Window, interactive, fit gaussian method.

Same as the automatic method except that you do the fit
interactively.

\end{itemize}

\end{itemize}


\item Fit methods.  The fit methods fit a model to the spectrum.
The moments are worked out from the fit, not the actual data.

\begin{itemize}
\item Fit gaussian, automatic method.  The fits are
done without user interaction.

\item Fit gaussian, interactive method.  The user interacts
with the fitting process.

\end{itemize} 

\end{itemize} 

You will also find context dependent disabling and enabling when you
select some of the convolution parameters; this interacts with
parameters in ``data selection''.  In particular, the idea of the
convolution is to make a mask by selecting pixels from the convolved
data.  Therefore you must make a pixel inclusion or exclusion selection. 
Also, the median coordinate moment is only available with
the basic method, so it is disabled for other methods.

The combination of a context dependent GUI and as much error checking as
possible in the GUI, means you should not often have the underlying C++
application complain to you that you have not set some parameter. 


\medskip
{\bf Recovering the GUI}

When you run this function, it returns an agent which is actually a
reference to the underlying GUI.  In addition, the GUI is left on the
screen.  You can explicitly dismiss it by pressing the Dismiss button or
selecting Dismiss from the File menu.  To recover the GUI you can do one
of two things. 

\begin{enumerate}

\item Run the command {\stfaf momentsgui} again.  This will 
return another reference of the GUI to you.  However,
it will reset some parts of the GUI because it is possible
that the image changed since you last ran this function
(the pixel values might have changed, it might even be a different
\imagefile\ attached to this \tool).

Thus

\begin{verbatim}
- im := image('myimage')
- g := im.momentsgui()             # Click Dismiss on GUI
- g := im.momentsgui()             # Get GUI back with some reset
\end{verbatim}


\item Apply the {\stfaf gui} function to the reference
returned when you ran the {\stfaf momentsgui} function.
This simply recovers the GUI with no resetting.  If the
image {\bf has} changed, this will not reflect it.

\begin{verbatim}
- im := image('myimage')
- g := im.momentsgui()             # Click Dismiss on GUI
- g.gui()                          # Get GUI back with no change
\end{verbatim}


\end{enumerate}


If you destroy the GUI (by selecting Done from  the File
menu) then you must run the {\stfaf momentsgui} function
again to regenerate it.


\end{ahdescription}

\end{ahfunction}



\begin{ahfunction}{name}{Name of the image file this tool is attached to}
\begin{ahargs}
  \ahaddarg[in]{strippath}{Strip off the path before the actual file name ?}{False}{Bool}
\end{ahargs}
\ahreturns{String or fail}

\begin{ahdescription}

This function returns the name of the \imagefile\ By default, this
function returns the full absolute path of the \imagefile.  You can
strip this path off if you wish with the {\stfaf strippath} argument and
just recover the \imagefile\ name itself. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('g1.app')
- im.name(strippath=F)
/DATA/ELARA_1/aips++/data/g1.app
- im.name(strippath=T)
g1.app
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{open}{Open a new image file with this image tool}

\begin{ahargs}
  \ahaddarg[in]{infile}{image file name}{}{String}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

Use this function when you are finished analyzing the current
\imagefile\ and want to attach to another one.  This function detaches the
\imagetool\ from the current \imagefile, and reattaches it (opens) to
the new \imagefile. 

The input image file may be in native \aipspp, \fits, or Miriad  
format.  Look \htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
information on foreign images.

You could, of course, also create a new \imagetool\ and associate that
with the new \imagefile, but this saves you the \tool\ creation. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im:=image('myimage')              # create tool im and open image myimage
- im.open('anotherimage')           # attach tool im to image anotherimage
\end{verbatim}
The {\stff open} function first closes the old \imagefile.
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{pixelvalue}{Get value of image and mask at specified pixel coordinate}
\begin{ahargs}
  \ahaddarg[in]{pixel}{Pixel coordinate}{Reference pixel}{Vector of integer}
\end{ahargs}
\ahreturns{Glish record, unset, or fail}
\begin{ahdescription}

This function gets the value of the image and the mask at the specified
pixel coordinate.  The values are returned in a \glish\ record with fields
'value', 'mask' and 'pixel'.  The value is returned as a quantity, the mask
as a Bool (T is good).  The 'pixel' field holds the actual
pixel coordinate used.

If the specified pixel coordinate is off the image, unset is returned.

Excessive elements in {\stfaf pixel} are silently discarded.
Missing elements are given the (nearest integer) value of the reference pixel.
This is reflected in the output record 'pixel' field.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage();
- im.pixelvalue()
[mask=T, value=[value=2.50643158, unit=Jy/beam], pixel=[56 38] ] 
-
- im.pixelvalue([0,0])
[i_am_unset=i_am_unset] 
-
- im.pixelvalue([10])
[mask=T, value=[value=0.140122071, unit=Jy/beam], pixel=[10 38] ] 
-
- im.pixelvalue([10,10,10])
[mask=T, value=[value=-0.452527285, unit=Jy/beam], pixel=[10 10] ] 

\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{putchunk}{Put pixels from a Glish array into a regular region of the image}
\begin{ahargs}
  \ahaddarg[in]{pixels}{Glish numeric array}{}{}
  \ahaddarg[in]{blc}{Bottom-Left-Corner (start) of location in image}{Start of image}{Vector of integers}
  \ahaddarg[in]{inc}{increment (stride) along axes}{1}{Vector of integers}
  \ahaddarg[in]{list}{List bounding box to logger ?}{F}{T or F}
  \ahaddarg[in]{locking}{Unlock image after use ?}{T}{T or F}
  \ahaddarg[in]{replicate}{Replicate array through image}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function puts a \glish\ array into the \imagefile.  If there is a
default \pixelmask\ it is ignored in this process.  It is the complement of the
\ahlink{getchunk}{images:image.getchunk} function.  You can specify the {\stfaf
blc} and {\stfaf inc} if desired.  If they are unspecified, they default
to the beginning of the image and an increment of one. 

Any illegal {\stfaf blc} values are set to unity.  Any illegal {\stfaf
inc} values are set to unity. 

A fail will result if you attempt to put an array beyond the extent of
the image (i.e., it is not truncated or decimated). 

If there are fewer axes in the array than in the image, the array is
assumed to have trailing axes of length unity.  Thus, if you have a 2D
array and want to put it in as the YZ plane rather than the XY plane,
you must ensure that the shape of the array is [1,nx,ny].  

However, the argument {\stfaf replicate} can be used to replicate the array
throughout the image (from the blc to the trc).  For example, if you
provide a 2D array to a 3D image, you can replicate it through the third
axis by setting {\stfaf replicate=T}.   The replication is done
from the specified {\stfaf blc} to the end of the image.
Use function \ahlink{putregion}{images:image.putregion}  if you
want to terminate the replication at a {\stfaf trc} value.

The argument {\stfaf locking} controls two things.  If True, then after
the function is called, the image is unlocked (so some other process can
acquire a lock) and it is indicated that the image has changed (causes
function \ahlink{view}{images:image.view} to redisplay the image if it
is has been called).  The reason for having this argument is that the
unlocking and updating processes are quite expensive.  If you are
repeatedly calling {\stff putchunk} in a for loop, you would be advised
to use this switch.

A related function is \ahlink{putregion}{images:image.putregion} 
which puts the pixels and masks into a more complex \region.
Function {\stff putchunk} is retained because it is faster and therefore
preferable for repeated operation in loops if the \pixelmask\ is not required.

See also the functions \ahlink{set}{images:image.set} and 
\ahlink{calc}{images:image.calc} which can also change pixel values.

\end{ahdescription}

\begin{ahexample}

We can clip all pixels to be {\tt <= } 5 as follows.
\begin{verbatim}
- pix := im.getchunk()               # get all pixels into a Glish array
- pix[pix > 5] := 5                  # clip values to 5
- im.putchunk(pix)                   # put array back into image
\end{verbatim}

The above example shows how you could clip an image to a value.  If all
the pixels didn't easily fit in memory, you would iterate through the
image chunk by chunk to avoid exhausting virtual memory.  Better would be to do
this via LEL through function \ahlink{calc}{images:image.calc}.

Suppose we wanted to set the fifth XY plane to 0.

We could do so as follows:
\begin{verbatim}
- im := image('myimage')
- imshape := im.shape()
- pix := array(0, imshape[1], imshape[2])
- im.putchunk(pix, blc=[1,1,5])
\end{verbatim}

Suppose we wanted to set the first YZ plane to 0.

\begin{verbatim}
- pix := array(0, 1, imshape[2], imshape[3])
- im.putchunk(pix)
\end{verbatim}

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{putregion}{Put pixels and mask into a  region-of-interest of the image}
\begin{ahargs}
  \ahaddarg[in]{pixels}{The pixel values}{None}{Glish numeric array}
  \ahaddarg[in]{pixelmask}{The pixel mask values}{None}{Glish Boolean array}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{list}{List the bounding box and any mask creation to the logger}{F}{T or F}
  \ahaddarg[in]{usemask}{Honour the mask when putting pixels}{T}{T or F}
  \ahaddarg[in]{locking}{Unlock image after use ?}{T}{T or F}
  \ahaddarg[in]{replicate}{Replicate array through image}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function replaces data and/or \pixelmask\ values in the image in
the specified \region.  The {\stfaf pixels} and/or {\stfaf pixelmask}
arrays must be the shape of the bounding box, and the whole bounding box
is replaced in the image.  The \region\ is really only used to specify
the bounding box.  If the region extends beyond the image, it is
truncated.  If the {\stfaf pixels} or {\stfaf pixelmask} array shapes do not
match the bounding box, an error will result. 

When you put a \pixelmask, it either replaces the current default \pixelmask, or
is created.  The \pixelmask\ is put before the pixels.

The argument {\stfaf usemask} is only relevant when you are putting
pixel values and there is a \pixelmask\ (meaning also the one you might have
just put in place).  If {\stfaf usemask=T} then only pixels for which
the mask is good (T) are altered.  If {\stfaf usemask=F} then all the
pixels in the region are altered - the mask is ignored. 

The argument {\stfaf replicate} can be used to replicate the array
throughout the image (from the blc to the trc).  For example, if you
provide a 2D array to a 3D image, you can replicate it through the third
axis by setting {\stfaf replicate=T}.   The replication
is done in the specified {\stfaf region}.

The argument {\stfaf locking} controls two things.  If True, then after
the function is called, the image is unlocked (so some other process can
acquire a lock) and it is indicated that the image has changed (causes
function \ahlink{view}{images:image.view} to redisplay the image if it
is has been called).  The reason for having this argument is that the
unlocking and updating processes are quite expensive.  If you are
repeatedly calling {\stff putchunk} in a for loop, you would be advised
to use this switch.

See the related functions \ahlink{putchunk}{images:image.putchunk},
\ahlink{set}{images:image.set} and \ahlink{calc}{images:image.calc}.

\end{ahdescription}

\begin{ahexample}

Suppose that we have a 2-dimensional image.  First we recover the pixel
and \pixelmask\ values from a polygonal region.  Then we change the values in
the array that are within the region to zero and replace the data. 

\begin{verbatim}
- im := image('myimage')                      # Create image tool
- x := dq.quantity([3,6,9,6,5,5,3],'pix')       # X vector, in absolute pixels
- y := dq.quantity([3,4,7,9,7,5,5],'pix')       # Y vector, in absolute pixels
- r1 := drm.wpoly(x,y,csys=im.coordsys())     # Create polygonal world region
- local pixels, pixelmask
- im.getregion(pixels, pixelmask, r1, F)      # Recover pixels and mask
- pixels[pixelmask] := 0                      # Set pixels where mask is T to zero
- im.putregion(pixels=pixels, region=r1)      # Replace pixels only
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{rebin}{rebin the image by the specified factors}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{bin}{Binning factors for each axis}{}{Vector of integers}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{dropdeg}{Drop degenerate axes}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function rebins the current image by the specified integer binning
factors for each axis.  The output pixel value is just the average of the
input pixel values. The output pixel will be masked bad if there
were no good input pixels.  You cannot rebin a Stokes axis.

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated with
a temporary image.  This temporary image may be in memory or on disk,
depending on its size.  When you destroy the Image \tool\ (with the
\ahlink{done}{images:image.done} function) this temporary image is
deleted. 

Sometimes it is useful to drop axes of length one (degenerate axes). 
Use the {\stfaf dropdeg} argument if you want to do this.  It will
discard the axes from the input image.  Therefore the output shape and
Coordinate System that you supply must be consistent with the input
image after the degenerate axes are dropped. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage();
- im2 := im.rebin(bin=[2,3]);
\end{verbatim}
\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{regrid}{regrid this image to the specified Coordinate System}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{shape}{Shape of output image}{Input shape}{Vector of integers}
  \ahaddarg[in]{csys}{Coordinate System for output image}{Input CoordinateSystem}{Coordsys tool}
  \ahaddarg[in]{axes}{The output pixel axes to regrid}{All}{Vecor of integers}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{method}{The interpolation method}{'linear'}{String from 'nearest', 'linear', 'cubic'}
  \ahaddarg[in]{decimate}{Decimation factor for coordinate grid computation}{10}{Integer}
  \ahaddarg[in]{replicate}{Replicate image rather than regrid ?}{F}{T or F}
  \ahaddarg[in]{doref}{Turn on reference frame changes}{T}{T or F}
  \ahaddarg[in]{dropdeg}{Drop degenerate axes}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{force}{Force specified axes to be regridded}{F}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
%%  \ahaddarg[in]{dbg}{Debugging level}{0}{0, 1 or 2}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function regrids the current image onto a grid specified by the
given Coordinate System.   You can also specify the shape of the
output image.

The Coordinate System must be given via a
\ahlink{Coordsys}{images:coordsys} \tool.  It is optional; if not
specified, the Coordinate System from the input image (i.e.  the one to
which you are applying the regrid function) is taken.  The order of the
coordinates and axes in the output image is always the same as the input
image.  It simply 'finds' the relevant coordinate in the supplied
Coordinate System in order to figure out the regridding parameters.  The
supplied Coordinate System must have at least as many coordinates as are
required to accomodate the axes you are regridding (e.g.  if you regrid
the first two axes, and these belong to a Direction Coordinate, you need
one Direction Coordinate in the supplied Coordinate System). 
Coordinates pertaining to axes that are not being regridded are supplied
from the input image, not the give Coordinate System. 

Reference changes are handled (e.g.  J2000 to B1950, LSR to TOPO).  In
general, the conversion machinery attempts to work out how sophisticated
it needs to be (e.g.  am I regridding LSR to LSR or LSR to TOPO). 
However, it errs on the side of conservatism so that it can be that the
conversion machine requires more information than it actually needs. 
For full frame conversions, one needs to know things like location on
earth (e.g.  observatory), direction of observation, and time of
observation.  

If you get the above errors and you {\bf are} doing a frame conversion,
then that means you must insert some extra information into the
Coordinate System of your image.  Most likely it's the time
(\ahlink{coordsys.setepoch}{images:coordsys.setepoch}) and location
(\ahlink{coordsys.settelescope}{images:coordsys.settelescope}) that are
missing. If you get these errors and you {\bf know} that you are not
specifying a frame change (e.g.  regrid LSR to LSR) then try setting
{\stfaf doref=F}.  This will (silently) bypass all possible frame
conversions.  Note that if you {\bf are} requesting a frame conversion
and you set {\stfaf doref=F} you are doing a bad thing (and you will
get no warnings).

If you regrid a plane holding a Direction Coordinate and the units are
Jy/pixel then the output is scaled to conserve flux (roughly; just one
scale factor at the reference pixel is computed). 

A variety of interpolation schemes are provided (you need only specify
the first three characters to {\stfaf method}).  The cubic interpolation
is substantially slower than linear, and often the improvement is
modest.  By default you get linear interpolation. 

You specify the shape of the output image ({\stfaf shape}) and which
output axes you want to regrid ({\stfaf axes}).  Note that a Stokes axis
cannot be regridded (you will get a warning if you try and do this). 

The {\stfaf axes} argument cannot be used to discard axes from the
output image; it can only be used to specify which {\bf output} axes are
going to be regridded and which are not.  Any axis that you are not
regridding must have the same output shape as the input image shape for
that axis. 

The {\stfaf axes} argument can also be used to specify the order in
which the {\bf output} axes are regridded.  This may give you
significant performance benefits.  For example, imagine we are going to
regrid a spectral-line cube of shape [512,512,1204] to shape
[256,256,32].  If you specified {\stfaf axes=[1,2,3]} then first, the
Direction axes would be regridded for each of the 1024 pixels (and
stored in a temporary image).  Then each profile at each spatial
location in the temporary image would be regridded to 32 pixels.  You
could speed this process up significantly by setting {\stfaf
axes=[3,1,2]}.  In this case, first each profile would be regridded to
32 pixels, and then each plane of the 32 pixels would be regridded. 
Note that the order of {\stfaf axes} does not affect the order of the
{\stfaf shape} argument.  I.e.  it should be given in the natural pixel
axis order of the image {\stfaf [256,256,32]} in both cases. 

You can also specify a \region\ to be applied to the input image.  If
you do this, you need to be careful with the output shape for
non-regridded axes (must match that of the region - use function
\ahlink{boundingbox}{images:image.boundingbox} to find that out). 

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated with
a temporary image.  This temporary image may be in memory or on disk,
depending on its size.  When you destroy the Image \tool\ (with the
\ahlink{done}{images:image.done} function) this temporary image is
deleted. 

The argument {\stfaf replicate} can be used to simply replicate pixels
rather than regridding them.  Normally ({\stfaf replicate=F}), for every
output pixel, its world coordinate is computed and the corresponding
input pixel found (then a little interpolation grid is generated).  If
you set {\stfaf replicate=T}, then what happens is that for every output
axis, a vector of regularly sampled input pixels is generated (based on
the ratio of the output and input axis shapes).  So this just means the
pixels get replicated (by whatever interpolation scheme you use) rather
than regridded in world coordinate space.  This process is much faster,
but its not a true world coordinate based regrid. 

As decribed above, when {\stfaf replicate} is False, a coordinate is
computed for each output pixel; this is an expensive operation.  The
argument {\stfaf decimate} allows you to decimate the computation of
that coordinate grid to a sparse grid, which is then filled in via fast
interpolation.  The default for {\stfaf decimate} is 10.  The number of
pixels per axis in the sparse grid is the number of output pixels for
that axis divided by the decimation factor.  A factor of 10 does pretty
well.  You may find that for very non-linear coordinate systems (e.g. 
very close to the pole) that you have to reduce the decimation factor. 

Sometimes it is useful to drop axes of length one (degenerate axes). 
Use the {\stfaf dropdeg} argument if you want to do this.  It will
discard the axes from the input image.  Therefore the output shape and
Coordinate System that you supply must be consistent with the input
image after the degenerate axes are dropped. 

Argument {\stfaf force} can be used to force all specified axes to be
regridded, even if the algorithm determines that they don't need to be (because
the input and output coordinate information is identical).

There is a useful function
\ahlink{setreferencelocation}{images:coordsys.setreferencelocation} that
you can use to keep a specific world coordinate in the center of an
image when regridding (see example below). 

The output \pixelmask\ will be good (T) unless the regridding failed to
find a value for that output pixel in which case it will be bad (F).
For example, if the total input mask (default input \pixelmask\ plus OTF
mask) for all of the relevant input pixels were masked bad 
then the output pixel would be masked bad (F).

{\bf Multiple axis Coordinates limitation} -- Some cooordinates pertain
to more than one axis.  E.g.  a Direction Coordinate holds longitude and
latitude.  A Linear Coordinate can also hold many axes.  When you regrid
*any* axis from a Coordinate which holds multiple axes, you must fully
specify the coordinate information for all axes in that Coordinate in
the Coordinate System that you provide.  For example, you have a Linear
Coordinate with two axes and you want to regrid axis one only.  In the
Coordinate System you provide, the coordinate information for axis two
(not being regridded) must correctly be a copy from the input coordinate
system (it won't be filled in for you). 


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- imr := image('radio.image')  
- imo := image('optical.image')
- cs := imo.coordsys();
- imrr := imr.regrid(outfile='radio.regridded', csys=cs,
                    shape=imo.shape())
- imrr.view()
- cs.done()
- imr.done()
- imo.done()
\end{verbatim}

In this example, we regrid a radio image onto the grid of an optical
image - this probably (if the optical FITS image was correctly labelled
!!) will involve a projection change (optical images are usually TAN
projection, radio usually SIN).  
\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- im := image('radio.image')  
- cs := im.coordsys();
- cs.referencecode('dir')
J2000
- cs.setreferencecode(value='B1950', type='dir', adjust=T)
- im3 := im1.regrid(outfile='radio.regridded', csys=cs,
+                   shape=im2.shape())
\end{verbatim}

In this example, we regrid a radio image from J2000 to B1950. This is
accomplished by first recovering the Coordinate System into a
\ahlink{Coordsys}{images:coordsys} tool, manipulating the reference code
with that \tool, and then supplying the new Coordinate System to the
regrid function.
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage('zz')  
- cs := im.coordsys();
-
- p := im.shape() / 2.0
- p +:= 10;
- refval := im.toworld(pixel=p, format='n')          # Location of interest
- inc := cs.increment(quant=F)
- inc /:= 2.0;                                # Halve increment
- cs.setincrement(value=inc)                  # Set increment
- shp := im.shape() * 2;                      # Double shape
- refpix := ((shp-1))/2.0 + 1;                # New ref pix
- cs.setreferencelocation(pixel=refpix, world=refval)    # Center image on location of interest
-
- imr := im.regrid(csys=cs, shape=shp)        # Regrid
- cs.done()
- imagedones()
\end{verbatim}
\end{ahexample}

\end{ahfunction}

\begin{ahfunction}{rotate}{rotate the direction coordinate axes attached to the image and regrid the image to the rotated Coordinate System}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{shape}{Shape of output image}{Input shape}{Vector of integers}
  \ahaddarg[in]{pa}{Angle by which to rotate}{0deg}{Quantity, string, numeric}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{method}{The interpolation method}{'cubic'}{String from 'nearest', 'linear', 'cubic'}
  \ahaddarg[in]{decimate}{Decimation factor for coordinate grid computation}{0}{Integer}
  \ahaddarg[in]{replicate}{Replicate image rather than regrid ?}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
%%  \ahaddarg[in]{dbg}{Debugging level}{0}{0, 1 or 2}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function rotates two axes of an image.  These axes are either
those associated with a Direction coordinate or with a Linear 
coordinate. The Direction coordinate takes precedence.
If rotating a Linear coordinate, it must hold precisely two axes.

The method is that the Coordinate is rotated and then the input
image is regridded to the rotated Coordinate System.

If the image brightness units are Jy/pixel then the output is scaled to
conserve flux (roughly; just one scale factor at the reference pixel is
computed).

A variety of interpolation schemes are provided (you need only specify
the first three characters to {\stfaf method}).  The cubic
interpolation is substantially slower than linear.  By default you get
cubic interpolation.

You can specify the shape of the output image ({\stfaf shape}).
However, all axis that are not regrided retain the same output shape
as the input image shape for that axis.  Only the direction coordinate
axes are regridded.

You can also specify a \region\ to be applied to the input image.  If
you do this, you need to be careful with the output shape for
non-regridded axes (must match that of the region - use function
\ahlink{boundingbox}{images:image.boundingbox} to find that out).

If {\stfaf outfile} is given, the image is written to the specified
disk file.  If {\stfaf outfile} is unset, the Image \tool\ is
associated with a temporary image.  This temporary image may be in
memory or on disk, depending on its size.  When you destroy the Image
\tool\ (with the \ahlink{done}{images:image.done} function) this
temporary image is deleted.

The argument {\stfaf replicate} can be used to simply replicate pixels
rather than regridding them.  Normally ({\stfaf replicate=F}), for every
output pixel, its world coordinate is computed and the corresponding
input pixel found (then a little interpolation grid is generated).  If
you set {\stfaf replicate=T}, then what happens is that for every output
axis, a vector of regularly sampled input pixels is generated (based on
the ratio of the output and input axis shapes).  So this just means the
pixels get replicated (by whatever interpolation scheme you use) rather
than regridded in world coordinate space.  This process is much faster,
but its not a true world coordinate based regrid. 

As decribed above, when {\stfaf replicate} is False, a coordinate is
computed for each output pixel; this is an expensive operation.  The
argument {\stfaf decimate} allows you to decimate the computation of
that coordinate grid to a sparse grid, which is then filled in via
fast interpolation.  The default for {\stfaf decimate} is 0 (no
decimation).  The number of pixels per axis in the sparse grid is the
number of output pixels for that axis divided by the decimation
factor.  A factor of 10 does pretty well.  You may find that for very
non-linear coordinate systems (e.g.  very close to the pole) that you
have to reduce the decimation factor.

The output \pixelmask\ will be good (T) unless the regridding failed to
find a value for that output pixel in which case it will be bad (F).
For example, if the total input mask (default input \pixelmask\ plus OTF
mask) for all of the relevant input pixels were masked bad 
then the output pixel would be masked bad (F).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage();
- im.view(axislabels=T);
- imr:=im.rotate(pa=45);
- imr.view(axislabels=T);
\end{verbatim}

In this example, we rotate the direction coordinate axes (RA/Dec) of a
test image by 45 degress and regrid the image onto the axes.  The viewer
displays the before and after images.
\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{rename}{Rename the image file associated with this image tool}
\begin{ahargs}
  \ahaddarg[in]{name}{The new image file name}{}{String}
  \ahaddarg[in]{overwrite}{Overwrite target file if it already exists}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function renames the \imagefile\ associated with the \imagetool. 
If a file with name {\stfaf name} already exists, you can overwrite it
with the argument {\stfaf overwrite}; otherwise a fail will
result. 

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := image('myimage')  
- im.name(strippath=T)
myimage
- im.rename('newimage', overwrite=T)
- im.name(strippath=T)
newimage
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{replacemaskedpixels}{replace the values of pixels which are masked bad}
\begin{ahargs}
  \ahaddarg[in]{pixels}{The new value(s)}{}{Numeric scalar or LEL expression}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{update}{Update mask as well ?}{F}{T or F}
  \ahaddarg[in]{list}{List the bounding box to the logger}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function (short-hand name {\stff rmp}) replaces the values of all
pixels whose total input mask (default input \pixelmask\ and OTF mask)
is bad (F) with the specified value.    

If the argument {\stfaf update} is F (the default), the actual \pixelmask\
is left unchanged.  That is, masked pixels remain masked.   However, if
you set {\stfaf update=T} then the \pixelmask\ will be updated so that the
\pixelmask\ will now be T (good) where the {\bf total} input mask was F
(bad).

See \ahlink{maskhandler}{images:image.maskhandler} for information
on how to set the default \pixelmask.

There are a few ways in which you can specify what to replace the
masked pixel values by.

\begin{itemize}

\item First, you can give the {\stfaf pixels} argument a simple numeric
scalar (e.g.  {\cf pixels=1.0}).  Then, all masked values will be
replaced by that value. 

\item Second, you can give a scalar
\htmladdnormallink{LEL}{../../notes/223/223.html} expression string
(e.g.  {\cf pixels='min(myimage)'}).  Then, all masked values will be
replaced by the scalar that results from the expression.  If the scalar expression
is illegal (e.g.  in the expression {\cf pixels='min(myimage)'} there
were no good pixels in {\sff myimage}) then the value 0 is used for
replacement. 

\item Third, you can give a
\htmladdnormallink{LEL}{../../notes/223/223.html} expression string
which has the same shape as the \imagefile\ you are applying the
function to.  For example, putting {\cf pixels='myotherimage'} means
replace all masked pixels in this \imagefile\ with the equivalent pixel
in the \imagefile\ called {\sff myotherimage}. 

Your expression might be quite complex, and you can think of it as
producing another masked lattice.  However, in the replace process, the
mask of that expression lattice is ignored.  Thus, only the mask of
the \imagefile\ you are replacing and the pixel values of the expression
lattice are relevant. 

The expression must conform with the subimage formed by applying the
\region\ to the image (i.e.  that associated with this Image \tool).  If
you use the {\stfaf mask} argument as well, the \region\ is applied to
it as well (see examples). 

\end{itemize}
\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('zz1')  
- im.replacemaskedpixels(0.0)
- im.replacemaskedpixels('min(zz2)')
\end{verbatim}
These examples replace all masked pixels by the
specified scalar.  In the second case, the scalar
comes from a LEL expression operating on some
other image {\sff zz2}.
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- im := image('zz1')  
- im.replacemaskedpixels(0.0, mask='zz2>0')
\end{verbatim}

Let us say that {\sff zz1} has no mask.  By using the {\stfaf mask}
argument, we generate a transient mask which is T (good) when the pixel
values are positive.  This means that all non-positive values (when that
mask is F [bad]) will be replaced with the value 0.  If {\sff zz1} did
have a mask it would be applied as well as the transient mask (the masks
would be logically ORed). 

\end{ahexample}



\begin{ahexample}
\begin{verbatim}
- im := image('zz1')  
- im2 := image('zz2')
- r := drm.quarter()
- im.replacemaskedpixels(0.0, region=r, mask='$im2>0')
\end{verbatim}

The specified region takes one quarter of the image by area centered on
the image center.  The region is applied to the {\stfaf mask} expression
as well - this means that any images in the {\stfaf mask} expression
must conform with the {\sff zz1} image.   The replacement of the
scalar is then done only within that region.  Note that in
the {\stfaf mask} expression we have specified the image with
the Image tool {\stf im2} via the \$ syntax (rather than referring
to its disk file name {\sff zz2}).


\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- im := image('zz1')  
- im.replacemaskedpixels('zz2+zz3')
\end{verbatim}

In this example, the replacement values are taken
from a LEL expression adding two other images
together.  The expression must conform with the
image {\sff zz1}.

\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- im := image('zz1')  
- r := drm.quarter()
- im.replacemaskedpixels('zz2[$r]+zz3[$r]', region=r)
\end{verbatim}

In this example, the replacement values are taken
from a LEL expression adding two other images
together.  Because expression must conform with the
image {\sff zz1} after application of the region,
we must specify the region in the expression as well.

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{restoringbeam}{Get the restoringbeam}
\ahreturns{Glish record or fail}
\begin{ahdescription}

This function (short-hand name {\stff rb}) gets the restoring beam, if any.
It is returned in a \glish\ record with fields 'major', 'minor' and
'postionangle'.   Each of these fields contains a quantity. If there
is no restoring beam, this function returds an empty record.

You can set the restoring beam with function 
\ahlink{setrestoringbeam}{images:image.setrestoringbeam}.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('hcn')      
- im.restoringbeam()
[major=[value=35, unit=arcsec], 
 minor=[value=13, unit=arcsec], 
 positionangle=[value=80, unit=deg]] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{sepconvolve}{Separable convolution}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{axes}{Axes to convolve}{[1,2,...]}{Vector of integers}
  \ahaddarg[in]{types}{Type of convolution kernel}{'gaussian'}
           {Vector of strings from  `boxcar', `gaussian', and `hanning'}
  \ahaddarg[in]{widths}{Convolution kernel widths}{}{Vector of numeric, quantity or string}
  \ahaddarg[in]{scale}{Scale factor}{Autoscale}{Float}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function (short-hand name {\stff sc}) does Fourier-based 
convolution of an \imagefile\ by a specified separable kernel.  

If {\stfaf outfile} is given, the image is written to the specified disk
file.  If {\stfaf outfile} is unset, the Image \tool\ is associated
with a temporary image.  This temporary image may be in memory or on
disk, depending on its size.  When you destroy the Image \tool\ 
(with the \ahlink{done}{images:image.done} function) this
temporary image is deleted.

You specify which axes of the image you wish to convolve, by what kernel
of what width. The kernel types can be shortened to {\cf `gauss',
`hann'} and {\cf `box'}. 

You specify the widths of the convolution kernels via the argument
{\stfaf widths}.  The values can be specified as a vector of three
different types.

\begin{itemize}

\item Quantity - for example {\stfaf widths=dq.quantity("1arcsec 0.00001rad")}.
Note that you can use pixel units, viz. {\stfaf widths=dq.quantity("10pix 0.00001rad")}
see below.

\item String - for example {\stfaf widths="1km 2arcsec"} (i.e. a string that the
Quanta \ahlink{Constructor}{quanta:quanta} accepts).  
  
\item Numeric - for example {\stfaf widths=[10,20]}.  In this case,
the units of the widths are assumed to be in pixels.
           
\end{itemize}

The interpretation of {\stfaf widths} depends upon the kernel type.


\begin{itemize}

\item Gaussian - the specified width is the full-width at
half-maximum.  

\item Boxcar (tophat) - the specified width is
the full width.  

\item Hanning - The kernel is $z[i] = 0.25*y[i-1] + 0.5*y[i] +
0.25*y[i+1]$.  The width is always 3 pixels, regardless of what
you give (but you still have to give it !).

\end{itemize}

The scaling of the output image is determined by the argument {\stfaf scale}.
If you leave it unset, then autoscaling will be invoked which means that
the convolution kernels will all be normalized to have unit volume
to as to conserve flux.  

If you do not leave {\stfaf scale} unset, then the convolution kernel  
will be scaled by this value (it has peak unity before application
of this scale factor).

Masked pixels will be assigned the value 0.0 before convolution. 
The output mask is the combination (logical OR) of the default input 
\pixelmask\ (if any) and the OTF mask.  Any other input \pixelmasks\
will not be copied.  Use function
\ahlink{maskhandler}{images:image.maskhandler} if you need to copy other
masks too.


See also the other convolution functions
\ahlink{convolve2d}{images:image.convolve2d},
\ahlink{convolve}{images:image.convolve} and
\ahlink{hanning}{images:image.hanning}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- dowait := T
- im := image('xyv')
- im2 := im.sepconvolve(outfile='xyv.con', axes=[2,3], types="gauss box", widths=[10,20])
\end{verbatim}

\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{sepconvolvegui}{Separable convolution via custom GUI interface}
\begin{ahargs}
  \ahaddarg[in]{parent}{Parent frame to embed GUI in}{Create stand a alone}{\glish\/Tk agent}
  \ahaddarg[in]{widgetset}{The widgetset to use for the GUI}{dws}{A widgetserver tool}
\end{ahargs}
\ahreturns{Agent or fail}

\begin{ahdescription}

\medskip
{\bf General}

This function (short-hand name {\stff scgui}) starts the custom GUI
interface for the \ahlink{sepconvolve}{images:image.sepconvolve}
function. Here is an example of the GUI.

\begin{figure}[h]
\begin{center}
\epsfig{file=imagesepconvolvegui.ps, width=4.5in}
\caption{The sepconvolve GUI}
\label{fig:sepconvolvegui}
\end{center}
\end{figure}


The GUI allows you to select which axes (listed by name) you wish to
convolve.  If you check the `Convolve' button for any axis, then that
indicates you wish to convolve that axis.  The kernel types and widths
widgets will then be active.  You must fill in the widths for each
selected axis.   You can give the widths as simple numeric values (units
of pixels assumed) or values with units like {\cf 10arcsec} or
{\cf 20km/s}, {\cf 5pix} etc.

Popuphelp is on each button to tell you what they do. 

If you don't provide a parent frame (the {\stfaf parent} argument),
the GUI is made in a standalone mode.  This means it creates
go, reset and dismiss buttons.  If you provide the parent frame,
you must also provide the buttons and act on them.

Although this function returns a reference to the underlying
subsequence for the custom GUI, you shouldn't need to do anything with it.


\medskip
{\bf Recovering the GUI}

When you run this function, it returns an agent which is actually a
reference to the underlying GUI.  In addition, the GUI is left on the
screen.  You can explicitly dismiss it by pressing the Dismiss button or
selecting Dismiss from the File menu.  To recover the GUI you can do one
of two things. 

\begin{enumerate}

\item Run the command {\stfaf sepconvolvegui} again.  This will
return another reference of the GUI to you.  However,
it will reset some parts of the GUI because it is possible
that the image changed since you last ran this function
(the pixel values might have changed, it might even be a different
\imagefile\ attached to this \tool).

Thus

\begin{verbatim}
- im := image('myimage')
- g := im.sepconvolvegui()             # Click Dismiss on GUI
- g := im.sepconvolvegui()             # Get GUI back with some reset
\end{verbatim}


\item Apply the {\stfaf gui} function to the reference
returned when you ran the {\stfaf sepconvolvegui} function.
This simply recovers the GUI with no resetting.  If the
image {\bf has} changed, this will not reflect it.

\begin{verbatim}
- im := image('myimage')
- g := im.sepconvolvegui()             # Click Dismiss on GUI
- g.gui()                              # Get GUI back with no change
\end{verbatim}   

\end{enumerate}

If you destroy the GUI (by selecting Done from  the File
menu) then you must run the {\stfaf sepconvolvegui} function
again to regenerate it.

\end{ahdescription}
\end{ahfunction}


\begin{ahfunction}{set}{Set pixel and/or mask values with a scalar in a region-of-interest of the image}
\begin{ahargs}
  \ahaddarg[in]{pixels}{The pixel value}{unset}{LEL scalar expression or numeric scalar}
  \ahaddarg[in]{pixelmask}{The pixel mask value}{unset}{T or F}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{list}{List the bounding box and any mask creation to the logger}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function replaces data and/or mask values into the image in the
specified \region.  You can think of it as a simplified version of the
image calculator. 

Unlike the \ahlink{calc}{images:image.calc} function, you can
only set a scalar value for all pixels in the specified \region.  For
example, it can be useful to set a whole image to one value, or a mask
in a \region\ to one value.  Although you could do that with the related
functions \ahlink{putregion}{images:image.putregion} and
\ahlink{putchunk}{images:image.putchunk}, you would have to make an
array of the shape of the image and if that is large, it could be
resource expensive. 

The value for the pixels is specified with the {\stfaf pixels} argument.  It can
be given as either a Lattice Expression Language (or LEL) expression
string or a simple numeric scalar.  See \htmladdnormallink{note
223}{../../notes/223/223.html} for a detailed description of the LEL
expression syntax.  If you give a LEL expression it must be a scalar
expression.   

Note that any default mask is {\em ignored} by this function when you
set pixel values.  This is different from
\ahlink{calc}{images:image.calc} where the extant mask is
honoured. 

The value for the pixel mask is specified with the {\stfaf pixelmask}
argument ({\cf T, F, unset}).  If it's {\cf unset} then the mask is not
changed.  

If you specify {\stfaf pixelmask=} T or F, then the mask that is affected is
the current default mask (see
\ahlink{maskhandler}{images:image.maskhandler}).  If there is no mask, a
mask is created for you and made the default mask. 


\end{ahdescription}

\begin{ahexample}

\begin{verbatim}
- im := imagefromshape('xx', [10,20])
- r1 := drm.box([2,2],[6,8])         # Make a box region
- im.set(pixels=1.0)                 # Set all pixels to 1
- im.set(pixels='1.0', region=r1)    # Set all pixels to 1 in the region
- im.set(pixels='min(yy)')           # Set all pixels to minimum of image yy
- im.set(pixels='min($im)', region=r1) # Set pixels in region to minimum of image xx
- im.set(pixelmask=T)                       # Set mask to all T
- im.set(pixels=0, pixelmask=F, region=r1)  #Set pixels and mask in region
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setbrightnessunit}{Set the image brightness unit}
\begin{ahargs}
  \ahaddarg[in]{unit}{New brightness unit}{}{String}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function (short-hand name {\stff sbu}) sets the image brightness unit.
You can get the brightness unit with function
\ahlink{brightnessunit}{images:image.brightnessunit}.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagefromshape(shape=[10,10])
- im.setbrightnessunit('km')
- im.brightnessunit()
km
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{setcoordsys}{Set new Coordinate System}
\begin{ahargs}
  \ahaddarg[in]{csys}{Coordinate System}{}{Coordsys tool}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function replaces the Coordinate System in the image. Coordinate
System are stored in and manipulated with the
\ahlink{Coordsys}{images:coordsys} \tool.  The Coordinate System can be
recovered from an image via the \ahlink{coordsys}{images:coordsys}
function.

Note that changing the Coordsys \tool\ has no effect on the original
image, until it is replaced with this function.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagefromshape(shape=[10,20])  # Make image
- cs := im.coordsys();                 # Recover Coordinate System
- incr := cs.increment('n');             # Get increment as numeric vector
- cs.setincrement(value=2*incr);       # Set new increment in Coordinate System
- im.setcoordsys(cs);                  # Set new Coordinate System in image
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{sethistory}{Set the history for an image}
\begin{ahargs}
  \ahaddarg[in]{history}{New history}{None}{String or vector of strings}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

An \aipspp\ \imagefile\ can accumulate history information
from  an input \fits\ file or by you writing something into
it explicitly with this function.     Each element of
the input vector is one line of history.  The new
history is appended to the old.

Presently, \aipspp\  functions do not automatically add history records.
You can recover the old history with function
\ahlink{history}{images:image.history}.

\end{ahdescription}

 
\begin{ahexample}
\begin{verbatim}
- im := image('myfile')  
- h := im.history()
- im.sethistory("I like fish")       # Adds three lines, 'I', 'like' and 'fish'
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setmiscinfo}{Set the miscellaneous information record for an image}
\begin{ahargs}
  \ahaddarg[in]{info}{Miscellaneous REPLACEMENT header}{}{Record}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

An \aipspp\ \imagefile\ can accumulate various miscellaneous information
during its lifetime; it is stored in a \glish\ record called the {\stff
miscinfo} record.  For example, the \fits\ reader
(\ahlink{imagefromfits}{images:image.imagefromfits.constructor}) puts header keywords
it doesn't otherwise use into the {\stff miscinfo} record.  The {\stff
miscinfo} record is not guaranteed to have any entries, so it's up to
you to check for any fields that you require. 

This function sets the {\cf miscinfo} record of the \imagefile.  Note
that this function {\em replaces} the record, it doesn't add to it, so
if you want to augment the existing record, you should first capture it
with the \ahlink{miscinfo}{images:image.miscinfo}) function, add to the
record, and then put it back.  The \fits\ writer will attempt to write
all the fields in the {\stff miscinfo} record to \fits\ file argument. 
It can do so for scalars and 1-dimensional arrays.  Records will be
omitted, and multi-dimensional arrays will be flattened into
1-dimensional arrays. 

\end{ahdescription}

 
\begin{ahexample}
\begin{verbatim}
- im := image('myfile')  
- x := something(im)      # calculate something interesting from im
- info := im.miscinfo()   # capture the miscinfo record
- info.mycalc := x        # add our result to it
- im.setmiscinfo(info)    # put it back into the image
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{shape}{Length of each axis in the image}
\ahreturns{Vector of integers or fail}
\begin{ahdescription}

The shape of an image is a vector holding the length of each axis of the
image.  Although this information is also available in the
\ahlink{summary}{images:image.summary} function, it is so useful that it
has been separated out into a separate function. 

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- imshape := im.shape()
- npixels := prod(imshape)    # imshape[1]*imshape[2]*...*imshape[n]
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{setrestoringbeam}{Set the restoringbeam}
\begin{ahargs}
  \ahaddarg[in]{major}{Major axis FWHM}{Unset}{Quantity or float}
  \ahaddarg[in]{minor}{Minor axis FWHM}{Unset}{Quantity or float}
  \ahaddarg[in]{pa}{Position angle}{Unset}{Quantity or float}
  \ahaddarg[in]{beam}{The complete restoring beam}{Unset}{Record}
  \ahaddarg[in]{delete}{Delete the restoring beam}{F}{T or F}
  \ahaddarg[in]{log}{Write new beam values to the logger}{F}{T or F}
\end{ahargs}

\ahreturns{T or fail}
\begin{ahdescription}

This function (short-hand name {\stff srb}) sets the restoring beam.
Do not do this unless it is a correct thing to do !

You may supply the beam in one of two ways.  

First, you can use the argument {\stfaf beam} which you must assign to a
\glish\ record containing  fields 'major', 'minor' and 'postionangle'.  
Each of these fields contains a quantity.   This record is in the same
format as  one returned by function
\ahlink{restoringbeam}{images:image.restoringbeam}. If you leave {\stfaf
beam} unset, no action with it is taken. If the function argument
{\stfaf beam} is used, the arguments {\stfaf major, minor, \& pa} are
ignored.

Second, you can use the arguments {\stfaf major}, {\stfaf minor}
and {\stfaf pa}.   Only the ones that you assign are used.
Each argument should be assigned either a quantity or a float (units
are implicitly those of the current beam - or if none, arcsec for
the axes and degrees for the position angle).

You may also delete the restoring beam by setting {\stfaf delete=T}
(all other arguments are then ignored).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('hcn')      
- rb := im.restoringbeam()
- rb
[major=[value=35, unit=arcsec], 
 minor=[value=13, unit=arcsec], 
 positionangle=[value=80, unit=deg]] 
-
- rb.minor.value := 12.5
- im.setrestoringbeam(beam=rb)
- im.restoringbeam()
[major=[value=35, unit=arcsec], 
 minor=[value=12.5, unit=arcsec], 
 positionangle=[value=80, unit=deg]] 
-
- im.setrestoringbeam(major=36)
- im.restoringbeam()
[major=[value=36, unit=arcsec], 
 minor=[value=12.5, unit=arcsec], 
 positionangle=[value=80, unit=deg]] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{statistics}{Compute statistics from the image}
\begin{ahargs}
  \ahaddarg[out]{statsout}{\glish\ record containing all statistics}{No retrieval into a \glish\ record}{\glish\ record}
  \ahaddarg[in]{axes}{List of axes to evaluate statistics over}{All axes}{Vector of integers}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{plotstats}{List of statistics to plot}{'mean sigma'}{String containing any
           combination of 'npts', 'sum', 'flux', 'sumsq', 'min', 
           'max', 'mean', 'sigma' (or 'stddev'), 'rms', 'median', 'medabsdevmed', 'quartile'}
  \ahaddarg[in]{includepix}{Range of pixel values to include}{Include all pixels}{Vector of 1 or 2 Floats}
  \ahaddarg[in]{excludepix}{Range of pixel values to exclude}{Exclude no pixels}{Vector of 1 of 2 Floats}
  \ahaddarg[in]{plotter}{The PGPLOT device name to make plots on}{No plotting}{Any valid PGPLOT device}
  \ahaddarg[in]{nx}{The number of subplots per page in the x direction}{1}{Any positive integer}
  \ahaddarg[in]{ny}{The number of subplots per page in the y direction}{1}{Any positive integer}
  \ahaddarg[in]{list}{If T then list the statistics as well}{T}{Bool}
  \ahaddarg[in]{force}{If T then force the stored statistical accumulations to be regenerated}{F}{Bool}
  \ahaddarg[in]{disk}{If T then force the storage image to disk}{F}{Bool}
  \ahaddarg[in]{robust}{If T then compute robust statistics as well}{F}{Bool}
  \ahaddarg[in]{verbose}{If T then print useful messages to the logger}{T}{Bool}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait - but always F if plotting}{Bool}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function (short-hand name is {\stff stats}) computes statistics
from the pixel values in the image.  You can then plot them, list them
and retrieve them (into a \glish\ record) for further analysis. 

The chunk of the image over which you evaluate the statistics is
specified by an array of axis numbers (argument {\stfaf axes}).  For example,
consider a 3-dimensional image for which you specify {\stfaf axes=[1,3]}. 
The statistics would be computed for each XZ (axes 1 and 3) plane in the
image.  You could then examine those statistics as a function of the Y
(axis 2) axis.  Or perhaps you set {\stfaf axes=[3]}, whereupon you could
examine the statistics for each Z (axis 3) profile as a function of X
and Y location in the image. 

You have control over how the statistics are presented; whether they are
listed, or plotted, or retrieved into \glish\ records or all of the above. 

A variety of statistics are offered for plotting and you can plot any
combination of them simultaneously (argument {\stfaf plotstats}).   

If you retrieve the statistics into a \glish\ record (argument {\stfaf
statsout}) each statistic is stored in an array in one named field in
the \glish\ record.  The shape of that array is that of the axes which
you did {\bf not} evaluate the statistics over.  For example, in the
second example above, we set {\stfaf axes=[3]} and asked for statistics
as a function of the remaining axes, in this case, the X and Y (axes 1
and 2) axes.  The shape of each statistics array is then [nx,ny]. 

The names of the fields in this record are the same as the names of the
statistics that you can plot: 

\begin{itemize}

\item {\stfaf npts} - the number of unmasked points used

\item {\stfaf sum} - the sum of the pixel values: $\sum I_i$

\item {\stfaf flux} - the integrated flux density if the beam is defined and
the brightness units are $Jy/beam$

\item {\stfaf sumsq} - the sum of the squares of the pixel values: $\sum I_i^2$

\item {\stfaf mean} - the mean of pixel values: $\bar{I} = \sum I_i / n$

\item {\stfaf sigma} - the standard deviation about the
mean: $\sigma^2 = (\sum I_i - \bar{I})^2 / (n-1)$

\item {\stfaf rms} - the root mean square: $\sqrt {\sum I_i^2 / n}$

\item  {\stfaf min} - minimum pixel value

\item {\stfaf max} - the maximum pixel value

\item {\stfaf median} - the median pixel value (if {\stfaf robust=T})

\item {\stfaf medabsdevmed} - the median of the absolute deviations from the median
(if {\stfaf robust=T})

\item {\stfaf quartile} - the inter-quartile range (if {\stfaf
robust=T}).  Find the points which are 25\% largest and 75\% largest
(the median is 50\% largest), find their difference and divide that
difference by 2.

\item {\stfaf blc} - the absolute pixel coordinate of the bottom left corner of the bounding box

\item {\stfaf blcf} - the formatted absolute world coordinate of the bottom left corner of the bounding box

\item {\stfaf trc} - the absolute pixel coordinate of the top right corner of the bounding box

\item {\stfaf trcf} - the formatted absolute world coordinate of the top right corner of the bounding box

\item {\stfaf minpos} - absolute pixel coordinate of minimum pixel value

\item {\stfaf maxpos} - absolute pixel coordinate of maximum pixel value

\item {\stfaf minposf} - formatted string of the world coordinate of
the minimum pixel value

\item  {\stfaf maxposf} - formatted string of the world coordinate of
the maximum pixel value

\end{itemize}

the last four fields only appear if you evaluate the statistics over all
axes in the image.  As an example, if your output \glish\ record is
called {\stfaf `mystats'}, then you could access the `mean' field via
{\cf print mystats.mean}. 

If there are no good points (e.g.  all pixels are masked bad in the
region), then the length of these fields will be 0 (e.g.  {\cf
length(rec.npts)==0}). 

If you retrieve statistics all of the available statistics are retrieved
into the \glish\ record regardless of what you might have asked to plot. 
You can of course also plot the statistics by accessing the arrays in
the \glish\ record, rather than using the built in plotting
capability. 

You also have no control over which statistics are listed to the logger,
you always get the same selection.  You can choose to list the statistics or not
(argument {\stfaf list}). 

As well as the simple (and faster to calculate) statistics like means
and sums, you can also compute some robust statistics.  Currently these
are the median, median absolute deviations from the median and the
inter-quartile range.  Because these are computationally expensive, they
are only computed if you directly ask for them.  You can do this in two
ways.  First by requesting a robust statistic in the list of statistics
to plot.  Second by setting {\stfaf robust=T} (it defaults to F).  For
example, it may be that you are not making any plots but wish to recover
the robust statistics into the output record.  This is why this extra
argument is needed. 

Note that if the axes are set to all of the axes in the image (which is
the default), no plotting is available as there would be just one point
per statistic. 

You have control over which pixels are included in the statistical sums
via the {\stfaf includepix} and {\stfaf excludepix} arguments.  These vectors
specify a range of pixel values for which pixels are either included or
excluded.  They are mutually exclusive; you can specify one or the
other, but not both.  If you only give one value for either of these,
say {\stfaf includepix=b}, then this is interpreted as {\stfaf
includepix=[-abs(b),abs(b)]}.  

The plotting is done directly on a PGPLOT plotting device.  The syntax
is {\stfaf plotter=name/type}.  For example {\stfaf
plotter='plot1.ps/ps'} (disk postscript file) or {\stfaf plotter='plot/glish'}
(\glish\ pgplotter). 

This function generates a `storage' lattice, into which the statistics
are written.  It is only regenerated when necessary.  For example, if
you run the function twice with identical arguments, the statistics will
be directly retrieved from the storage lattice the second time. 
However, you can force regeneration of the storage image if you set
{\stfaf force=T}.  The storage medium is either in memory or on disk,
depending upon its size.  You can force it to disk if you set {\stfaf
disk=T}, otherwise it decides for itself.    

\end{ahdescription}


\begin{ahexample} 
\begin{verbatim} 
- im.statistics()
\end{verbatim} 
In this example, we ask to see statistics evaluated over the
entire image.  No plotting is available under these conditions.
\end{ahexample}

\begin{ahexample} 
\begin{verbatim} 
- im.statistics(statsout=mystats,axes=[2,3],plotstats='sigma, rms',
+               includepix=[0,100],plotter='/glish',list=F)
\end{verbatim} 

In this example, let us assume the image has 3 dimensions.  We plot the
standard deviation about the mean and the rms of YZ (axes 2 and 3)
planes for pixels with values in the range 0 to 100 as a function of
X-axis location on the standard PGPLOT X-windows device.  The statistics
are not listed to the logger.  Because we are making plots, the tool
function is automatically run synchronously so we can directly recover
the the \glish\ record containing the statistics arrays. 

\end{ahexample}
\end{ahfunction} 




\begin{ahfunction}{twopointcorrelation}{Compute two point correlation function from the image}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{axes}{The pixel axes to compute structure function over}{Sky or first two}{Vector of integers}
  \ahaddarg[in]{method}{The method of computation}{structurefunction}{String from 'structurefunction'}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function (short-hand name is {\stff tpc}) computes two-point auto-correlation
functions from an image.  

By default, the auto-correlation function is computed for the Sky axes.
If there is no sky in the image, then the first two axes are used.
Otherwise you can specify which axes the auto-correlation function lags
are computed over with the {\stfaf axes} argument (must be of length 2).

Presently, only the Structure Function is implemented.  This is defined as :

\begin{displaymath}
S(lx,ly) = < (data(i,j) - data(i+lx,j+ly))^2 >
\end{displaymath}

where $lx, ly$ are integer lags in the x (first axis) and y (second axis)
directions.  The ensemble average is over the all values at the same lag pair.
This process is extremely compute intensive and so you may have to be patient.

In an auto-correlation function image there are some symmetries.  The
first and third quadrants are symmetric, and the second and fourth are
symmetric.  So in principle, all the information is in the top or bottom
half of the image.  We just write it all out to look nice.  The long
lags don't have a lot of contributing values of course.  

\end{ahdescription}


\begin{ahexample} 
\begin{verbatim} 
- im := imagemaketestimage();        # Output image is virtual
- im2 := im.twopointcorrelation()    # Output image is virtual
\end{verbatim} 
\end{ahexample}

\end{ahfunction} 




\begin{ahfunction}{subimage}{Create a (sub)image from a region of the image}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Output image file name}{unset}{String}
  \ahaddarg[in]{region}{Region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{dropdeg}{Drop degenerate axes}{F}{T or F}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{list}{List informative messages to the logger}{T}{T or F}
\end{ahargs}
\ahreturns{Image tool or fail}

\begin{ahdescription}

This function (short-hand name {\stff subim}) copies all or part of the
image to another (there is also a
\htmlref{subimage}{images:image.subimage.constructor} constructor). 

If {\stfaf outfile} is given, the subimage is written to the specified
disk file.  If {\stfaf outfile} is unset, the Image \tool\ actually
references the input image file (i.e.  that associated with the Image
\tool\ to which you are applying this function).  So if you deleted the
input image disk file, it would render this \tool\ useless.  When you
destroy this \tool\ (with the \ahlink{done}{images:image.done} function)
the reference connection is broken. 

Sometimes it is useful to drop axes of length one (degenerate axes).
Use the {\stfaf dropdeg} argument if you want to do this.

The output mask is the combination (logical OR) of the default input 
\pixelmask\ (if any) and the OTF mask.  Any other input \pixelmasks\
will not be copied.  Use function
\ahlink{maskhandler}{images:image.maskhandler} if you need to copy other
masks too.

\end{ahdescription}


\begin{ahexample}
\begin{verbatim}
- im := image('myfile')
- im2 := im.subimage()                                        # a complete copy
- r1 := drm.box([10,10],[30,40],[5,5])                        # A strided pixel box region
- im3 := im.subimage(outfile='/tmp/foo', region=r1)           # Explicitly named subimage
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{summary}{Summarize basic information about the image}
\ahreturns{T or fail}
\begin{ahargs}
  \ahaddarg[out]{header}{Header information}{empty}{}
  \ahaddarg[in]{doppler}{If there is a spectral axis, list velocity too, with this doppler definition}{RADIO}{String}
  \ahaddarg[in]{list}{List the summary to the logger}{T}{T or F}
  \ahaddarg[in]{pixelorder}{List axis descriptors in pixel or world axis order}{T}{T or F}
\end{ahargs}
\begin{ahdescription}

This function summarizes miscellaneous information such as shape, Coordinate System,
restoring beams, and masks.

If called without any arguments, this function displays a summary of the
image header to the logger only; where appropriate, values will be
formatted nicely (e.g.  HH:MM:SS.SS for the reference value of RA axes). 

For spectral axes, the information is listed as a velocity as well as a
frequency.  The argument {\stfaf doppler} allows you to specify what
velocity doppler convention it is listed in.  You can choose from {\stfaf radio,
optical} and {\stfaf true}.  Alternative names are {\stfaf z} for
{\stfaf optical}, and {\stfaf beta} or {\stfaf relativistic} for {\stfaf
true}.  The default is {\stfaf radio}.  The definitions are

\begin{itemize}
\item radio: $1 - F$
\item optical: $-1 + 1/F$
\item true: $(1 - F^2)/(1 + F^2)$
\end{itemize}
where $F = \nu/\nu_0$ and $\nu_0$ is the rest frequency.  If the rest
frequency has not been set in your image, you can set it via
a Coordsys \tool\ with
the function \ahlink{setrestfrequency}{images:coordsys.setrestfrequency}.

If the {\stfaf header} argument is supplied, that 
argument will be a \glish\ record with the following fields filled in:
\begin{description}
    \item[ndim]       Dimension of the image.
    \item[shape]      Length of each axis in the image.
    \item[tileshape]  Shape of the chunk which is most efficient for I/O.
    \item[axisnames]  Name of each axis.
    \item[refpix]     Reference pixel for each axis (1 relative)
    \item[refval]     Reference value for each axis.
    \item[incr]       Increment for each axis.
    \item[axisunits]  Unit name for each axis.
    \item[unit]       Brightness units for the pixels.
    \item[hasmask]    True if the image has a mask.
    \item[defaultmask]The name of the mask which is applied by default.
    \item[masks]      The names of all the masks stored in this image.
    \item[restoringbeam] The restoring beam if present.
    \item[imagetype]   The image type.
\end{description}

If you set {\stfaf list=F}, then the summary will not
be written to the logger.  However, in addition to the 
output record, the return value of the function will
be a vector strings containing the formatted output
that would normally have gone to the logger.   If {\stfaf list=T}
the return value is always T or a fail.


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- im := image('myim1')
- im.summary()                 # summarize to logging only

Image name       : test
Image mask       : mask0 [mask1, mask2]
Image units      : JY/BEAM

Direction reference : J2000
Spectral  reference : LSRK
Velocity  type      : RADIO
Rest frequency      : 1.42041e+09 Hz

Telescope        : ATCA
Observer         : NEBK
Date observation : 1997/02/121/03:03:26


Axis Type      Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
------------------------------------------------------------------------------------------ 
1    Direction Right Ascension   SIN  512   10  00:00:00.000     6.00 -6.000000e+01 arcsec
2    Direction Declination       SIN  512   20 +00.00.00.000    11.00  6.000000e+01 arcsec
3    Spectral  Frequency             1024   30  1.415000e+09    16.00  1.000000e+03 Hz
               Velocity                         1.140944e+03    16.00 -2.110611e-01 km/s


- im.summary(header,list=F)      # store header in Glish record
- if (header.ndim == 3) ...      # program using header values
\end{verbatim}
\end{ahexample}

Note that the Spectral Coordinate is listed twice; once with frequency
and once with velocity units.  You can distinguish this double listing
because the shape of the axis is only listed once (in
this case on the Frequency line). 

Note also that this image has three masks present.  The first one is the
default which means that it is applied by applications.  Any of the
other masks, listed in square brackets, could be made the default mask
by application of the \ahlink{maskhandler}{images:image.maskhandler}
function.   If there was no default mask (effectively that means
an all good mask would be applied), all the mask names would be 
listed in square brackets.

\end{ahfunction}





\begin{ahfunction}{tofits}{Convert the image to a FITS file}
\begin{ahargs}
  \ahaddarg[in]{outfile}{FITS file name}{Input name + `.fits'}{String}
  \ahaddarg[in]{velocity}{prefer velocity (rather than frequency) as primary spectral axis?}{F}{Bool}
  \ahaddarg[in]{optical}{use the optical (rather than radio) velocity convention?}{T}{Bool}
  \ahaddarg[in]{bitpix}{Bits per pixel}{-32}{-32 (floating point) or 16 (integer)}
  \ahaddarg[in]{minpix}{Minimum pixel value for BITPIX=16}{Autoscale}{Float}
  \ahaddarg[in]{maxpix}{Maximum pixel value for BITPIX=16}{Autoscale}{Float}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
  \ahaddarg[in]{dropdeg}{Drop degenerate axes ?}{F}{T or F}
  \ahaddarg[in]{deglast}{Put degenerate axes last in header ?}{F}{T or F}
  \ahaddarg[in]{async}{Run asynchronously?}{!dowait}{Bool}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function converts the image into a \fits\ file.
%%(writes to the FITS ``primary array''). 

If the image has a rest frequency associated with it, it will always
write velocity information into the \fits\ file.  By default the
frequency information will be primary as it is better defined than
velocity information.  If you select {\stfaf velocity=T} then by default
the velocity is written in the optical convention, but if {\stfaf
optical=F} it will use the radio convention instead. 

The \fits\ definition demands equal increment pixels.  Therefore, if you
write velocity information as primary and use the optical velocity
definition, the increment is computed at the spectral reference pixel. 
If the bandwidth is large, this may incur non-negligible coordinate
calculation errors far from the reference pixel. 

By default the image is written as a floating point \fits\ file ({\stfaf 
bitpix= -32}).  Under rare circumstances you might want to save space
and write it as scaled 16 bit integers ({\stfaf bitpix = 16}).  You can
have {\stff tofits} calculate the scaling factors by unsetting {\stfaf
minpix}  and {\stfaf maxpix} (the default).  If you set {\stfaf
minpix} and {\stfaf maxpix}, values outside of that range will be
truncated.  This can be useful if all of the \fits\ images dynamic range
is being used by a few high or low values and you are not interested in
preserving those values exactly.  Besides the factor of two space
savings you get by using 16 instead of 32 bits, integer images usually
also compress well (for example, with the standard GNU software
facility {\tt gzip}). 

If the specified \region\ extends beyond the image, it is truncated.

The output mask is the combination (logical OR) of the default input 
\pixelmask\ (if any) and the OTF mask. 

Sometimes it is useful to drop axes of length one (degenerate axes)
because not all FITS readers can handle them.  Use the {\stfaf dropdeg}
argument if you want to do this. 


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- ok := im.tofits('MYFILE.FITS')             # write FITS image file
- ok := im.tofits('MYFILE2.FITS', bitpix=16) # Write as scaled 16 bit integers
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{toascii}{Convert the image to an ascii file}
\begin{ahargs}
  \ahaddarg[in]{outfile}{Ascii file name}{Input name + `.ascii'}{String}
  \ahaddarg[in]{region}{The region of interest}{Whole image}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{sep}{Separator of data in ascii file}{' '}{String}
  \ahaddarg[in]{format}{Format of data in ascii file}{\%e}{String}
  \ahaddarg[in]{maskvalue}{Value to replace masked pixels by}{No change}{Float or unset}
  \ahaddarg[in]{overwrite}{Overwrite (unprompted) pre-existing output file ?}{F}{T or F}
\end{ahargs}
\ahreturns{T or fail}
\begin{ahdescription}

This function converts the image into an ascii file. The format is one
image row per line (see
\ahlink{imagefromascii}{images:image.imagefromascii.constructor}).

The output mask is the combination (logical OR) of the default input 
\pixelmask\ (if any) and the OTF mask.  Because the mask is not
transferred to the ascii file, you must specify what data value to use
if a pixel is masked.  By default, the underlying data value in the
image is used. But this could be anything (and often it's a NaN), so you
could set, say, {\stfaf maskvalue=-10000} as a magic value.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage()
- ok := im.toascii('myfile.ascii')
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{type}{Return the type of this tool}
\ahreturns{String or fail}

\begin{ahdescription}

This function returns the string `image'.  It is used so that  in
a script, you can make sure this \glish\ variable is an Image
\tool.

\end{ahdescription}
\end{ahfunction}



\begin{ahfunction}{topixel}{Convert from world to pixel coordinate}
\begin{ahargs}
\ahaddarg[in]{value}{Absolute world coordinate}{Reference value}{Numeric vector, vector of quantities or record}
\end{ahargs}
\ahreturns{Vector of float or fail}

\begin{ahdescription}

This function converts from absolute world to pixel coordinate (1-rel). 
The world coordinate can be provided in many formats (numeric, string,
quantum etc.) via the argument {\stfaf value}.  These match the output
formats of function \ahlink{toworld}{images:image.toworld}. 

This function is just a wrapper for the Coordsys \tool\ function
\ahlink{topixel}{images:coordsys.topixel} so see the documentation there
for a description and more examples. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagemaketestimage();
- w := im.toworld([10,10], 'n')        # Numeric vector
- im.topixel(w)
[10 10]
- w := im.toworld([10,10], 'm')        # Record of measures
- im.topixel(w)
[10 10]
\end{verbatim}
Convert to a pixel coordinate to world as floats and then
back to pixel.  Do the same with the world coordinate
formatted as measures instead.
\end{ahexample}

\end{ahfunction}



\begin{ahfunction}{toworld}{Convert from pixel to world coordinate}
\begin{ahargs}
\ahaddarg[in]{value}{Absolute pixel coordinate}{Reference pixel}{Numeric vector}
\ahaddarg[in]{format}{What type of formatting ?}{'n'}
         {String from combination of 'n' (numeric), 'q' (quantity), 'm' (measure), 's' (string)}
\end{ahargs}
\ahreturns{Vector float, vector quantity, record, string or fail}


\begin{ahdescription}

This function converts between absolute pixel coordinate (1-rel)   
and world (physical coordinate).

This function is just a wrapper for the Coordsys \tool\ function
\ahlink{toworld}{images:coordsys.toworld} so see the documentation there
for a description of the arguments and more examples. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('hcn')
- w := cs.toworld([10,10], 'n')
- w := cs.toworld([10,10], 'nmq')
\end{verbatim}
Convert to a vector of floats and then to a record
holding a vector of floats, a vector of quantities
and a subrecord of measures.
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{unlock}{Release any lock on the image}

\begin{ahdescription}

This function releases any lock set on the \imagefile\ (and also flushes
any outstanding I/O to disk).  It is not of general user interest.  It
can be useful in scripts when a file is being shared between more than
one process.  See also functions \ahlink{lock}{images:image.lock} and
\ahlink{haslock}{images:image.haslock}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := imagefromarray('xx', array(0,10,20))
- im.unlock()
\end{verbatim}

This releases the write lock on the \imagefile.  Now some
other process can gain immediate access to the \imagefile.

\end{ahexample}

\end{ahfunction}



\begin{ahfunction}{view}{Display the current image with the viewer}
\begin{ahargs}
  \ahaddarg[in]{parent}{Parent frame to embed display in}{F}{Glish/Tk frame agent}
  \ahaddarg[in]{raster}{Display as a raster}{Last value (T if first)}{unset, T or F}
  \ahaddarg[in]{contour}{Display as contours}{Last value (F is first)}{unset, T or F}
  \ahaddarg[in]{vector}{Display as vectors}{Last value (F is first)}{unset, T or F}
  \ahaddarg[in]{marker}{Display as marker}{Last value (F is first)}{unset, T or F}
  \ahaddarg[in]{region}{Region of interest}{Last value (whole image if first)}{Region tool}
  \ahaddarg[in]{mask}{OTF mask}{None}{Boolean LEL expression or mask region}
  \ahaddarg[in]{model}{Componentlist}{None}{Componentlist tool}
  \ahaddarg[in]{adjust}{Start adjustment GUI ?}{T}{T or F}
  \ahaddarg[in]{axislabels}{Display axis labels}{Last value (F if first)}{unset, T, F}  
  \ahaddarg[in]{includepix}{Pixel range}{Full range}{unset or Vector of float (length 1 or 2)}
  \ahaddarg[in]{order}{Order to display axes in}{Last value (natural if first)}{unset or vector integer}  
  \ahaddarg[in]{activatebreak}{Activate the break button}{unset}{unset, T, F}  
  \ahaddarg[in]{hasdimiss}{Add Dismiss button}{T}{T, F}  
  \ahaddarg[in]{widgetset}{The widgetset to use for the GUI}{ddlws}{A widgetserver tool}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

\begin{itemize}
\item {General}

This function displays the image with the viewer.  The viewer is built
with the Display Library.

This function displays the image as one or more of a raster display,
contour map, vector map or marker map.  The default behaviour is to
display first as a raster.  If {\stfaf raster}, {\stfaf contour},
{\stfaf vector} or {\stfaf marker} is left unset, then the behaviour is
to leave the raster or contour or vector display, respectively, as they
were last time.  You can set these arguments to T or F explicitly to get
what you want otherwise.   

You can embed the display panel it creates in an existing frame if you
wish ({\stfaf parent}).  You can optionally start the adjustment control
({\stfaf adjust=T}) GUI (one for each of the raster or contour displays)
which gives you control over things like axis labels, contour levels
etc.  

You can specify the \region\ you want to see with the {\stfaf region}
argument.  By default, you see the whole image.  If you call this
function again without specifying the {\stfaf region} argument, then you
get whatever \region\ you last displayed.  You must explicitly over-ride
{\stfaf region} to change the displayed \region. 

You can specify the pixel range used to map to the display colors via
the {\stfaf includepix} argument.  If unset (the default) the full range
is taken.   Otherwise you can specify 1 or 2 arguments.   If you only give
one value for either of these vectors, say {\stfaf includepix=[b]}, then
this is interpreted as {\stfaf includepix=[-abs(b),abs(b)]}.    If you
give two values, then these are the data minimum and maximum

The argument {\stfaf order} allows you to control the initial
display order of the axes in the image.  For example, if your
image has axes RA,DEC,Stokes,Frequency and you set {\stfaf order=[4,1,2]}
then the x-axis will be Frequency, the y-axis RA and the z-axis (movie
axis) DEC.   You can specify at most three axes.  The hidden axes will
sort themselves out.   The first time, by default you get the natural order.  
Thereafter, if {\stfaf orer} is unset you get the order you last 
specified.

The argument {\stfaf hasdismiss} controls whether a Dismiss button is
added to the GUI or not.  It always has a Done button.  This is argument
is not for  general user use.  

If you dismiss the display panel (press dismiss button) call the {\stff
view} function again to bring it back.   If you destroy the display
panel (press done button) it will be recreated next time you run the
{\stff view} function (takes longer than just redisplaying the GUI
of course).

An example display from this function as well as a full description of
most of it's GUI elements is shown \ahlink{here}{viewer:vdpgui}.

In this case, the 2D image is shown as a raster image with the default
`Rainbow 1' transfer function.  The axis labels are are turned
on and because the image is 2D the animation tapedeck is deactivated. 

Here are a few extra notes on the functionality.

The standard \ahlink{viewerdisplaypanel control box}{viewer:vdpguibtnbar}
control box is found along the left-hand side (zoom, pan, colormap
control and region making). 

There is an additional button at the bottom:

\begin{itemize}
\item Dismiss - dismiss the view. It can be recovered by
executing the {\stff view} function again (this is faster than
if you destroyed (done) it).

\end{itemize}

The menus along the top are a standard service provided
by the \ahlink{viewerdisplaypanel}{viewer:viewerdisplaypanel} \tool.
See it for discussion of the menu items if they are unclear.

Note in particular, that the "DisplayData" menu item can be used to
toggle on and off the raster and contour displays, regardless of the
values you gave the view function for arguments {\stfaf raster} and
{\stfaf contour}).   

The animation tapedeck along the right is a standard service provided by
the \ahlink{viewerdisplaypanel}{viewer:vdpguiani} \tool.  See
it for discussion of the tapedeck interface if is unclear. 


\item {Vector maps displays}

If you set {\stfaf vector=T} then the image will be displayed as a grid
of vectors (all of the same amplitude).  The image pixel values are
interpreted as the position angle.  If the image brightness unit
(\ahlink{brightnessunit}{images:image.brightnessunit}) is not angular,
degrees will be assumed.  You can set the brightness units with the
Image \tool\ function
(\ahlink{setbrightnessunit}{images:image.setbrightnessunit})

The position angle is measured positive North through East when you display a
plane holding a celestial coordinate (the usual astronomical
convention).  For other  axis/coordinate combinations, a positive
position angle is measured  from +x to +y in the
absolute world coordinate frame.

To make Vector map displays where the amplitude is also provided, you
need a Complex image and the basic Viewer
\ahlink{gui}{viewer:viewer.gui.function} interface. For more details, see the
discussion in  the \htmlref{Getting
Results}{GRdisplay} document.  See also the
\ahlink{Imagepol}{images:imagepol} \tool\ which has a function
\ahlink{makecomplex}{images:imagepol.makecomplex} to make Complex images
from amplitude/phase or real/imaginary Float images.


\item {The ImageAnalysis window} 

The menu bar of the viewerdisplaypanel provides you with a submenu
{\stff Tools}. This has an item {\stff ImageAnalysis}. If you select
this menu item, you are presented with some rollups which give access
to image analysis functions, such as interactive regions, positions
and profiles, statistics and summary. These rollups are described in the
\ahlink{viewerdisplaypanel}{viewer:vdpguiimanal} documentation.

\item {Connecting to the Regionmanager}
	
It is also possible to establish a connection with the
\ahlink{Regionmanager}{images:regionmanager} \tool\ so that it catches
the interactive regions you create.  This is done by requesting an
`interactive' region from the Regionmanager GUI.  This action will start
the {\stff view} function of the specified (in the Regionmanager) image
and the Regionmanager will collect the interactive regions that you
make.  The `break' button will be enabled.  If you wish to break the
connection to the Regionmanager from the image display you can press the
`break' button on the {\stff view} GUI. 
	
	

\item {Events}

A number of events are generated by the {\stff view} function
and emitted by the Image \tool.  You can catch these yourself
if you like, just like any \glish\ event.

\begin{ahexample}
\begin{verbatim}
- im := image('hcn')
- whenever im->* do {
+  print $name, $value
+ }
\end{verbatim}
This example catches all events from the Image \tool\ {\stf im}
and prints out the event names and values.
\end{ahexample}

Most of the events are simply forwarded from the
\ahlink{viewerdisplaypanel}{viewer:vdpevents}, but
\ahlink{image.view}{images:image.view} provides a few extra events.

\begin{itemize} 
\item {\tt region} see \ahlink{viewerdisplaypanel}{viewer:vdpevents}

\item {\tt position} see \ahlink{viewerdisplaypanel}{viewer:vdpevents}

\item {\tt statistics} see \ahlink{viewerdisplaypanel}{viewer:vdpevents}


\item {\tt breakfromviewer}

This event is not of general user interest.

The {\stfaf activatebreak} argument of the {\stff view} function is not
intended for general user use (use the default value).  However, if it is
set to T, then the `break' button on the displaypanel is activated.  If
it is set to F, the button is deactivated.  If left {\cf unset}, the
button state is left unchanged.  When the button is pressed, or when you
change its state via the call sequence, an event called {\tt
breakfromviewer} is emitted.  The \$value of the event are either T
(break deactivated) or F (break activated). 


\item {\tt viewerdone}

This event is not of general user interest.

The {\stff view} function generates its own private \viewer\ \tool\ with
which it makes the display.  When this private \viewer\ is destroyed
(e.g.  the user presses the done button) an event called {\tt
viewerdone} is emitted.  Its \$value is T. 

\end{itemize}
\end{itemize}


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
im := image('hcn')
im.view(raster=T, contour=T, adjust=T)
\end{verbatim}
\end{ahexample}

Displays the image as a raster and overlays contours.  The adjustment
panels (one for each display of the image) are shown as well. 
\end{ahfunction}


\end{ahobject}



%% Global functions

\begin{ahfunction}{is\_image}{Is this variable an image tool ?}
\begin{ahargs}
  \ahaddarg[in]{thing}{Variable to test}{None}{Glish variable}
\end{ahargs}


\ahreturns{T or F}
\begin{ahdescription}

Determine if this variable is an image tool.  This is very useful in
scripts; for robustness, you check that the tool is an Image \tool\
before you start applying Image \toolfunctions.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im:=image('myimage')              
- is_image(im)
T
- im2 := [10,20]
- is_image(im2)
F
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{imagefiles}{Find the list of image files in the given directory}
\begin{ahargs}
  \ahaddarg[in]{files}{Path/files of interest}{'.' the current working directory}{String}
  \ahaddarg[in]{strippath}{Strip off leading path name ?}{T}{T or F}
  \ahaddarg[in]{foreign}{Include foreign formats with native support ?}{F}{T or F}
\end{ahargs}
\ahreturns{Vector of Strings}

\begin{ahdescription}

This (global) function returns a list of the names of the image files on
disk in the specified path.  You can provide just a directory, or a
directory and wild-carded file list, or just the file list.  You can
optionally include the leading directory part of the output file names. 

If {\stfaf foreign==T}, then all foreign format image for which we have
native access (\fits\ and Miriad presently) are included in the listing. 
Otherwise, and by default, just \aipspp\ images are listed.  Please note
that presently, any \fits\ file (image or otherwise) will show up in the
listing. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im1:=imagefromshape('zz', [10])
- im2:=imagefromshape('zz2', [10])
- im2.tofits('zz2.fits')
-
- imagefiles()
zz zz2
-
- imagefiles(foreign=T)
zz zz2 zz2.fits
- imagefiles(stripppath=F)
/u/nkilleen/zz /u/nkilleen/zz2
-
- imagefiles('./*2')                   # Wild card file name
zz2
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{imagetools}{Find the list of current global image tools}
\begin{ahargs}
\ahaddarg[in]{showname}{Show name of image assocoated with tool}{F}{T or F}
\ahaddarg[in]{showclosed}{Include tool in list even if closed}{T}{T or F}
\end{ahargs}


\ahreturns{Vector of Strings}
\begin{ahdescription}

This (global) function retuns a list of the names of the image
\tools\ currently in Global name space.  You can optionally list the
names of the images (in parentheses) associated with the Image tools 
as well.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im1:=image('myimage')              
- im2 := imagefromshape(shape=[10,10])
-
- imagetools()
im1 im2
- imagetools(showname=T)
im1(myimage) im2(Temporary_Image)
- im2.close()
- imagetools(showclosed=F)
im1
- imagedones()
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{imagedones}{Done all global or specified Image tools}
\begin{ahargs}
  \ahaddarg[in]{which}{Which Image tools to destroy}{All global Image tools}{String or vector of strings}
\end{ahargs}
\ahreturns{T or F}

\begin{ahdescription}

This (global) function applies the \ahlink{done}{images:image.done} function to
the specified Image \tools\ currently in Global name space.
By default it destroys all Image \tools.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im1 := image('myimage1')              
- im2 := image('myimage2')
- imagetools()
im1 im2
- imagedones();
Done applied to image tool "im1"
Done applied to image tool "im2"
#
- im1 := image('myimage1')              
- im2 := image('myimage2')
- im3 := image('myimage3')
- imagedones("im1 im3")
Done applied to image tool "im1"
Done applied to image tool "im3"
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{imagedemo}{Demonstrate the use of an image}
\begin{ahdescription}

Demonstrate the use of the image class.  This tool function is extremely
rudimentary at the moment.  It creates an image on disk called
``demoimage.image'' of shape [10,20,5] and filled with zeros.  It then
works through this image one plane at a time replacing the pixel values
of that plane with the plane number.  It then statistics evaluated over
each plane.  Finally, the image is converted to a FITS file called
``DEMOIMAGE.FITS''

\ahreturns{Bool - T means success}
\end{ahdescription}


\begin{ahfunction}{imagetest}{Run test suite for Image tool}
\begin{ahargs}
  \ahaddarg[in]{which}{Which test to run}{All tests}{Integer or vector of integers}
\end{ahargs}
\ahreturns{T or F}

\begin{ahdescription}

Self-test of the Image \tool.  This function is quite extensive and
includes forced errors.  As long as the function finally returns with a
{\cf T}, it has succeeded (regardless of what error messages you might
see). 

The function invokes many tests.  The first one is a general test of
everything at a basic level.  The succeeding tests work on individual
areas of the image module. 

To run a specific test, you can use the {\stfaf which} argument.  Since
the number of tests keeps growing, we don't tell you how many there are
here or what exactly they do ! If you give too large a value, nothing
will happen.  {\stfaf which} can be an integer or a vector of integers. 


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- imagetest()
\end{verbatim}

Runs all tests.
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- imagetest(10)
\end{verbatim}

Runs test 10 only.
\end{ahexample}
\end{ahfunction}


\end{document}

