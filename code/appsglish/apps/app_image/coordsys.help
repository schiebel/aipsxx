]%% Copyright (C) 1999,2000,2001,2002,2003
%% Associated Universities, Inc. Washington DC, USA.
%%
%% This library is free software; you can redistribute it and/or modify it
%% under the terms of the GNU Library General Public License as published by
%% the Free Software Foundation; either version 2 of the License, or (at your
%% option) any later version.
%%
%% This library is distributed in the hope that it will be useful, but WITHOUT
%% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
%% License for more details.
%%
%% You should have received a copy of the GNU Library General Public License
%% along with this library; if not, write to the Free Software Foundation,
%% Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
%%
%% Correspondence concerning AIPS++ should be addressed as follows:
%%        Internet email: aips2-request@nrao.edu.
%%        Postal address: AIPS++ Project Office
%%                        National Radio Astronomy Observatory
%%                        520 Edgemont Road
%%                        Charlottesville, VA 22903-2475 USA
%%
%% $Id: 
\documentclass{article}
\usepackage{aips2help,html}
\begin{document}
%%
%%--------------------------------------------------------------------------
%%
%% Tool template
%%
%%--------------------------------------------------------------------------
%%

\begin{ahobject}{coordsys}{Operations on CoordinateSystems}

\ahinclude{coordsys.g}

\ahcategory{image}

   %
   %ahkeyword registers module keywords
   %
\ahkeyword{coordinates}{}
\ahkeyword{image}{}
\ahkeyword{measures}{}
\ahkeyword{quanta}{}
\ahmethods{}


%
%

\medskip
\noindent{\bf Summary}

A Coordsys \tool\ is used to store and manipulate a Coordinate System
(we will use the term `Coordinate System' interchangeably with `Coordsys
\tool'). A Coordinate System is a collection of coordinates, such as a
direction coordinate (E.g. RA/DEC), or a spectral coordinate (e.g. an
LSRK frequency).  

The main job of the Coordsys \tool\ is to convert between absolute pixel and world
(physical) coordinates.  It also supports relative pixel and world coordinates
(relative to reference location).

A Coordinate System is generally associated with an image (manipulated
via an \ahlink{Image}{images:image} \tool) but can also exist in its own
right.  An image is basically just a regular lattice of pixels plus a
Coordinate System describing the mapping from pixel coordinate to world
(or physical) coordinate.

Each coordinate is associated with a number of axes.  For example, a
direction coordinate has two coupled axes; a longitude and a latitude. 
A spectral coordinate has one axis.  A linear coordinate can have an
arbitrary number of axes, but they are all uncoupled.   The Coordinate
System actually maintains two kinds of axes; pixel axes and world
axes.    

As well as the coordinates, there is some extra information stored in
the Coordinate System.  This consists of the telescope, the epoch (date
of observation), and the highly influential observer's name.   The
telescope (i.e. position on earth) and epoch are important if you want
to, say, change a spectral coordinate from LSRK to TOPO.  

For general discussion about celestial coordinate systems, see the
papers by Mark Calabretta and Eric Greisen.
Background on the WCS system and relevant papers (including the
papers published in 
\begin{verbatim}
A&A 2002, 1061-1075 and 1077-1122
\end{verbatim}
can be found 
\htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.
Note that the actual system implemented originally in \aipspp\ was
based on a 1996 draft of these papers. The final papers are being
implemented while new version of the defining library become
available.

\bigskip
\noindent {\label{COORDSYS:FORMATTING} \bf Coordinate formatting}

Many of the Coordsys \tool\ functions use a world coordinate value
as an argument.  This world value can be formatted in many ways.

Some functions (e.g.  \ahlink{toworld}{images:coordsys.toworld}) have a function
argument called {\stfaf format} which takes a string.  This controls 
the format in which the coordinate is output and hence possibly input 
into some other function.


Possibilities for {\stfaf format} are :

\begin{itemize}

\item 'n' - means the world coordinate is given as a numeric vector (actually doubles).
The units are implicitly those returned by function \ahlink{units}{images:coordsys.units}.

\item 'q' - means the world coordinate is given as a vector of quantities
(value and unit) - see the \ahlink{quanta}{quanta} module.  If there
is only one axis (e.g. spectral coordinate), you will get
a single quantum only.

\item 'm' - means the world coordinate is given as a record
of measures - see the \ahlink{measures}{measures:measures} module.

The record consists of fields named from from {\cf direction}, 
{\cf spectral}, {\cf stokes}, {\cf linear}, and {\cf tabular},
depending upon which coordinate types are present in the Coordinate System.

The {\cf direction} field holds a \ahlink{direction}{measures:measures.direction}
measure.    

The {\cf spectral} field holds further subfields  {\cf frequency}, {\cf
radiovelocity}, {\cf opticalvelocity}, {\cf betavelocity}. The {\cf
frequency} subfield holds an
\ahlink{frequency}{measures:measures.frequency} measure. The {\cf
radiovelocity} subfield holds a
\ahlink{doppler}{measures:measures.doppler} measure using the radio
velocity definition. The {\cf opticalvelocity} subfield holds a
\ahlink{doppler}{measures:measures.doppler} measure using the optical
velocity definition. The {\cf betavelocity} subfield holds a
\ahlink{doppler}{measures:measures.doppler} measure using the true or
beta velocity definition.

The {\cf stokes} field just holds a string giving the Stokes type
(not a real measure).  

The {\cf linear} and {\cf tabular} fields hold a vector of quanta (not a real measure).

\item 's' - means the the world coordinate is given as a vector of formatted strings

\end{itemize}

You can give any combination of the allowed letters when using the
{\stfaf format}  argument. If you supply one letter the coordinate is as
described above. If you supply more than one letter, the coordinate is
given as a record, with possible fields 'numeric', 'quantity', 'measure'
and 'string' where each of these fields is given as described above.

\bigskip There are functions \ahlink{torel}{images:coordsys.torel} and
\ahlink{toabs}{images:coordsys.toabs} used to inter-convert between
absolute and relative world and pixel coordinates.   These functions
have an argument {\stfaf isworld} whereby you can specify whether the
coordinate is a pixel coordinate or a world coordinate.    In general,
you should not need to use this argument because any coordinate variable
generated by Coordsys \tool\ functions 'knows' whether it is absolute or
relative, world or pixel (uses a \glish\ attribute).  However, you may
be inputting a coordinate variable which you have generated in some
other way, and then you may need this.



\bigskip
\noindent {\bf Stokes Coordinates}

Stokes axes don't fit very well into our Coordinate model since
they are not interpolatable.   The alternative to having a Stokes
Coordinate is having a Stokes pixel type (like double, complex).  Both
have their good and bad points.  We have chosen to use a Stokes
Coordinate.  

With the Stokes Coordinate, any absolute pixel coordinate value must be in the
range of 1 to $nStokes$, where $nStokes$ is the number of Stokes types in
the Coordinate.

We define relative world coordinates for a Stokes axis to be the same as absolute
world coordinates (it makes no sense to think of a relative value
$XY - XX$ say).

You can use the specialized functions 
\ahlink{stokes}{images:coordsys.stokes}  and
\ahlink{setstokes}{images:coordsys.setstokes}  to recover and set new
Stokes values in the Stokes Coordinate.



\bigskip
\noindent {\label{COORDSYS:PWAXES} \bf World and Pixel axes}

The Coordinate System maintains what it calls pixel and world axes.  The
pixel axis is associated with, say, the axes of a lattice of pixels. 
The world axes describe notional world axes, generally in the same order
 as the pixel axes.  However, they may be different.  Imagine that a 3-D
image is collapsed along one axis.  The resultant image has 2 pixel
axes.  However, we can maintain the world coordinate for the collapsed
axis (so we know the coordinate value still).  Thus we have three world
axes and two pixel axes.  It is also possible for the C++ programmer to
reorder these pixel and world axes.  However, this is strongly
discouraged, and you should never actually encounter a situation where
the pixel and world axes are in different orders, but you may encounter
cases where the number of world and pixela axes is different.

For those of us (\aipspp\ programmers) writing robust scripts, we must
account for these possibilities, although the user really shouldn't
bother.  This, the {\stfaf pixel} and {\stfaf world} vectors return the
pixel and world axes of the found coordinate.

The functions 
\ahlink{referencevalue}{images:coordsys.referencevalue},
\ahlink{increment}{images:coordsys.increment},
\ahlink{units}{images:coordsys.units}, and
\ahlink{names}{images:coordsys.names} return their vectors in world axis
order.  However, function
\ahlink{referencepixel}{images:coordsys.referencepixel} returns in pixel
axis order (and the world vectors might have more values than the
referencepixel vector).




\bigskip
{\bf Overview of Coordsys tool functions}


\begin{itemize}


\item {\bf Get/set - } Functions to get and set various items within the
Coordinate System are 

\begin{itemize}

% functions parentname and setparentname are not documented as the user should not need them
% and will just confuse them

\item \ahlink{referencepixel}{images:coordsys.referencepixel} - get the reference pixel

\item \ahlink{setreferencepixel}{images:coordsys.setreferencepixel} - set the reference pixel

\item \ahlink{referencevalue}{images:coordsys.referencevalue} - get the reference value

\item \ahlink{setreferencevalue}{images:coordsys.setreferencevalue} - set the reference value

\item \ahlink{setreferencelocation}{images:coordsys.setreferencelocation} - Set reference pixel and value
to these values

\item \ahlink{increment}{images:coordsys.increment} - get axis increments

\item \ahlink{setincrement}{images:coordsys.setincrement} - set axis increments

\item \ahlink{lineartransform}{images:coordsys.lineartransform} - get linear transform

\item \ahlink{setlineartransform}{images:coordsys.setlineartransform} - set linear transform

\item \ahlink{names}{images:coordsys.names} - get axis names

\item \ahlink{setnames}{images:coordsys.setnames} - set axis names

\item \ahlink{units}{images:coordsys.units} - get axis units

\item \ahlink{setunits}{images:coordsys.setunits} - set axis units

\item \ahlink{stokes}{images:coordsys.stokes} - get Stokes values

\item \ahlink{setdirection}{images:coordsys.setdirection} - set Direction coordinate values

\item \ahlink{setstokes}{images:coordsys.setstokes} - set Stokes values

\item \ahlink{setspectral}{images:coordsys.setspectral} - set Spectral coordinate tabular values

\item \ahlink{settabular}{images:coordsys.settabular} - set Tabular coordinate tabular values

\item \ahlink{projection}{images:coordsys.projection} - get direction coordinate projection

\item \ahlink{setprojection}{images:coordsys.setprojection} - set direction coordinate projection

\item \ahlink{referencecode}{images:coordsys.referencecode} - get reference codes

\item \ahlink{setreferencecode}{images:coordsys.setreferencecode} - set reference codes

\item \ahlink{restfrequency}{images:coordsys.restfrequency} - get the spectral coordinate rest frequency

\item \ahlink{setrestfrequency}{images:coordsys.setrestfrequency} - set the spectral coordinate rest frequency

\item \ahlink{epoch}{images:coordsys.epoch} - get the epoch of observation

\item \ahlink{setepoch}{images:coordsys.setepoch} - set the epoch of observation

\item \ahlink{telescope}{images:coordsys.telescope} - get the telecope of the observation

\item \ahlink{settelescope}{images:coordsys.settelescope} - set the telecope of the observation

\item \ahlink{observer}{images:coordsys.observer} - get observer name

\item \ahlink{setobserver}{images:coordsys.setobserver} - set observer name

\end{itemize}




\item {\bf Utility - }  There is a range of utility services available through the functions

\begin{itemize}

% Multiple coordinates of the same type not well supported so not advertised yet.
%\item \ahlink{addcoordinate}{images:coordsys.addcoordinate} - add a new default coordinate 

\item \ahlink{axesmap}{images:coordsys.axesmap} - get mapping between
pixel and world axes order

\item \ahlink{axiscoordinatetypes}{images:coordsys.axiscoordinatetypes} - get type
of coordinate for each axis

\item \ahlink{coordinatetype}{images:coordsys.coordinatetype} - get type
of coordinates

\item \ahlink{copy}{images:coordsys.copy} - make a copy of this tool

\item \ahlink{done}{images:coordsys.done} - destroy this \tool\

\item \ahlink{findaxis}{images:coordsys.findaxis} - find specified axis (by number) in
coordinate system

\item \ahlink{findcoordinate}{images:coordsys.findcoordinate} - find specified (by number) coordinate 

\item \ahlink{fromrecord}{images:coordsys.fromrecord} - set Coordinate System from a \glish\ record

\item \ahlink{id}{images:coordsys.id} - get the fundamental identifier of this \tool\

\item \ahlink{naxes}{images:coordsys.naxes} - get number of axes

\item \ahlink{ncoordinates}{images:coordsys.ncoordinates} - get the number of coordinates

%\item \ahlink{replace}{images:coordsys.replace} - replace one coordinate from another Coordinate System

\item \ahlink{reorder}{images:coordsys.reorder} - reorder coordinates

\item \ahlink{summary}{images:coordsys.summary} - summarize the Coordinate System

\item \ahlink{torecord}{images:coordsys.torecord} - Convert a Coordinate SYstem to a \glish\ record

\item \ahlink{type}{images:coordsys.type} - the type of this \tool\

\end{itemize}



\item {\bf Coordinate conversion}

\begin{itemize}

\item \ahlink{convert}{images:coordsys.convert} - Convert one numeric coordinate with mixed input and output formats (abs/rel/world/pixel) 

\item \ahlink{toabs}{images:coordsys.toabs} - Convert a relative coordinate to an absolute coordinate

\item \ahlink{topixel}{images:coordsys.topixel} - Convert from absolute world coordinate to absolute pixel coordinate

\item \ahlink{torel}{images:coordsys.torel} - Convert an absolute coordinate to a relative coordinate

\item \ahlink{toworld}{images:coordsys.toworld} - Convert from an absolute pixel coordinate to an absolute world coordinate

\item \ahlink{convertmany}{images:coordsys.convertmany} - Convert many numeric coordinates with mixed input and output formats (abs/rel/world/pixel) 

\item \ahlink{toabsmany}{images:coordsys.toabsmany} - Convert many relative coordinates to absolute coordinates

\item \ahlink{topixelmany}{images:coordsys.topixelmany} - Convert many absolute world coordinates to absolute pixel coordinates

\item \ahlink{torelmany}{images:coordsys.torelmany} - Convert many absolute coordinates to relative coordinates

\item \ahlink{toworldmany}{images:coordsys.toworldmany} - Convert many absolute pixel coordinates to absolute world coordinates

\item \ahlink{frequencytovelocity}{images:coordsys.frequencytovelocity} - Convert from frequency to velocity

\item \ahlink{frequencytofrequency}{images:coordsys.frequencytofrequency} - Convert from frequency to frequency via a velocity offset

\item \ahlink{velocitytofrequency}{images:coordsys.velocitytofrequency} - Convert from velocity to frequency

\item \ahlink{setconversiontype}{images:coordsys.setconversiontype} - Set extra reference frame conversion layer

\item \ahlink{conversiontype}{images:coordsys.conversiontype} - Recover extra reference frame conversion types

\end{itemize}




\item {\bf Tests - }  

\begin{itemize}

\item \ahlink{coordsystest}{images:coordsystest} - Run test suite for Coordsys \tool\

\end{itemize}


\end{itemize}



\bigskip
\noindent{\bf Events}

There are no events emitted or acted upon by this \tool.



\begin{ahexample} 
include 'coordsys.g'
\begin{verbatim}
cs := coordsys(direction=T, linear=2)
cs.summary()

\end{verbatim}
\end{ahexample}



\begin{ahconstructor}{coordsys}{Create a default coordsys tool}
\begin{ahargs}  
  \ahaddarg[in]{direction}{Make a direction coordinate ?}{F}{Bool}  
  \ahaddarg[in]{spectral}{Make a spectral coordinate ?}{F}{Bool}
  \ahaddarg[in]{stokes}{Make a Stokes coordinate with these Stokes}{""}{String or vector of Strings}
  \ahaddarg[in]{linear}{Make a linear coordinate with this many axes}{0}{Integer}
  \ahaddarg[in]{tabular}{Make a tabular coordinate}{F}{Bool}
\end{ahargs}    
\ahreturns{Coordsys\ \tool\ or fail}

\begin{ahdescription}

By default, this constructor makes an empty Coordsys \tool.  You can ask
it to include various sorts of coordinates through the arguments. 
Except for Stokes, you don't have any control over the coordinate
contents (e.g.  reference value etc.) it does make for you on request. 
But you can edit the Coordinate System after creation if you wish. 

If you wish to make a Stokes coordinate, then you assign
{\stfaf stokes} to a string (or a vector of strings) saying
which Stokes you want.  \aipspp\ allows rather
a lot of potential Stokes types.  

Probably most useful is some combination of the
basic I, Q, U, V, XX, YY, XY, YX, RR, LL, RL, and LR.

However, a more esoteric choice is also possible:
RX, RY, LX, LY, XR, XL, YR, YL (these are mixed
linear and circular),  PP, PQ, QP, QQ (general quasi-orthogonal correlation products)
RCircular, LCircular, Linear  (single dish polarization types).

You can also specify some polarization `Stokes' types:
Ptotal (Polarized intensity (($Q^2+U^2+V^2)^(1/2)$),
Plinear (Linearly Polarized intensity ($(Q^2+U^2)^(1/2)$),
PFtotal (Polarization Fraction (Ptotal/I)), 
PFlinear  (Linear Polarization Fraction (Plinear/I)), and
Pangle  (Linear Polarization Angle ($0.5 arctan(U/Q)$ in radians)).

Probably you will find the more unusual types aren't fully
supported throughout the system.

You can make a LinearCoordinate with as many uncoupled axes as you like.
Thus, {\stfaf linear=2} makes one LinearCoordinate with 2 axes (think
of it like a DirectionCoordinate which also has 2 axes [but coupled in
this case], a longitude and a latitude).

If you make a TabularCoordinate, it is linear to start with.
You can change it to a non-linear one by providing
a list of pixel and world values to function
\ahlink{settabular}{images:coordsys.settabular}.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- cs.ncoordinates()
0
- cs.done()
- cs
F
#
- cs2 := coordsys(direction=T, stokes='I V');
- cs2.ncoordinates()
2
- cs2.coordinatetype()
Direction Stokes
#
- cs2.summary()
Direction system : J2000
Telescope        : ATCA
Observer         : Karl Jansky
Date observation : 2000/07/03/08:10:57

Axis Type      Name             Proj   Coord value at pixel    Coord incr Units
------------------------------------------------------------------------------- 
1    Direction Right Ascension   SIN  00:00:00.000     1.00 -6.000000e+01 arcsec
2    Direction Declination       SIN +00.00.00.000     1.00  6.000000e+01 arcsec
3    Stokes    Stokes                           IV

\end{verbatim}
The second Coordinate System contains a direction coordinate
and a Stokes coordinate.   This means that there are three `axes'
associated with the 2 coordinates.

\end{ahexample}
\end{ahconstructor}
 



%%% Functions


% This function allows multiple coordinates of the same type which
% are not well supported.
%\begin{ahfunction}{addcoordinate}{Add default coordinates}
%\begin{ahargs}  
%  \ahaddarg[in]{direction}{Add a direction coordinate ?}{F}{Bool}  
%  \ahaddarg[in]{spectral}{Add a spectral coordinate ?}{F}{Bool}
%  \ahaddarg[in]{stokes}{Add a Stokes coordinate with these Stokes}{""}{String or vector of Strings}f%
%  \ahaddarg[in]{linear}{Add a linear coordinate with this many axes}{0}{Integer}
%  \ahaddarg[in]{tabular}{Add a tabular coordinate}{F}{Bool}
%\end{ahargs}    
%\ahreturns{T or fail}
%
%\begin{ahdescription}
%Add default coordinates of the specified types.
%\end{ahdescription}
%
%\begin{ahexample}
%\begin{verbatim}
%- cs := coordsys()
%- cs.addcoordinate(direction=T)
%\end{verbatim}
%\end{ahexample}
%\end{ahconstructor}
 



\begin{ahfunction}{axesmap}{Find mapping between world and pixel axes}
\begin{ahargs}
  \ahaddarg[in]{toworld}{Map from pixel to world ?}{T}{T or F}
\end{ahargs}

\ahreturns{Vector of Int or fail}
\begin{ahdescription}

This function returns a vector describing the mapping from pixel to
world or world to pixel axes.  It is not for general user use.

See the \htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
ordering.  Generally they will be in the same order.


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- cs.axesmap(T);
[1 2 3]
- cs.axesmap(F);
[1 2 3]
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{axiscoordinatetypes}{Return types of coordinates for each axis}
\begin{ahargs}
  \ahaddarg[in]{world}{World or pixel axes ?}{T}{T or F}
\end{ahargs}

\ahreturns{Vector of strings or fail}
\begin{ahdescription}

This function (short-hand name {\stff act}) returns a vector string 
giving the coordinate type for each axis (world or pixel)
in the Coordinate System.

See the \htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
ordering.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- cs.axiscoordinatetypes()
Direction Direction Spectral
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{conversiontype}{Get extra reference conversion layer}
\begin{ahargs}
  \ahaddarg[in]{type}{Coordinate type}{}{String from 'direction', 'spectral'}
\end{ahargs}

\ahreturns{String or fail}

\begin{ahdescription}

Some coordinates contain a reference code.  Examples of reference codes
are B1950 and J2000 for direction coordinates, or LSRK and BARY for
spectral coordinates.  When you do conversions between pixel and world
coordinate, the coordinates are in the reference frame corresponding to
these codes.   

Function  \ahlink{setconversiontype}{images:coordsys.setconversiontype}
allows you to specify a different reference frame
which is used when converting between world and pixel coordinate.

This function allows you to recover those conversion types.  If no extra
conversion layer has been set, you get back the native reference types.

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- print cs.conversiontype (type='direction'), ' ', cs.conversiontype (type='spectral'), 
J2000 LSRK
-
- cs.setconversiontype (direction='GALACTIC', spectral='BARY');
- print cs.conversiontype (type='direction'), ' ', cs.conversiontype (type='spectral'), 
GALACTIC BARY
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\end{ahdescription}
\end{ahfunction}







\begin{ahfunction}{convert}{Convert a numeric mixed coordinate }
\begin{ahargs}
\ahaddarg[in]{coordin}{Input coordinate}{}{Numeric vector}
\ahaddarg[in]{absin}{Are input coordinate elements absolute ?}{All T}{Boolean vector}
\ahaddarg[in]{dopplerin}{Input doppler type for velocities}{'radio'}{String}
\ahaddarg[in]{unitsin}{Input units}{Native}{String vector}
\ahaddarg[in]{absout}{Are output coordinate elements absolute ?}{All T}{Boolean vector}
\ahaddarg[in]{dopplerout}{Output doppler type for velocities}{'radio'}{String}
\ahaddarg[in]{unitsout}{Output units}{Native}{String vector}
\ahaddarg[in]{shape}{Image shape}{Unused}{Integer vector}
\end{ahargs}
\ahreturns{Numeric vector or fail}

\begin{ahdescription}

This function converts between mixed pixel/world/abs/rel numeric
coordinates.  The input and output coordinates are specified via a 
numeric vector giving coordinate values, a string vector giving units, a
boolean vector specifying whether the coordinate is absolute or relative
(to the reference pixel) and doppler strings specifying the doppler
convention for velocities.

The units string may include {\cf pix} for pixel coordinates and
velocity units (i.e. any unit consistent with {\cf m/s}).

The allowed doppler strings and definition are described
in function \ahlink{summary}{images:image.summary}.

The {\stfaf shape} argument is optional.  If your Coordinate
System from an image, then assign the image shape to this
argument.  It is used only when making mixed (pixel/world) conversions
for Direction Coordinates to resolve ambiguity.

The example will make the use of this function clear.


\end{ahdescription}



\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)    # 3 axes
-
- cout := cs.convert (coordin=[10,20,30],
                      absin=[T,T,T],
                      unitsin="pix pix pix",
                      absout=[T,F,T],
                      dopplerout='optical',
                      unitsout="pix arcsec km/s");
-
- print 'cout=', cout
[10 1140.0058 1134.82336]
\end{verbatim}
In this example we convert from a vector of absolute pixels
to a mixture of pixel/world and abs/rel.
\end{ahexample}

\end{ahfunction}



\begin{ahfunction}{convertmany}{Convert many numeric mixed coordinates}
\begin{ahargs}
\ahaddarg[in]{coordin}{Input coordinate}{}{Numeric matrix}
\ahaddarg[in]{absin}{Are input coordinate elements absolute ?}{All T}{Boolean vector}
\ahaddarg[in]{dopplerin}{Input doppler type for velocities}{'radio'}{String}
\ahaddarg[in]{unitsin}{Input units}{Native}{String vector}
\ahaddarg[in]{absout}{Are output coordinate elements absolute ?}{All T}{Boolean vector}
\ahaddarg[in]{dopplerout}{Output doppler type for velocities}{'radio'}{String}
\ahaddarg[in]{unitsout}{Output units}{Native}{String vector}
\ahaddarg[in]{shape}{Image shape}{Unused}{Integer vector}
\end{ahargs}
\ahreturns{Numeric matrix or fail}

\begin{ahdescription}

This function converts between many mixed pixel/world/abs/rel numeric
coordinates.   See function \ahlink{convert}{images:coordsys.convert}
for more information.

The only diffference with that function is that you
provide a matrix holding many coordinates to convert
and a matrix of many converted coordinates is returned.


\end{ahdescription}



\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)    # 3 axes
-
- p := [15,20,30];                           # absolute pixel coordinate
- cin := array (p, 3, 10);                   # 10 conversions each of length 3
- cin[3,] := 1:10;                           # spectral pixel runs from 1 to 10
- cin
[[1:3,]
    15 15 15 15 15 15 15 15 15 15
    20 20 20 20 20 20 20 20 20 20
    1  2  3  4  5  6  7  8  9  10] 
-
- cout := cs.convertmany (coordin=cin,     
                          absin=[T,T,T],
                          unitsin="pix pix pix",
                          absout=[T,F,T],
                          dopplerout='optical',
                          unitsout="pix deg km/s");
-
- cout
[[1:3,]
    15          15          15          15          15          15          15          15          15          15
    0.316668279 0.316668279 0.316668279 0.316668279 0.316668279 0.316668279 0.316668279 0.316668279 0.316668279 0.316668279
    1145.30291  1145.09023  1144.87756  1144.66488  1144.4522   1144.23953  1144.02685  1143.81418  1143.6015   1143.38883] 
-
- cout[,1]                                     # First coordinate
[15 0.316668279 1145.30291] 
-
- cout[,10]                                    # 10th coordinate
[15 0.316668279 1143.38883]  
\end{verbatim}
\end{ahexample}

\end{ahfunction}





\begin{ahfunction}{coordinatetype}{Return type of specified coordinate}
\begin{ahargs}
  \ahaddarg[in]{which}{Which coordinate ?}{All}{1-rel integer or unset}
\end{ahargs}

\ahreturns{String or fail}
\begin{ahdescription}

This function (short-hand name {\stff ct}) returns a string describing
the type of the specified coordinate.  If {\stfaf which=unset} the types
for all coordinates are returned.

Possible output values are 'Direction', 'Spectral', 'Stokes', 'Linear', and
'Tabular'


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- cs.coordinatetype(1)
Direction
- cs.coordinatetype()
Direction Spectral
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{copy}{Copy this Coordsys tool}
\ahreturns{Coordsys tool or fail}
\begin{ahdescription}

\glish\ uses copy-on-write semantics.  This sometimes
means that it maintains a reference between variables
that you would rather it didn't.

This function returns a copy, not a reference, of the Coordsys \tool.
It is your responsibility to call the {\stff done} function
on the new \tool.

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- cs2 := cs             # Reference
- cs.done()
- cs
F
- cs2                   # cs2 gets doned when c2 does
F 
-
- cs := coordsys()
- cs2 := cs.copy()      # Copy
- cs.done()
- cs
F
- cs2
ref [busy=<function>, result=<function>,...   # cs2 is still viable
- cs2.done()
- cs2                   # Now it's done
F
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{done}{Destroy this Coordsys tool}
\ahreturns{T or fail}
\begin{ahdescription}

If you no longer need to use a Coordsys \tool, calling this function
will free up its resources.  That is, it destroys the \tool.  You can no
longer call any functions on the \tool\ after it has been {\stff done}. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- cs.done()
- cs
F
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{epoch}{Return the epoch}
\ahreturns{Epoch measure or fail}

\begin{ahdescription}

This function (short-hand name {\stff e}) returns the epoch of the observation as a
\ahlink{Measure}{measures:measures.epoch}.  You can format it with
\ahlink{quanta}{quanta:quanta}


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- ep := cs.epoch()
- ep
[type=epoch, refer=UTC, m0=[value=51728.4578, unit=d]] 
-
- time := dm.getvalue(ep)           # Extract time with measures
- dq.time(time)                     # Format with quanta
10:59:10.170 
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{findaxis}{Find specified axis in coordinate system}
\begin{ahargs}  
  \ahaddarg[out]{coordinate}{Coordinate number}{}{Integer}
  \ahaddarg[out]{axisincoordinate}{Axis in the coordinate}{}{Integer}
  \ahaddarg[in]{world}{is axis a world or pixel axis ?}{T}{Bool}
  \ahaddarg[in]{axis}{Axis in coordinate system}{1}{Integer}
\end{ahargs}    
\ahreturns{T, F or fail}
  
\begin{ahdescription}

This function (short-hand name {\stf fa}) finds the specified axis in
the Coordinate System. If the axis does not exist, it returns F (not
fail).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, linear=2)          # RA/DEC/Lin1/Lin2
- local coord, axisincoord;
- cs.findcoordinate(coord, axisincoord, T, 2)    # DEC
- print coord, axisincoord
1 2
- cs.findcoordinate(coord, axisincoord, T, 3)    # Lin1
- print coord, axisincoord
2 1
\end{verbatim}

In these examples, the Coordinate System has 4 axes (both world and
pixel the same).  The first example finds the DEC axis (coordinate
system axis 2) to be the second axis of the Direction Coordinate
(coordinate 1). The second example finds the first linear axis
(coordinate system axis 3)  to be the first axis of the Linear
Coordinate (coordinate 2).

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{findcoordinate}{Find axes of specified coordinate}
\begin{ahargs}  
  \ahaddarg[out]{pixel}{Pixel axes}{}{Vector of integers}
  \ahaddarg[out]{world}{World axes}{}{Vector of integers}
  \ahaddarg[in]{type}{Type of coordinate to find}{"direction"}
           {String from "direction", "stokes", "spectral", "linear", "tabular"}
  \ahaddarg[in]{which}{Which coordinate if more than one}{First (1)}{Integer}
\end{ahargs}    
\ahreturns{T, F or fail}
  
\begin{ahdescription}

This function (short-hand name {\stf fc}) finds the axes in the
Coordinate System for the specified coordinate (minimum match is active
for argument {\stfaf type}).  By default it finds the first coordinate,
but if there is more than one (can happen for linear coordinates), you
can specify which.  If the coordinate does not exist, it returns F (not
fail).


See also the function \ahlink{axesmap}{images:coordsys.axesmap}
which returns the mapping between pixel and world axes.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T)
- local pa, wa;
- cs.findcoordinate(pa, wa, 'direction')
- print 'pixel, world axes =', pa, wa
pixel, world axes = [1 2] [1 2]
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{frequencytofrequency}{Convert frequency to frequency with an offset}
\begin{ahargs}  
  \ahaddarg[in]{value}{Frequency to convert}{}{Numeric or vector of numeric}
  \ahaddarg[in]{frequnit}{Unit of input frequencies}{Intrinsic units}{String}
  \ahaddarg[in]{velocity}{Velocity offset}{None}{Quantity}  
  \ahaddarg[in]{doppler}{Velocity doppler definition}{'radio'}{String}   
\end{ahargs}    
\ahreturns{Double or vector of double or fail}
  
\begin{ahdescription}

This function (short-hand name {\stf ftf}) converts frequencies to
frequencies by applying (subtracting) a velocity offset. 

The input frequencies are specified via a vector of numeric values and a
specified unit ({\stfaf frequnit}).  If you don't give a frequency unit,
it is assumed that the units are those given by function
\ahlink{units}{images:coordsys.units} for the spectral coordinate.

This function does not make any frame conversions (e.g.  LSR to BARY)
but you can specifiy the velocity doppler definition for the velocity
via the {\stfaf doppler} argument (see
\ahlink{summary}{images:image.summary} for possible values). 

This function will return a fail if there is no spectral coordinate
in the Coordinate System. See also function
\ahlink{frequencytovelocity}{images:coordsys.frequencytovelocity}.

This function presently uses an approximation only valid for velocities
less than the speed of light.  The correction tends to zero as the
velocity appraches the speed of light. You will get NaNs for larger
values of the velocity.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(spectral=T)
- idx := 1 + 0.1*(1:5)
- rv := cs.referencevalue()
- freq := idx * rv
-
- print 'In = ', freq
[1.5565e+09 1.698e+09 1.8395e+09 1.981e+09 2.1225e+09]  
-
- print cs.frequencytofrequency(freq, velocity='100km/s')
[1.55598089e+09 1.6974337e+09 1.83888651e+09 1.98033932e+09 2.12179213e+09] 

\end{verbatim}

\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{frequencytovelocity}{Convert frequency to velocity}
\begin{ahargs}  
  \ahaddarg[in]{value}{Frequency to convert}{}{Numeric or vector of numeric}
  \ahaddarg[in]{frequnit}{Unit of input frequencies}{Intrinsic units}{String}
  \ahaddarg[in]{doppler}{Velocity doppler definition}{'radio'}{String}   
  \ahaddarg[in]{velunit}{Unit of output velocities}{'km/s'}{String}  
\end{ahargs}    
\ahreturns{Double or vector of double or fail}
  
\begin{ahdescription}

This function (short-hand name {\stf ftv}) converts frequencies to
velocities.  

The input frequencies are specified via a vector of numeric values and a
specified unit ({\stfaf frequnit}).  If you don't give a frequency unit,
it is assumed that the units are those given by function
\ahlink{units}{images:coordsys.units} for the spectral coordinate.

This function does not make any frame conversions (e.g. LSR to BARY)
but you can specifiy the velocity doppler definition via the {\stfaf doppler}
argument (see \ahlink{summary}{images:image.summary} for possible
values).

The velocities are returned in a vector for which you specify the
units ({\stfaf velunit} - default is km/s).

This function will return a fail if there is no spectral coordinate
in the Coordinate System. See also function
\ahlink{velocitytofrequency}{images:coordsys.velocitytofrequency}.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('hcn.cube')
- cs := im.coordsys()
-
- local pa, wa;
- cs.findcoordinate(pa, wa, 'spectral')     # Find spectral axis
- pixel := cs.referencepixel();             # Use reference pixel for non-spectral
-
- nFreq := im.shape()[pa[1]];               # Length of spectral axis
- freq := [];
- for (i in 1:nFreq) { 
    pixel[pa[1]] := i;                      # Assign value for spectral axis of pixel coordinate
    w := cs.toworld(value=pixel, format='n')# Convert pixel to world
    freq[i] := w[wa[1]];                    # Fish out frequency
  }
- vel := cs.frequencytovelocity(value=freq, doppler='optical', velunit='km/s')
- print vel
[137.868718 133.690916 129.513229 125.33566 121.158206 116.980869 
 112.803649 108.626544 104.449556 100.272685 96.0959294 91.9192905 
  87.7427679 83.5663616 79.3900717 75.213898 71.0378408 66.8618999 
  62.6860752 58.5103668 54.3347748 50.159299 45.9839395 41.8086963 
  37.6335694 33.4585588 29.2836644 25.1088863 20.9342244 16.7596788 
  12.5852495  8.41093638 4.23673952 0.0626588884 -4.11130551 -8.28515368 
 -12.4588856 -16.6325014 -20.8060009 -24.9793842 -29.1526513 -33.3258023 
 -37.498837 -41.6717555 -45.8445579 -50.0172441 -54.1898141 -58.3622679 
 -62.5346056 -66.7068272 -70.8789325 -75.0509218 -79.2227948 -83.3945518 
 -87.5661926 -91.7377173 -95.9091259 -100.080418 -104.251595 -108.422655 
-112.593599 -116.764427 -120.935139 -125.105735]  

\end{verbatim}

In this example, we find the optical velocity in km/s of every pixel
along the spectral axis of our image.  First we  obtain the Coordinate
System from the image.  Then we find which axis of the Coordinate System
(image) pertain to the spectral coordinate.  Then we loop over each
pixel of the spectral axis, and convert a pixel coordinate (one for each
axis of the image) to world.  We obtain the value for the spectral axis
from that world vector, and add it to the vector of frequencies.  Then
we convert that vector of frequencies to velocity.

\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{fromrecord}{Fill Coordinate System from a record}
\begin{ahargs}  
  \ahaddarg[in]{record}{Record containing Coordinate System}{}{Glish record}
\end{ahargs}    
\ahreturns{T or fail}
  
\begin{ahdescription}

You can convert a Coordinate System to a record
(\ahlink{torecord}{images:coordsys.torecord}).  This function
(fromrecord) allows you to set the contents of an existing Coordinate
System from such a record.   In doing so, you overwrite its current
contents.

These functions are not for general user use.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, stokes="I Q")
- cs.ncoordinates()
2
- r := cs.torecord()
-
- cs2 := coordsys()
- cs2.ncoordinates()
0
- cs2.fromrecord(r)
- cs2.ncoordinates()
2
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{id}{Return the fundamental identifier of this tool}
\begin{ahdescription}

This function should be of little interest to users. It returns the 
fundamental identifier of the \tool\ used in the tasking system.

\end{ahdescription}

\ahreturns{ToolID - a record}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- cs.id()
[sequence=5, pid=17277, time=962622872, host=phoenix, agentid=3] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{increment}{Recover the increments}
\begin{ahargs}
  \ahaddarg[in]{format}{Format string}{'n'}{String from combination of "n", "q", "s", "m"}
  \ahaddarg[in]{type}{Coordinate type}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
\end{ahargs}
\ahreturns{Vector of doubles, vector of quantities, vector of string, record or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a reference value,
reference pixel and an increment (per pixel).  These are used in the
mapping from pixel to world coordinate. 

This function (short-hand name {\stff i}) returns the increment (in
world axis order). You can recover  the increments either for all
coordinates (leave {\stfaf type} unset) or for a specific coordinate
type (mimumum match of the allowed types will do).  If you ask for a
non-existent coordinate an exception is generated.

See the \htmlref{discussion}{COORDSYS:FORMATTING} regarding the
formatting possibilities available via argument {\stfaf format}.

You can set the increment with function
\ahlink{setincrement}{images:coordsys.setincrement}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- cs.increment(format='q')
[__*0=[value=-1, unit='], __*1=[value=1, unit='], __*2=[value=1000, unit=Hz]] 
-
- cs.increment(format='n')
[-1 1 1000]  
-
- cs.increment(format='n', type='spectral')
1000
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{lineartransform}{Recover the linear transform matrix}
\begin{ahargs}
  \ahaddarg[in]{type}{Coordinate type}{}
           {String from "direction", "stokes", "spectral", "linear", "tabular"}
\end{ahargs}
\ahreturns{Vector of double or fail}

\begin{ahdescription}

Recover the linear transform component for the specified coordinate type.

You can set the linear transform with function
\ahlink{setlineartransform}{images:coordsys.setlineartransform}. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, linear=3)
- cs.lineartransform('dir')                  # 2 x 2
[[1:2,]
    1 0
    0 1]
- cs.lineartransform('lin')                  # 3 x 3
[[1:3,]
    1 0 0
    0 1 0
    0 0 1]
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{names}{Recover the names for each axis}
\begin{ahargs}
  \ahaddarg[in]{type}{Coordinate type}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
\end{ahargs}

\ahreturns{Vector of strings or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a name (they don't
mean anything fundamental).  This function returns those names in
world axis order.

You can recover the names either for all coordinates (leave {\stfaf
type} unset) or for a specific coordinate type (mimumum match of the
allowed types will do).  If you ask for a non-existent coordinate an
exception is generated.

You can set the names with function
\ahlink{setnames}{images:coordsys.setnames}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- n := cs.names(T)
- n[1]
Right Ascension 
- n[2]
Declination 
- n[3]
Frequency 
-
- cs.names('spec')
Frequency
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{naxes}{Recover the number of axes}
\begin{ahargs}
  \ahaddarg[in]{world}{Find number of world or pixel axes ?}{T}{T or F}
\end{ahargs}

\ahreturns{Int or fail}

\begin{ahdescription}

Find the number of axes  in the Coordinate System.

You may find the number of world or pixel axes; these are generally the
same and general users can ignore the distinction.  See the
\htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
ordering.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- n := cs.naxes(T)
3                          # 2 direction axes, 1 spectral
- n := cs.naxes(F)
3
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{ncoordinates}{Recover the number of coordinates in the Coordinate System}
\ahreturns{Integer or fail}

\begin{ahdescription}

This function (short-hand name {\stff nc}) recovers the number of
coordinates in the Coordinate System.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- cs.ncoordinates()
2
- cs2 := coordsys(linear=4)
- cs2.ncoordinates()
1
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\end{ahfunction}
\begin{ahfunction}{observer}{Return the name of the observer}
\ahreturns{String or fail}

\begin{ahdescription}

This function returns the name of the observer.
You can set it with the function \ahlink{setobserver}{images:coordsys.setobserver}.

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- cs.observer()
Karl Jansky
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{projection}{Recover the direction coordinate projection}
\begin{ahargs}
  \ahaddarg[in]{type}{Type of projection}{Current}{String}
\end{ahargs}

\ahreturns{Record, Vector string, Int or fail}


\begin{ahdescription}

If the Coordinate System contains a direction coordinate, this function
(short-hand name {\stff p}) can be used to recover information about the
projection.  For discussion about celestial coordinate systems,
including projections, see the papers by Mark Calabretta and Eric
Greisen. The initial draft  from 1996 (implemented in
\aipspp Background information can be
found
\htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.


What this function returns depends upon the value
you assign to {\stfaf type}.

\begin{itemize}

\item {\stfaf type=unset}.  In this case (the default), the actual
projection type and projection parameters are returned in a \glish\
record with fields {\cf type} and {\cf parameters}, respectively.

\item {\stfaf type='all'}.  In this case, a vector of strings
containing all of the possible projection codes is returned.

\item {\stfaf type=code}.  If you specify a valid
projection type code (see list by setting {\stfaf type='all'})
then what is returned is the number of parameters required
to describe that projection (useful in function
\ahlink{setprojection}{images:coordsys.setprojection}).

\end{itemize}

You can change the projection with
\ahlink{setprojection}{images:coordsys.setprojection}. 

If the Coordinate System does not contain a direction coordinate,
an exception is generated.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T)
- cs.projection()
[type=SIN, parameters=[0 0] ] 
-
- cs.projection('all')
AZP TAN SIN STG ARC ZPN ZEA AIR CYP CAR MER CEA COP 
COD COE COO BON PCO GLS PAR AIT MOL CSC QSC TSC 
-
- cs.projection('ZPN')
10 
\end{verbatim}
We first recover the projection type and parameters from
the direction coordinate.  Then we find the list of all
possible projection types.  FInally, we recover the number of 
parameters required to describe the 'ZPN' projection.
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{referencecode}{Return specified reference code}
\begin{ahargs}
  \ahaddarg[in]{type}{Which coordinate type ?}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
  \ahaddarg[in]{list}{List all possibilities ?}{F}{Bool}
\end{ahargs}
\ahreturns{Vector of strings, string or fail}

\begin{ahdescription}

This function (short-hand name {\stff rp}) returns the reference code
for all, or the specified coordinate type.    Examples of the reference
code are B1950 and J2000 for direction coordinates, or LSRK and BARY for
spectral coordinates.

If {\stfaf type} is left unset, then a vector of strings is returned,
one code for each coordinate type in the Coordinate System.

If you specify {\stfaf type} then select from
'direction', 'spectral', 'stokes', and 'linear'
(the first two letters will do).  However, only the first two
coordinate types will return a non-empty string.
If the Coordinate System does not contain a coordinate of
the type you specify, an exception is generated.

The argument {\stfaf list} is ignored unless you specify a specific {\stfaf type}. 
If {\stfaf list=T}, then this function returns the list of all possible
reference  codes for the specified coordinate type.  Otherwise, it just
returns the actual code current set in the Coordinate System.    

The list of all possible types is returned as a \glish\ record  (it is
actually generated by the 
\ahlink{listcodes}{measures:measures.listcodes} function in the
\ahlink{measures}{measures:measures} system). This record has two
fields.  These are called 'normal' 
(containing all normal codes) and 'extra' (maybe empty, with all extra
codes like planets). 

You can set the reference code with
\ahlink{setreferencecode}{images:coordsys.setreferencecode}. 
\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T)
- list := cs.referencecode('dir', T)
- list.normal[1:10]
J2000 JMEAN JTRUE APP B1950 BMEAN BTRUE GALACTIC HADEC AZEL 
-
- cs.referencecode('dir')
J2000
\end{verbatim}

In this example we first get the list of all possible reference codes
for a direction coordinate (and print some of the normal ones). Then we
get the actual reference code for the direction coordinate in our
Coordinate System.

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{referencepixel}{Recover the reference pixel}
\begin{ahargs}
  \ahaddarg[in]{type}{Coordinate type}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
\end{ahargs}
\ahreturns{Vector of double or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a reference value,
reference pixel and an increment (per pixel).  These are used in the
mapping from pixel to world coordinate. 

This function (short-hand name {\stff rp}) returns the reference pixel
(in pixel axis order). You can recover  the reference pixel either for
all coordinates (leave {\stfaf type} unset) or for a specific coordinate
type (mimumum match of the allowed types will do).  If you ask for a
non-existent coordinate an exception is generated.

You can set the reference pixel with function
\ahlink{setreferencepixel}{images:coordsys.setreferencepixel}. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(spectral=T, linear=2)
- cs.setreferencepixel([1.0, 2.0, 3.0])
- cs.referencepixel()
[1 2 3]  
-
- cs.referencepixel('lin')
[2 3]
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{referencevalue}{Recover the reference value}
\begin{ahargs}
  \ahaddarg[in]{format}{Format string}{'n'}{String from combination of "n", "q", "s", "m"}
  \ahaddarg[in]{type}{Coordinate type}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
\end{ahargs}
\ahreturns{Vector of doubles, vector of quantities, vector of string, record or fail}


\begin{ahdescription}

Each axis associated with the Coordinate System has a reference value,
reference pixel and an increment (per pixel).  These are used in the
mapping from pixel to world coordinate. 

This function (short-hand name {\stff rv}) returns the reference value
(in world axis order). You can recover  the reference value either for all
coordinates (leave {\stfaf type} unset) or for a specific coordinate
type (mimumum match of the allowed types will do).  If you ask for a
non-existent coordinate an exception is generated.

See the \htmlref{discussion}{COORDSYS:FORMATTING} regarding the
formatting possibilities available via argument {\stfaf format}.

You can set the reference value with function
\ahlink{setreferencevalue}{images:coordsys.setreferencevalue}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- cs.referencevalue(format='q')
[__*0=[value=0, unit='], __*1=[value=0, unit='], __*2=[value=1.415e+09, unit=Hz]] 
-
- cs.referencevalue(format='n')
[0 0 1.415e+09]  
-
- cs.referencevalue(format='n', type='spec')
1.415e+09 
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{reorder}{Reorder the coordinates}
\begin{ahargs}
  \ahaddarg[in]{order}{New coordinate order}{}{Vector of integers}
\end{ahargs}
\ahreturns{Vector of quantities or doubles, or fail}

\begin{ahdescription}

This function reorders the coordinates in the Coordinate System.
You specify the new order of the coordinates in terms of their old
order.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T, linear=2)
- cs.coordinatetype()
Direction Spectral Linear
-
- cs.reorder([2,3,1]);
- cs.coordinatetype()
Spectral Linear Direction
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{replace}{Replace a coordinate}
\begin{ahargs}
  \ahaddarg[in]{csys}{Coordinate System to replace from}{}{Coordsys tool}
  \ahaddarg[in]{whichin}{Index of input coordinate}{}{Integer}
  \ahaddarg[in]{whichout}{Index of output coordinate}{}{Integer}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function replaces on coordinate in the current Coordinate System by
one coordinate in the given Coordinate System.  The specified
coordinates must have the same number of axes.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, linear=1)
- cs.coordinatetype()
Direction Linear
- cs2 := coordsys(spectral=T)
- cs2.replace (cs2,2,1)
- cs.coordinatetype()
Direction Spectral
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{restfrequency}{Recover the rest frequency}
\ahreturns{Quantity or fail}

\begin{ahdescription}

If the Coordinate System contains a spectral coordinate, then
it has a rest frequency.  In fact, the spectral coordinate
can hold several rest frequencies (to handle for example,
an observation where the band covers many lines), although
only one is active (for velocity conversions) at a time.

This function (short-hand name {\stff rf}) recovers the rest frequencies
as a quantity vector.   The first frequency is the active one.

You can change the rest frequencies with
\ahlink{setrestfrequency}{images:coordsys.setrestfrequency}. 

If the Coordinate System does not contain a frequency coordinate,
an exception is generated.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(spectral=T)
- cs.restfrequency()
[value=1.42040575e+09, unit=Hz] 
-
- cs.setrestfrequency (value=[1.2e9. 1.3e9], which=2, append=F)
- cs.restfrequency()
[value=[1.3e+09 1.2e+09] , unit=Hz] 
\end{verbatim}
In the example, the initial spectral coordinate has 1 rest frequency.
Then we set it with two, nominating the second as the active rest frequency,
and recover them.
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setconversiontype}{Set extra reference conversion layer}
\begin{ahargs}
  \ahaddarg[in]{direction}{Reference code}{None}{String or unset}
  \ahaddarg[in]{spectral}{Reference code}{None}{String or unset}
\end{ahargs}

\ahreturns{T, F or fail}

\begin{ahdescription}

Some coordinates contain a reference code.  Examples of reference codes
are B1950 and J2000 for direction coordinates, or LSRK and BARY for
spectral coordinates.  When you do conversions between pixel and world
coordinate, the coordinates are in the reference frame corresponding to
these codes.   

This function allows you to specify a different reference frame
which is used when converting between world and pixel coordinate
(see function \ahlink{conversiontype}{images:coordsys.conversiontype}
to recover the conversion types).
If it returns F, it means that although the conversion machines
were successfully created, a trial conversion failed.  This usually
means the REST frame was involved which requires a radial velocity
(not yet implemented).  If this happens, the conversion type will
left as it was.     You will get a fail if more blatant things are wrong
like a missing coordinate, or an incorrect reference code.

The list of possible reference codes can be obtained
via function \item \ahlink{referencecode}{images:coordsys.referencecode}.

With this function, you specify the desired reference code.  Then, when
a conversion between pixel and world is requested, an extra conversion
is done to ({\stff toWorld}) or from ({\stff toPixel}) the specified
reference frame. 

The \ahlink{summary}{images:coordsys.summary} function shows
the extra conversion reference system to the right of the native 
reference system (if it is different) and in parentheses.

Note that to convert between different spectral reference frames, you
need a position, epoch and direction.  The position (telescope) and
epoch (date of observation), if not in your coordinate system can be set
with functions \ahlink{settelescope}{images:coordsys.settelescope} and
\ahlink{setepoch}{images:coordsys.setepoch}.  The direction is the
reference direction of the {\it required} direction coordinate in the
coordinate system. 

As an example, let us say you are working with a spectral coordinate
which was constructed with the LSRK reference frame.  You want to convert
some pixel coordinates to barycentric velocities (reference code BARY).

\begin{verbatim}
- cs := coordsys(direction=T, spectral=T); # Create coordinate system
- local pa, wa;
- cs.findcoordinate(pa, wa, 'spectral')    # Find spectral coordinate
- u := cs.units()[wa[1]];                  # Spectral unit
- cs.referencecode(type='spectral')        # Which is  in LSRK reference frame
LSRK
-
- p := [10,20,30]
- w := cs.toworld(p, format='n')           # Convert a pixel to LSRK world
- print 'pixel, world = ', p, w
pixel, world =  [10 20 30]  [21590.9999 19.0000967 1.415029e+09] 
-
- p2 := cs.topixel(w)                      # and back to pixel
- print 'world, pixel = ', w, p2
world, pixel =  [21590.9999 19.0000967 1.415029e+09]  [10 20 30] 
-
- v := cs.frequencytovelocity(value=w[wa[1]],     # Convert LSRK frequency to LSRK velocity
                              frequnit=u, 
                              doppler='RADIO', 
                              velunit='m/s');
- print 'pixel, frequency, velocity = ', p[pa[1]], w[wa[1]], v
pixel, frequency, velocity =  30 1.415029e+09 1134823.36
-
-
- cs.setconversiontype(spectral='BARY')    # Specify BARY reference code
- w := cs.toworld(p, format='n')           # Convert a pixel to BARY world
print 'pixel, world = ', p, w
pixel, world =  [10 20 30]  [21590.9999 19.0000967 1.41498179e+09] 
-
- p2 := cs.topixel(w)                      # and back to pixel
- print 'world, pixel = ', w, p2
world, pixel =  [21590.9999 19.0000967 1.41498179e+09]  [10 20 29.9952772] 
-
- v := cs.frequencytovelocity(value=w[wa[1]],   # Convert BARY frequency to BARY velocity
                              frequnit=u, 
                              doppler='RADIO', 
                              velunit='m/s');
- print 'pixel, frequency, velocity = ', p[pa[1]], w[wa[1]], v
pixel, frequency, velocity =  30 1.41498179e+09 1144787.26

\end{verbatim}

You must also be aware of when this extra layer is active and when it is
not.  It's a bit nasty. 

\begin{itemize}

\item - Whenever you use {\stff toWorld}, {\stff toPixel}
{\stff toWorldMany}, or {\stff toPixelMany} the layer is active.   

\item - Whenever you use {\stff convert} or {\stff convertMany}
the layer {\it may} be active.   Here are the rules !

It is only relevant to spectral and direction coordinates.

For the direction coordinate part of your conversion, if you request a
pure world or pixel conversion it is active.  Any pixel/world mix will
not invoke it (because it is ill defined). 

For the spectral coordinate part it is always active (only one axis
so must be pixel or world).

\item - This layer is irrelevant to all functions converting between
frequency and velocity, and absolute and relative.  The values are in
whatever frame you are working with. 

\end{itemize}


The \item \ahlink{summary}{images:coordsys.summary} function
lists the reference frame for direction and spectral
coordinates.  If you have also set a conversion reference
code it also lists that (to the right in parentheses).


\end{ahdescription}
\end{ahfunction}



\begin{ahfunction}{setdirection}{Set direction coordinate values}
\begin{ahargs}
  \ahaddarg[in]{refcode}{Reference code}{No change}{String}  
  \ahaddarg[in]{proj}{Projection type}{No change}{String}
  \ahaddarg[in]{projpar}{Projection parameters}{No change}{Numeric vector}
  \ahaddarg[in]{refpix}{Reference pixel}{No change}{Numeric vector}
  \ahaddarg[in]{refval}{Reference value}{No change}{Vector of doubles, vector of quantities, quantity of vector of doubles, vector of string, record}
  \ahaddarg[in]{incr}{Increment}{No change}{Vector of doubles, vector of quantities, quantity of vector of doubles, vector of string, record}
  \ahaddarg[in]{xform}{Linear transform}{No change}{2-D numeric array}
  \ahaddarg[in]{poles}{Native poles}{No change}{Vector of doubles, vector of quantities, quantity of vector of doubles, vector of string, record}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

When you construct a Coordsys \tool, if you include a Direction
Coordinate, it  will have some default parameters.  
This function simply allows you to
replace the values of the Direction Coordinate.

You can also change almost all of those parameters (such as projection, reference value
etc.) via the individual functions 
\ahlink{setreferencecode}{images:coordsys.setreferencecode},
\ahlink{setprojection}{images:coordsys.setprojection},
\ahlink{setreferencepixel}{images:coordsys.setreferencepixel},
\ahlink{setreferencevalue}{images:coordsys.setreferencevalue},
\ahlink{setincrement}{images:coordsys.setincrement}, and
\ahlink{setlineartransform}{images:coordsys.setlineartransform}
provided by the Coordsys \tool.    See those functions for more details
about the formatting of the above function arguments.

Bear in mind, that if your Coordinate System came from a real image, then
the reference pixel is special and you should not change it.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T);
- cs.setdirection (refcode='GALACTIC', proj='SIN', projpar=[0,0],
                   refpix=[-10,20], refval="10deg -20deg");
- 
- cs.projection()
[type=SIN, parameters=[0 0] ] 
- cs.referencepixel()
[-10 20]  
- cs.referencevalue(format='s')
10.000000 deg -20.000000 deg 
\end{verbatim}
\end{ahexample}
\end{ahfunction}






\begin{ahfunction}{setepoch}{Set a new epoch}
\begin{ahargs}
  \ahaddarg[in]{value}{New epoch}{}{Epoch measure}
\end{ahargs}

\ahreturns{T or fail}

\begin{ahdescription}

This function (short-hand name {\stff se}) sets a new epoch (supplied as an
\ahlink{epoch}{measures:measures.epoch} measure) of the observation. You
can get the current epoch with function
\ahlink{epoch}{images:coordsys.epoch}.  

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- ep := cs.epoch()
- ep
[type=epoch, refer=UTC, m0=[value=51728.4578, unit=d]] 
-
- ep := dm.epoch('UTC', 'today')
- cs.setepoch(ep)
- cs.epoch()
[type=epoch, refer=UTC, m0=[value=51729.1679, unit=d]] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setincrement}{Set the increment}
\begin{ahargs}
  \ahaddarg[in]{value}{Increments}{}
           {Vector of doubles, vector of quantities, quantity of vector of doubles, vector of string, record}
  \ahaddarg[in]{type}{Which coordinate type ?}
           {All}{String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a reference value,
reference pixel and an increment (per pixel).  These are used in the
mapping from pixel to world coordinate. 

This function (short-hand name {\stff si}) allows you to set a new
increment.   You should not do this on "stokes" axes unless you are an
adept or a big risk taker.

You can set the increments either for all axes ({\stfaf
type=unset}) or for just the axes associated with a particular
coordinate type.

You may supply the increments in all of the formats described in
the \htmlref{formatting}{COORDSYS:FORMATTING} discussion.

In addition, you can also supply the increments as  a quantity of vector
of doubles.  For example {\stfaf dq.quantity([-1,2],'arcsec')}.

You can recover the current increments with function
\ahlink{increment}{images:coordsys.increment}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- rv := cs.increment(format='q')
- rv
[__*0=[value=-1, unit='], __*1=[value=1, unit='], __*2=[value=1000, unit=Hz]] 
-
- rv2 := dq.quantity('4kHz');
- cs.setincrement(value=rv2, type='spec')
- cs.increment(type='spec', format='q')
[value=4000, unit=Hz] 
-
- cs.increment(format='q')
[__*0=[value=-1, unit='], __*1=[value=1, unit='], __*2=[value=4000, unit=Hz]] 
-
- cs.setincrement (value="-2' 2' 2e4Hz")
- cs.increment(format='q')
[__*0=[value=-2, unit='], __*1=[value=2, unit='], __*2=[value=20000, unit=Hz]] 

\end{verbatim}
\end{ahexample}

In the example we first recover the increments as a vector of
quantities. We then create a quantity for a new value for the spectral
coordinate increment.  Note we use units of kHz whereas the spectral coordinate is
currently expressed in units of Hz.  We then set the increment for the
spectral coordinate.   We then recover the increment again; you
can see 4kHz has been converted to 4000Hz.  We also show how to set
the increment using a string interface.

\end{ahfunction}




\begin{ahfunction}{setlineartransform}{Set the linear transform}
\begin{ahargs}
  \ahaddarg[in]{type}{Which coordinate type ?}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular"}
  \ahaddarg[in]{value}{Linear transform}{}{Array of double}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function set the linear transform component.  For Stokes Coordinates
this function will return T but do nothing.

You can recover the current linear transform with function
\ahlink{lineartransform}{images:coordsys.lineartransform}. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(spectral=T, linear=3)
- xf := cs.lineartransform('lin')
- xf
[[1:3,]
    1 0 0
    0 1 0
    0 0 1]
- xf[1,2] := 0.01
- cs.slt(xf,'lin')
- cs.lt('lin')
[[1:3,]
    1 0.01 0
    0 1    0
    0 0    1]
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{setnames}{Set the axis names}
\begin{ahargs}
  \ahaddarg[in]{value}{Names}{}{Vector of strings}
  \ahaddarg[in]{type}{Which coordinate type ?}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a name.
It isn't used in any fundamental way.

This function (short-hand name {\stff sn}) allows you to set new axis names.   

You can set the names either for all axes ({\stfaf
type=unset}) or for just the axes associated with a particular
coordinate type.

You can recover the current axis names with function
\ahlink{names}{images:coordsys.names}. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(spectral=T, linear=2)
- cs.setnames(value="a b c")
- cs.names()
a b c
-
- cs.setnames('lin', "flying fish")
- cs.names()
a flying fish
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setobserver}{Set a new observer}
\begin{ahargs}
  \ahaddarg[in]{value}{New observer}{}{String}
\end{ahargs}

\ahreturns{T or fail}

\begin{ahdescription}

If you want grab all the glory, or transfer the blame, this function
(short-hand name {\stff so}) sets a new observer of the observation. You
can get the current observer with function
\ahlink{observer}{images:coordsys.observer}.    The observer's name is
not fundamental to the Coordinate System !

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- cs.observer()
Karl Jansky 
- cs.setobserver('Ronald Biggs')
- cs.observer()
Ronald Biggs 
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setprojection}{Set the direction coordinate projection}
\begin{ahargs}
  \ahaddarg[in]{type}{Type of projection}{}{String}
  \ahaddarg[in]{parameters}{Projection parameters}{[]}{Vector of double}
\end{ahargs}
\ahreturns{T or fail}


\begin{ahdescription}

If the Coordinate System contains a direction coordinate, this function
(short-hand name {\stff sp}) can be used to set the projection.  For
discussion about celestial coordinate systems, including projections,
see the papers by Mark Calabretta and Eric Greisen. The initial draft 
from 1996 (implemented in \aipspp) can be found
\htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.

You can use the function \ahlink{projection}{images:coordsys.projection}
to find out all the possible types of projection.  You can also use it
to find out how many parameters you need to describe a particular
projection.  See Calabretta and Greisen for details about those
parameters (see section 4 of their paper); in FITS terms these
parameters are what are labelled as PROJP. 

Some brief help here on the more common projections in astronomy.

\begin{itemize}

\item SIN has either 0 parameters or 2.  For coplanar arrays like
East-West arrays, one can use what is widely termed the NCP projection. 
This is actually a SIN projection where the parameters are 0 and
$1/tan(\delta_0)$ where $\delta_0$ is the reference declination.  Images
made from the ATNF's Compact Array with \aipspp\ will have such a
projection.  Otherwise, the SIN projection requires no parameters (but
you can give it two each of which is zero if you wish).

\item TAN is used widely in optical astronomy.  It requires 0
parameters.

\item ZEA (zenithal equal area) is used widely in survey work.
It requires 0 parameters.

\end{itemize}


If the Coordinate System does not contain a direction coordinate,
an exception is generated.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('cena')
- cs := im.coordsys()
- cs.projection()
[type=SIN, parameters=[0 0] ] 
-
- cs.projection('ZEA')
0
- cs.setprojection('ZEA')
- im2 := im.regrid('cena.zea', csys=cs)
\end{verbatim}
We change the projection of an image from SIN to 
ZEA (which requires no parameters).
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setreferencecode}{Set new reference code}
\begin{ahargs}
  \ahaddarg[in]{value}{Reference code}{}{String}
  \ahaddarg[in]{type}{Which coordinate type ?}{}{String from
  "direction" or "spectral"}
  \ahaddarg[in]{adjust}{Adjust reference value ?}{T}{Bool}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

This function (short-hand name {\stff src}) sets the reference code for the specified  coordinate
type.  Examples of reference codes are B1950 and J2000 for direction
coordinates, or LSRK and BARY for spectral coordinates.

You must specify {\stfaf type}, selecting from 'direction',  or
'spectral' (the first two letters will do).   If the Coordinate System
does not contain a coordinate of the type you specify, an exception is
generated.

Specify the new code with argument {\stfaf value}.   To see 
the list of possible codes, use the function
\ahlink{referencecode}{images:coordsys.referencecode} (see example).

If {\stfaf adjust} is T, then the reference value is recomputed.
This is invariably the correct thing to do.  If {\stfaf adjust} is F, 
then the reference code is simply overwritten; do this very carefully.

\end{ahdescription}


\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T)
- list := cs.referencecode('dir', T)      # See possibilities
- list.normal[1:10]
J2000 JMEAN JTRUE APP B1950 BMEAN BTRUE GALACTIC HADEC AZEL 
-
- cs.referencecode('dir')
J2000
- cs.setreferencecode('B1950', 'dir', T)

\end{verbatim}

In this example we first get the list of all possible reference codes
for a direction coordinate (and print some of the normal ones). Then we
set the actual reference code for the direction coordinate in our
Coordinate System.

\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T)
- list := cs.referencecode('dir', T)      # See possibilities
- list.normal[1:10]
J2000 JMEAN JTRUE APP B1950 BMEAN BTRUE GALACTIC HADEC AZEL 
-
- cs.referencecode('dir')
J2000
- cs.setreferencecode('B1950', 'dir', T)

\end{verbatim}

In this example we first get the list of all possible reference codes
for a direction coordinate (and print some of the normal ones). Then we
set the actual reference code for the direction coordinate in our
Coordinate System.

\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- im := image('myimage.j2000')                        # Open image
- cs := im.coordsys()			              # Get Coordinate System
- cs.referencecode('dir', F)
J2000
- cs.setreferencecode('B1950', 'dir', T)              # Set new direction system
- im2 := im.regrid(outfile='myimage.b1950', csys=cs)  # Regrid and make new image

\end{verbatim}

In this example we show how to regrid an image from J2000
to B1950.  First we recover the Coordinate System  into the Coordsys
\tool\ called {\stf cs}.  We then set a new direction reference code,
making sure we recompute the reference value.  Then the
new Coordinate System is supplied in the regridding process
(done with an Image \tool).

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setreferencelocation}{Set reference pixel and value}
\begin{ahargs}
  \ahaddarg[in]{pixel}{New reference pixel}{Old reference pixel}{Vector of integer}
  \ahaddarg[in]{world}{New reference value}{Old reference value}
           {Vector of doubles, vector of quantities, quantity of vector of doubles, vector of string, record}
  \ahaddarg[in]{mask}{Indicates which axes to center}{All}{Vector of boolean}
\end{ahargs}

\ahreturns{T or fail}
\begin{ahdescription}

This function (short-hand name {\stff srl}) sets the reference pixel and
reference value to the specified values.  The world coordinate can be
specified in any of the formats that the output world coordinate is
returned in by the \ahlink{toworld}{images:coordsys.toworld} function. 

You can specify a mask (argument {\stfaf mask}) indicating which pixel
axes are set (T) and which are left unchanged (F).  This function will
refuse to change the reference location of a Stokes axis (gets you into
trouble otherwise). 

This function can be rather useful when \ahlink{regridding}{images:image.regrid}
images.  It allows you to keep easily a particular feature centered in the 
regridded image.

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(linear=2)
- cs.referencepixel()
[1 1] 
- cs.referencevalue()
[0 0]
-
- w := cs.toworld([20,20], format='n')
- shp := [129,129]
- p := (shp-1)/2.0 + 1;
- cs.setreferencelocation (pixel=p, world=w)
- cs.referencepixel()
[65 65]  
- cs.referencevalue()
[19 19] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{setreferencepixel}{Set the reference pixel}
\begin{ahargs}
  \ahaddarg[in]{type}{Which coordinate type ?}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
  \ahaddarg[in]{value}{Reference pixel}{}{Vector of double}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a reference value,
reference pixel and an increment (per pixel).  These are used in the
mapping from pixel to world coordinate. 

This function (short-hand name {\stff srp}) allows you to set a new reference pixel.   You should not
do this on "stokes" axes unless you are an adept or a big risk taker.

You can set the reference pixel either for all axes ({\stfaf
type=unset}) or for just the axes associated with a particular
coordinate type.

Bear in mind, that if your Coordinate System came from a real image,
then the reference pixel is special and you should not change it for
Direction Coordinates. 

You can recover the current reference pixel with function
\ahlink{referencepixel}{images:coordsys.referencepixel}. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(spectral=T, linear=2)
- cs.setreferencepixel(value=[1.0, 2.0, 3.0])
- cs.referencepixel()
[1 2 3]
-
- cs.setreferencepixel('lin', [-1, -1])
- cs.referencepixel()
[1 -1 -1]  
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setreferencevalue}{Set the reference value}
\begin{ahargs}
  \ahaddarg[in]{value}{Reference value}{}
           {Vector of doubles, vector of quantities, quantity of vector of doubles, vector of string, record}
  \ahaddarg[in]{type}{Which coordinate type ?}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a reference value,
reference pixel and an increment (per pixel).  These are used in the
mapping from pixel to world coordinate. 

This function (short-hand name {\stff srv}) allows you to set a new
reference value.  You should not do this on "stokes" axes unless you
are an adept or a big risk taker.

You may supply the reference value in all of the formats described in
the \htmlref{formatting}{COORDSYS:FORMATTING} discussion.

You can recover the current reference value with function
\ahlink{referencevalue}{images:coordsys.referencevalue}. 

Note that the value argument should be one of the specified
possibilitioes. Especially a {\stff measure} will be accepted, but
will have a null effect, due to the interpretation as a generic
record.

\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- rv := cs.referencevalue(format='q')
- rv
[__*0=[value=0, unit='], __*1=[value=0, unit='], __*2=[value=1.415e+09, unit=Hz]] 
-
- rv2 := rv[3];
- rv2.value := 2.0e9;
- cs.setreferencevalue(type='spec', value=rv2)
- cs.referencevalue(format='n')
[0 0 2e+09] 
\end{verbatim}
To set a new direction reference value, the easiest way, given a
direction measure {\stff dr} would be:
\begin{verbatim}
- cs.setreferencevalue(type='direction', value=dm.getvalue(dr))
\end{verbatim}
\end{ahexample}
In the example we first recover the reference value as a vector of quantities.
We then select out the value for the spectral coordinate, change it,
and set it back in the Coordinate System.  We then recover the
reference value again, but this time just as a vector of doubles. In
the case of the dircetion, we set the value from a known direction measure.
\end{ahfunction}




\begin{ahfunction}{setrestfrequency}{Set the rest frequency}
\begin{ahargs}
  \ahaddarg[in]{value}{New rest frequencies}{}{Quantity, double or string vector}
  \ahaddarg[in]{which}{Which is the active rest frequency}{1}{Integer}
  \ahaddarg[in]{append}{Append this list or overwrite ?}{F}{Bool}
\end{ahargs}

\ahreturns{T or fail}

\begin{ahdescription}

If the Coordinate System contains a spectral coordinate, then
it has a rest frequency.  In fact, the spectral coordinate
can hold several rest frequencies (to handle for example,
an observation where the band covers many lines), although
only one is active (for velocity conversions) at a time.

This function (short-hand name {\stff srf}) allows you to set new rest
frequencies.  You can provide the rest frequency as a quantity, 
a quantity string, or a double (units of current rest frequency assumed).

You specify whether the list of frequencies will be appended
to the current list or whether it will replace that list.
You must select which of the frequencies will become the active
one.  By default its the first in the list.  The index refers
to the final list (either appended or replaced).

You can recover the current rest frequencies with
\ahlink{restfrequency}{images:coordsys.restfrequency}. 

If the Coordinate System does not contain a frequency coordinate,
an exception is generated.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(spectral=T)
- cs.restfrequency()
[value=1.42040575e+09, unit=Hz] 
-
- cs.setrestfrequency(dq.quantity('1.4GHz'))
- cs.restfrequency()
[value=1.4e+09, unit=Hz] 
-
- cs.setrestfrequency(1.3e9)
- cs.restfrequency()
[value=1.3e+09, unit=Hz] 
-
- cs.setrestfrequency (value=[1.2e9, 1.3e9], which=2)
- cs.restfrequency()
[value=[1.3e+09 1.2e+09] , unit=Hz] 
-
- cs.setrestfrequency (dq.quantity([1,2],'GHz'), which=4, append=T)
- cs.restfrequency()
[value=[2e+09 1.2e+09 1.3e+09 1e+09] , unit=Hz] 
-
- cs.setrestfrequency ("1.4E9Hz 1667MHz")
- cs.restfrequency()
[value=[1.4e+09 1.667e+09] , unit=Hz] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setspectral}{Set tabular values for the spectral coordinate}
\begin{ahargs}
  \ahaddarg[in]{refcode}{Reference code}{No change}{String}
  \ahaddarg[in]{restfreq}{Rest frequency}{No change}{Quantum or double}
  \ahaddarg[in]{frequencies}{Vector of frequencies}{No change}{Quantum vector}
  \ahaddarg[in]{doppler}{Doppler type}{No change}{String}
  \ahaddarg[in]{velocities}{Vector of velocitiestypes}{No change}{Quantum vector}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

When you construct a Coordsys \tool, if you include a Spectral Coordinate, it 
will be linear in frequency.  This function allows you to replace the
Spectral Coordinate by a finite table of values.  Coordinate
conversions between pixel and world are then done by interpolation.

You may specify either a vector of frequencies or velocities.
If you specify frequencies, you can optionally specify a (new)
reference code (see function \ahlink{setreferencecode}{images:coordsys.setreferencecode}
for more details) and rest frequency (else the existing ones 
will be used).

If you specify velocities, you can optionally specify a (new)
reference code and rest frequency (else the existing ones 
will be used).  You must also give the doppler type 
(see function \ahlink{summary}{images:image.summary} for
more details).   The velocities
are then converted to frequency for creation of the Spectral Coordinate
(which is fundamentally described by frequency).

You may specify the rest frequency as a Quantum or a double (native units
of Spectral Coordinate used).

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(spectral=T);
-
- f1 := [1,1.01,1.03,1.4]
- fq := dq.quantity(f1, 'GHz')
- cs.setspectral(frequencies=fq)
- v := cs.frequencytovelocity(f1, 'GHz', 'radio', 'km/s')
- print 'v=', v
[88731.3175 86620.7061 82399.4832 4306.86125]  
- vq := dq.quantity(v, 'km/s')
- cs.setspectral(velocities=vq, doppler='radio')
- f2 := cs.velocitytofrequency(v, 'GHz', 'radio', 'km/s')
-
- print 'f1 = ', f1
[1 1.01 1.03 1.4]  
- print 'f2 = ', f2
[1 1.01 1.03 1.4]  
\end{verbatim}
We make a linear Spectral Coordinate.  Then overwrite it with
a list of frequenices.  Convert those values to velocity,
then overwrite the coordinate starting with a list of
velocities. Then convert the velocities to frequency
and show we get the original result.
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setstokes}{Set the Stokes types}
\begin{ahargs}
  \ahaddarg[in]{stokes}{Stokes types}{}{Vector of strings}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

If the Coordinate System contains a Stokes Coordinate, this function allows
you to change the Stokes types defining it.  If there is no Stokes
Coordinate, an exception is generated.

See the \ahlink{coordsys}{images:coordsys.coordsys} constructor
to see the possible Stokes types you can set.

You can set the Stokes types with function
\ahlink{setstokes}{images:coordsys.setstokes}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(stokes='I V')
- cs.stokes()
I V
- cs.setstokes("XX RL")
- cs.stokes()
XX RL
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{settabular}{Set tabular values for the tabular coordinate}
\begin{ahargs}
  \ahaddarg[in]{pixel}{Vector of (1-rel) pixel values}{No change}{Double vector}
  \ahaddarg[in]{world}{Vector of world values}{No change}{Double vector}
  \ahaddarg[in]{which}{Which Tabular coordinate}{1}{Integer}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

When you construct a Coordsys \tool, if you include a Tabular
Coordinate, it will be linear.  This function allows you to replace the
Tabular Coordinate by a finite table of values.  Coordinate conversions
between pixel and world are then done by interpolation (or extrapolation
beyond the end).  The table of values must be at least of length 2
or an exception will occur.

You may specify a vector of pixel and world values (in the current units
of the Tabular Coordinate).  These vectors must be the same length.  If
you leave one of them unset, then the old values are used, but again,
ultimately, the pixel and world vectors must be the same length. 

The new reference pixel will be the first pixel value.
The new reference value will be the first world value.

Presently, there is no way for you to recover the lookup table
once you have set it.

If you have more than one Tabular Coordinate, use argument
{\stfaf which} to specify which one you want to modify.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(tabular=T);
- cs.settabular (pixel=[1,10,15,20,100], world=[10,20,50,100,500])
\end{verbatim}
We make a linear Tabular Coordinate.  Then overwrite it with
a non-linear list of pixel and world values.
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{settelescope}{Set a new telescope}
\begin{ahargs}
  \ahaddarg[in]{value}{New telescope}{}{String}
\end{ahargs}

\ahreturns{T or fail}

\begin{ahdescription}

This function (short-hand name {\stff st}) sets a new telescope of the observation.   The telescope
position may be needed for reference code conversions; this is why it is
maintained in the Coordinate System.    So it is fundamental
to the Coordinate System and should be correct.

You can find a list of the observatory names know to \aipspp\ with the
Measures \ahlink{obslist}{measures:measures.obslist} function.

You can  get the current telescope with function
\ahlink{telescope}{images:coordsys.telescope}.   



\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- cs.telescope()
ATCA
- cs.settelescope('VLA')
- cs.telescope()
VLA
-
- cs.settelescope('The One In My Backyard')
WARN: This telescope is not known to the AIPS++ system
You can request that it be added
-
- dm.obslist()
ALMA ATCA BIMA CLRO DRAO DWL GB GBT JCMT MOPRA NRAO12M PKS VLA WSRT 

\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{setunits}{Set the axis units}
\begin{ahargs}
  \ahaddarg[in]{value}{Units}{}{Vector of strings}
  \ahaddarg[in]{type}{Which coordinate type ?}{All}
           {String from "direction", "stokes", "spectral", "linear", "tabular" or unset}
  \ahaddarg[in]{overwrite}{Overwrite linear or tabular coordinate units ?}{F}{Bool}
  \ahaddarg[in]{which}{Which coordinate if more than one of same type}{First}{Integer}
\end{ahargs}
\ahreturns{T or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a unit. This
function (short-hand name {\stff su}) allows you to set new axis units.    

You can set the units either for all axes ({\stfaf
type=unset}) or for just the axes associated with a particular
coordinate type.

In general, the units must be consistent with the old units. When you
change the units, the increment and reference value will be adjusted
appropriately.  However, for a linear or tabular coordinate, and only
when you specify {\stfaf type='linear'} or {\stfaf type='tabular'} 
(i.e. you supply units only for the specified linear of tabular
coordinate), and if you set {\stfaf overwrite=T}, you can just overwrite
the units with no further adjustments.   Otherwise, the {\stfaf
overwrite} argument will be silently ignored.  Use argument
{\stfaf which} to specify which coordinate if you have more
than one of the specified type.


You can recover the current axis units with function
\ahlink{units}{images:coordsys.units}. 


\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- cs.summary()
-
Direction reference : J2000
Spectral  reference : LSRK
Velocity  type      : RADIO
Rest frequency      : 1.42041e+09 Hz

Telescope        : ATCA
Observer         : Karl Jansky
Date observation : 2000/07/05/06:58:46

Axis Type      Name             Proj   Coord value at pixel    Coord incr Units
------------------------------------------------------------------------------- 
1    Direction Right Ascension   SIN  00:00:00.000     1.00 -6.000000e+01 arcsec
2    Direction Declination       SIN +00.00.00.000     1.00  6.000000e+01 arcsec
3    Spectral  Frequency              1.415000e+09     1.00  1.000000e+03 Hz
               Velocity               1.140944e+03     1.00 -2.110611e-01 km/s
-
- cs.setunits(value="deg rad mHz");
-
-
Direction reference : J2000
Spectral  reference : LSRK
Velocity  type      : RADIO
Rest frequency      : 1.42041e+12 mHz

Telescope        : ATCA
Observer         : Karl Jansky
Date observation : 2000/07/05/06:58:46

Axis Type      Name             Proj   Coord value at pixel    Coord incr Units
------------------------------------------------------------------------------- 
1    Direction Right Ascension   SIN  00:00:00.000     1.00 -6.000000e+01 arcsec
2    Direction Declination       SIN +00.00.00.000     1.00  6.000000e+01 arcsec
3    Spectral  Frequency              1.415000e+12     1.00  1.000000e+06 mHz
               Velocity               1.140944e+03     1.00 -2.110611e-01 km/s

\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{stokes}{Recover the Stokes types}

\ahreturns{Vector of strings or fail}

\begin{ahdescription}

If the Coordinate System contains a Stokes Coordinate, this function recovers the
Stokes types defining it.  If there is no Stokes
Coordinate, an exception is generated.

You can set the Stokes types with function
\ahlink{setstokes}{images:coordsys.setstokes}. 

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(stokes='I V')
- cs.stokes()
I V
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{summary}{Summarize basic information about the Coordinate System}
\begin{ahargs}
  \ahaddarg[in]{doppler}{List velocity information with this doppler definition}{RADIO}{String}
  \ahaddarg[in]{list}{List to global logger}{T}{Boolean}
\end{ahargs}
\ahreturns{T, fail, or Vector of strings}
\begin{ahdescription}

This function (short-hand name {\stff s}) summarizes the information
contained in the Coordinate System. 
    
For spectral coordinates, the information is listed as a velocity as well as a
frequency.  The argument {\stfaf doppler} allows you to specify what
doppler convention it is listed in.  You can choose from {\stfaf radio,
optical} and {\stfaf beta}.  Alternative names are {\stfaf z} for
{\stfaf optical}, and {\stfaf relativistic} for {\stfaf
beta}.  The default is {\stfaf radio}.  The definitions are

\begin{itemize}
\item radio: $1 - F$
\item optical: $-1 + 1/F$
\item beta: $(1 - F^2)/(1 + F^2)$
\end{itemize}
where $F = \nu/\nu_0$ and $\nu_0$ is the rest frequency.  If the rest
frequency has not been set in your image, you can set it with
the function \ahlink{setrestfrequency}{images:coordsys.setrestfrequency}.

These velocity definitions are provided by the \ahlink{measures}{measures:measures}
system via the Doppler measure (see example).

If you  set {\stfaf list=F}, then the summary will not be written
to the global logger.     However, the return value will be a vector of strings
holding the summary information, one string per line of the summary.

For direction and spectral coordinates, the reference frame (e.g.  J2000
or LSRK) is also listed.  Along side this, in parentheses, will be the
conversion reference frame as well (if it is different from the native
reference frame).  See function
\ahlink{setconversion}{images:coordsys.setconversion} to see what this
means. 


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- d := dm.doppler('beta')
- dm.listcodes(d)
[normal=RADIO Z RATIO BETA GAMMA OPTICAL TRUE RELATIVISTIC, extra=] 
-
- cs := coordsys(direction=T, spectral=T)
- cs.summary()
-
Direction reference : J2000
Spectral  reference : LSRK (-> BARY)
Velocity  type      : RADIO
Rest frequency      : 1.42041e+09 Hz

Telescope        : ATCA
Observer         : Karl Jansky
Date observation : 2000/07/04/10:01:11

Axis Type      Name             Proj   Coord value at pixel    Coord incr Units
------------------------------------------------------------------------------- 
1    Direction Right Ascension   SIN  00:00:00.000     1.00 -6.000000e+01 arcsec
2    Direction Declination       SIN +00.00.00.000     1.00  6.000000e+01 arcsec
3    Spectral  Frequency              1.415000e+09     1.00  1.000000e+03 Hz
               Velocity               1.140944e+03     1.00 -2.110611e-01 km/s

\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{telescope}{Return the telescope}
\begin{ahargs}
  \ahaddarg[in]{measure}{Return as position measure}{F}{T or F}
\end{ahargs}

\ahreturns{String or position measure or fail}
  
\begin{ahdescription}

This function (short-hand name {\stff t}) returns the telescope contained in the Coordinate System. 
It can be returned as a simple string ({\stfaf measure=F}) or as a
position measure ({\stfaf measure=T}).

The telescope position may be needed for reference code conversions; this is
why it is maintained in the Coordinate System.  

The conversion from string to position is done with
\ahlink{observatory}{measures:measures.observatory}.
The example shows you what is really going on.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys()
- cs.telescope()
ATCA
- cs.telescope(T)
[type=position, refer=ITRF, m2=[value=6372960.26, unit=m], 
m1=[unit=rad, value=-0.52613792], m0=[unit=rad, value=2.61014232]] 
-
- dm.observatory(cs.telescope())
[type=position, refer=ITRF, m2=[value=6372960.26, unit=m], 
m1=[unit=rad, value=-0.52613792], m0=[unit=rad, value=2.61014232]] 

\end{verbatim}
We get the telescope as a string and as a position measure.
We also show how the Measures system was used to convert from
the simple name to a position Measure.

\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{toabs}{Convert relative coordinate to absolute}
\begin{ahargs}
 \ahaddarg[in]{value}{Relative coordinate}{}{Numeric vector, vector string, vector quantum, record}
 \ahaddarg[in]{isworld}{Is coordinate world or pixel ?}{unset}{T, F, unset}
\end{ahargs}
\ahreturns{Same as input or fail}

\begin{ahdescription}

This function converts a relative coordinate to an absolute coordinate.
The coordinate may be a pixel coordinate or a world coordinate.

If the coordinate is a pixel coordinate, it is supplied as a numeric
vector. If the coordinate is a world coordinate,  you may give it in all
of the formats described in the
\htmlref{formatting}{COORDSYS:FORMATTING} discussion.

If the coordinate value is supplied by a Coordsys \tool\ function (e.g.
\ahlink{toworld}{images:coordsys.toworld}) then the coordinate 'knows'
whether it is world or pixel (and absolute or relative). However, you
might supply the value from some other source as a numeric vector (which
could be world or pixel) in which case you must specify whether it is a 
world or pixel coordinate via the {\stfaf isworld} argument.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
-
- aw := cs.toworld([100,100,24], 's')
- rw := cs.torel(aw)
- aw2 := cs.toabs(rw)
-
- aw
23:53:23.781 +01.39.00.821 1.415023e+09 Hz 
- rw
5.943285e+03 arcsec 5.940821e+03 arcsec 2.300000e+04 Hz 
- aw2
23:53:23.781 +01.39.00.821 1.415023e+09 Hz 

\end{verbatim}

This example uses world coordinates.
\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
-
- ap := cs.topixel()           # Reference value
- rp := cs.torel(ap)
- ap2 := cs.toabs(rp)
-
- ap
[1 1 1] 
- rp
[0 0 0]
- ap2
[1 1 1] 
\end{verbatim}
This example uses pixel coordinates.
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{toabsmany}{Convert many numeric relative coordinates to absolute}
\begin{ahargs}
 \ahaddarg[in]{value}{Relative coordinates}{}{Numeric matrix}
 \ahaddarg[in]{isworld}{Is coordinate world or pixel ?}{unset}{T, F, unset}
\end{ahargs}
\ahreturns{Numeric matrix or fail}

\begin{ahdescription}

This function converts many relative coordinates to absolute. It exists
so you can efficiently make many conversions (which would be rather slow
if you did them all with \ahlink{toabs}{images:coordsys.toabs}). Because
speed is the object, the interface is purely in terms of numeric
matrices, rather than being able to accept strings and quanta etc. like
\ahlink{toabs}{images:coordsys.toabs} can.  

When dealing with world coordinates, the units of the numeric
values must be the native units, given by function
\ahlink{units}{images:coordsys.units}.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)    # 3 axes
-
- rv := cs.referencevalue();                 # reference value
- w := cs.torel(rv)                          # make relative
- inc := cs.increment();                     # increment
- idx := 1:100;
- off := inc[3] * idx;                       # offset for third axis
- wrel := array (w, 3, 100);                 # 100 conversions each of length 3
- wrel[3,] +:= off;                          # Make spectral axis values change
-
- wabs  := cs.toabsmany (rel, T)             # Convert
- wabs[,1]                                   # First absolute coordinate
[0 0 1.415001e+09]  
- wabs[,100]                                 # 100th absolute coordinate
[0 0 1.415002e+09]  

\end{verbatim}
This example uses world coordinates.
\end{ahexample}





\begin{ahfunction}{topixel}{Convert from absolute world to pixel coordinate}
\begin{ahargs}
\ahaddarg[in]{value}{Absolute world coordinate}{Reference value}{Numeric vector, vector of quantities, vector of strings or record}
\end{ahargs}
\ahreturns{Vector of double or fail}

\begin{ahdescription}

This function converts between world (physical) coordinate and absolute pixel
coordinate (1-rel).

The world coordinate can be provided in one of four formats via the
argument {\stfaf world}.  These match the output formats of function
\ahlink{toworld}{images:coordsys.toworld}.

If you supply fewer world values than there are axes in the  Coordinate
System, your coordinate vector will be padded out with the reference
value for the missing axes. Excess values will be silently ignored.

You may supply the world coordinate in all of the formats described in
the \htmlref{formatting}{COORDSYS:FORMATTING} discussion.

\end{ahdescription}



\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T, stokes="I V", linear=2)
-
- w := cs.toworld([-2,2,1,2,23,24], 'n')
- cs.topixel(w)
[-2 2 1 2 23 24]  
-
- w := cs.toworld([-2,2,1,2,23,24], 'q')
- cs.topixel(w)
[-2 2 1 2 23 24]  
-
- w := cs.toworld([-2,2,1,2,23,24], 'm')
- cs.topixel(w)
[-2 2 1 2 23 24]  
-
- w := cs.toworld([-2,2,1,2,23,24], 's')
- cs.topixel(w)
[-2 2 1 2 23 24]  
-
- w := cs.toworld([-2,2,1,2,23,24], 'mnq')
- cs.topixel(w)                            
[-2 2 1 2 23 24]  

\end{verbatim}
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys (stokes="I V", linear=2)
- cs.toworld([1,2,3], 's')
I 1.000000e+00 2.000000e+00 
-
- cs.toworld([1,2,3], 'm')
[stokes=I, linear=[*1=[value=1, unit=km], *2=[value=2, unit=km]]] 
-
- cs.toworld([1,2,3], 'q')
[*1=[value=1, unit=], *2=[value=1, unit=km], *3=[value=2, unit=km]] 

\end{verbatim}
\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- cs := coordsys (spectral=T, linear=1)
- cs.toworld([1,2,3], 'q')
[*1=[value=1.415e+09, unit=Hz], *2=[value=1, unit=km]] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{topixelmany}{Convert many absolute numeric world coordinates to pixel}
\begin{ahargs}
 \ahaddarg[in]{value}{Absolute world coordinates}{}{Numeric matrix}
\end{ahargs}
\ahreturns{Numeric matrix or fail}

\begin{ahdescription}

This function converts many absolute world coordinates to pixel coordinates. It exists
so you can efficiently make many conversions (which would be rather slow
if you did them all with \ahlink{topixel}{images:coordsys.topixel}). Because
speed is the object, the interface is purely in terms of numeric
matrices, rather than being able to accept strings and quanta etc. like
\ahlink{topixel}{images:coordsys.topixel} can.  

The units of the numeric values must be the native units, given by
function \ahlink{units}{images:coordsys.units}.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)    # 3 axes
-
- rv := cs.referencevalue();                 # reference value
- inc := cs.increment();                     # increment
- idx := 0:99;
- off := inc[3] * idx;                       # offset for third axis
-
- wabs := array (rv, 3, 100);                # 100 conversions each of length 3
- wabs[3,] +:= off;                          # Make spectral axis values change
-
- pabs  := cs.topixelmany (wabs);            # Convert
- pabs[,1]                                   # First absolute pixel coordinate
[1 1 1]  
- pabs[,100]                                 # 100th absolute pixel coordinate
[1 1 100]  
\end{verbatim}
\end{ahexample}




\begin{ahfunction}{torecord}{Convert Coordinate System to a record}
\ahreturns{Glish record or fail}
  
\begin{ahdescription}

You can convert a Coordinate System to a record with this function.
There is also \ahlink{fromrecord}{images:coordsys.fromrecord}
to set a Coordinate System from a record.

These functions are not for general user use; they are used for
sending Coordsys \tools\ about the \glish\ bus.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, stokes="I Q")
- rec := cs.torecord();
- cs2 := coordsys();
- cs2.fromrecord(rec);
-
- print cs.ncoordinates(), cs2.ncoordinates()
2 2

\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{torel}{Convert absolute coordinate to relative}
\begin{ahargs}
 \ahaddarg[in]{value}{Absolute coordinate}{}{Numeric vector, vector string, vector quantum, record}
 \ahaddarg[in]{isworld}{Is coordinate world or pixel ?}{unset}{T, F, unset}
\end{ahargs}
\ahreturns{Same as input or fail}

\begin{ahdescription}

This function converts an absolute coordinate to a relative coordinate.
The coordinate may be a pixel coordinate or a world coordinate.

Relative coordinates are relative to the reference pixel (pixel coordinates)
or the reference value (world coordinates) in the sense 
$relative = absolute - reference$.

If the coordinate is a pixel coordinate, it is supplied as a numeric
vector. If the coordinate is a world coordinate,  you may give it in all
of the formats described in the
\htmlref{formatting}{COORDSYS:FORMATTING} discussion.

If the coordinate value is supplied by a Coordsys \tool\ function (e.g.
\ahlink{toworld}{images:coordsys.toworld}) then the coordinate 'knows'
whether it is world or pixel (and absolute or relative). However, you
might supply the value from some other source as a numeric vector (which
could be world or pixel) in which case you must specify whether it is a 
world or pixel coordinate via the {\stfaf isworld} argument.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
-
- aw := cs.toworld([100,100,24], 's')
- rw := cs.torel(aw)
- aw2 := cs.toabs(rw)
-
- aw
23:53:23.781 +01.39.00.821 1.415023e+09 Hz 
- rw
5.943285e+03 arcsec 5.940821e+03 arcsec 2.300000e+04 Hz 
- aw2
23:53:23.781 +01.39.00.821 1.415023e+09 Hz 

\end{verbatim}

This example uses world coordinates.
\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
-
- ap := cs.topixel()           # Reference value
- rp := cs.torel(ap)
- ap2 := cs.toabs(rp)
-
- ap
[1 1 1] 
- rp
[0 0 0]
- ap2
[1 1 1] 
\end{verbatim}
This example uses pixel coordinates.
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{torelmany}{Convert many numeric absolute coordinates to relative}
\begin{ahargs}
 \ahaddarg[in]{value}{Absolute coordinates}{}{Numeric matrix}
 \ahaddarg[in]{isworld}{Is coordinate world or pixel ?}{unset}{T, F, unset}
\end{ahargs}
\ahreturns{Numeric matrix or fail}

\begin{ahdescription}

This function converts many absolute coordinates to relative. It exists
so you can efficiently make many conversions (which would be rather slow
if you did them all with \ahlink{torel}{images:coordsys.torel}). Because
speed is the object, the interface is purely in terms of numeric
matrices, rather than being able to accept strings and quanta etc. like
\ahlink{torel}{images:coordsys.torel} can.  

When dealing with world coordinates, the units of the numeric
values must be the native units, given by function
\ahlink{units}{images:coordsys.units}.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)    # 3 axes
-
- w := cs.referencevalue();                  # reference value
- inc := cs.increment();                     # increment
- idx := 0:99;
- off := inc[3] * idx;                       # offset for third axis
- wabs := array (w, 3, 100);                 # 100 conversions each of length 3
- wabs[3,] +:= off;                          # Make spectral axis values change
-
- wrel  := cs.torelmany (wabs, T)            # Convert
- wrel[,1]                                   # First relative coordinate
[0 0 0]  
- wrel[,100]                                 # 100th relative coordinate
[0 0 99000] 
\end{verbatim}
This example uses world coordinates.
\end{ahexample}




\begin{ahfunction}{toworld}{Convert from absolute pixel coordinate to world}
\begin{ahargs}
 \ahaddarg[in]{value}{Absolute pixel coordinate}{Reference pixel}{Numeric vector}
 \ahaddarg[in]{format}{Format string}{'n'}{String from combination of "n", "q", "s", "m"}
\end{ahargs}
\ahreturns{Vector numeric, vector quantity, vector string, record, or fail}

\begin{ahdescription}

This function converts between absolute pixel coordinate (1-rel)
and absolute world (physical coordinate).

If you supply fewer pixel values than there are axes in the  Coordinate
System, your coordinate vector will be padded out with the reference
pixel for the missing axes. Excess values will be silently ignored.

You may ask for the world coordinate in all of the formats described in
the \htmlref{discussion}{COORDSYS:FORMATTING} regarding the
formatting possibilities available via argument {\stfaf format}.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
-
- cs.toworld([-2,2,2], 'n')
[3.00000051 1.00000001 1.415001e+09]       
-
- cs.toworld([-2,2,2], 'q')
[*1=[value=3.00000051, unit='], 
 *2=[value=1.00000001, unit='], 
 *3=[value=1.415001e+09, unit=Hz]] 
-
- cs.toworld([-2,2,2], 'm')
[direction=[type=direction, refer=J2000, m1=[value=0.000290888213, unit=rad],  
                                         m0=[unit=rad, value=0.000872664774]], 
 spectral=[frequency=[type=frequency, refer=LSRK, m0=[value=1.415001e+09, unit=Hz]], 
           radiovelocity=[value=1140.73308, unit=km/s], 
           opticalvelocity=[value=1145.09023, unit=km/s], 
           betavelocity=[value=1142.90335, unit=km/s]]] 
-
- cs.toworld([-2,2,2], 's')
00:00:12.000 +00.01.00.000 1.415001e+09 
\end{verbatim}
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys (stokes="I V", linear=2)
- cs.toworld([1,2,3], 's')
I 1.000000e+00 2.000000e+00 
-
- cs.toworld([1,2,3], 'm')
[stokes=I, linear=[*1=[value=1, unit=km], *2=[value=2, unit=km]]] 
-
- cs.toworld([1,2,3], 'q')
[*1=[value=1, unit=], *2=[value=1, unit=km], *3=[value=2, unit=km]] 

\end{verbatim}
\end{ahexample}


\begin{ahexample}
\begin{verbatim}
- cs := coordsys (spectral=T, linear=1)
- cs.toworld([1,2,3], 'q')
[*1=[value=1.415e+09, unit=Hz], *2=[value=1, unit=km]] 
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{toworldmany}{Convert many absolute pixel coordinates to numeric world}
\begin{ahargs}
 \ahaddarg[in]{value}{Absolute pixel coordinates}{}{Numeric matrix}
\end{ahargs}
\ahreturns{Numeric matrix or fail}

\begin{ahdescription}

This function converts many absolute pixel coordinates to world coordinates. It exists
so you can efficiently make many conversions (which would be rather slow
if you did them all with \ahlink{toworld}{images:coordsys.toworld}). Because
speed is the object, the interface is purely in terms of numeric
matrices, rather than being able to produce strings and quanta etc. like
\ahlink{toworld}{images:coordsys.toworld} can.  

The units of the output world values are the native units given by
function \ahlink{units}{images:coordsys.units}.


\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)    # 3 axes
-
- rp := cs.referencepixel();                 # reference pixel
- off := 0:99;                               # offset for third axis
-
- pabs := array (rp, 3, 100);                # 100 conversions each of length 3
- pabs[3,] +:= off;                          # Make spectral axis values change
-
- wabs  := cs.toworldmany (pabs);            # Convert
- wabs[,1]                                   # First absolute pixel coordinate
[0 0 1.415e+09]  
- wabs[,100]                                 # 100th absolute pixel coordinate
[0 0 1.415099e+09]  
\end{verbatim}
\end{ahexample}



\begin{ahfunction}{type}{Return the type of this tool}
\ahreturns{String}
  
\begin{ahdescription}

This function returns the string `coordsys'.

\end{ahdescription}
\end{ahfunction}



\begin{ahfunction}{units}{Recover the units for each axis}
\begin{ahargs}
  \ahaddarg[in]{type}{Coordinate type}{All}{String from 'direction', 'stokes', 'spectral', 'linear' or unset}
\end{ahargs}

\ahreturns{Vector of strings or fail}

\begin{ahdescription}

Each axis associated with the Coordinate System has a unit.
This function (short-hand name {\stff u}) returns those units
(in world axis order).

You can recover the units either for all coordinates (leave {\stfaf
type} unset) or for a specific coordinate type (mimumum match of the
allowed types will do).  If you ask for a non-existent coordinate an
exception is generated.

You can set the units with function
\ahlink{setunits}{images:coordsys.setunits}.

\end{ahdescription}

\begin{ahexample}  
\begin{verbatim}
- cs := coordsys(direction=T, spectral=T)
- cs.units(T)
' ' Hz 
-
- cs.units('spec')
Hz
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{velocitytofrequency}{Convert velocity to frequency}
\begin{ahargs}  
  \ahaddarg[in]{value}{Velocity to convert}{}{Numeric or vector of numeric}
  \ahaddarg[in]{frequnit}{Unit of output frequencies}{Intrinsic units}{String}
  \ahaddarg[in]{doppler}{Velocity doppler definition}{'radio'}{String}   
  \ahaddarg[in]{velunit}{Unit of input velocities}{'km/s'}{String}  
\end{ahargs}    
\ahreturns{Double or vector of double or fail}
  
\begin{ahdescription}

This function (short-hand name {\stf vtf}) converts velocities
to frequencies.

The input velocities are specified via a vector of numeric values, a
specified unit ({\stfaf velunit}), and a  velocity doppler definition ({\stfaf
doppler}).

The frequencies are returned in a vector for which you specify the
units ({\stfaf frequnit}).  If you don't give the unit, it is assumed that 
the units are those given by function \ahlink{units}{images:coordsys.units} 
for the spectral coordinate.

This function will return a fail if there is no spectral coordinate
in the Coordinate System. See also the function
\ahlink{frequencytovelocity}{images:coordsys.frequencytovelocity}.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
- im := image('hcn.cube')
- cs := im.coordsys()
-
- local pa, wa;
- cs.findcoordinate(pa, wa, 'spectral')     # Find spectral axis
- pixel := cs.referencepixel();             # Use reference pixel for non-spectral
-
- nFreq := im.shape()[pa[1]];               # Length of spectral axis
- freq := [];
- for (i in 1:nFreq) { 
    pixel[pa[1]] := i;                      # Assign value for spectral axis of pixel coordinate
    w := cs.toworld(value=pixel, format='n')# Convert pixel to world
    freq[i] := w[wa[1]];                    # Fish out frequency
  }
- vel := cs.frequencytovelocity(value=freq, doppler='optical', velunit='km/s')
- freq2 := cs.velocitytofrequency(value=vel, doppler='optical', velunit='km/s')

\end{verbatim}

In this example, we find the optical velocity in km/s of every pixel
along the spectral axis of our image.  First we  obtain the Coordinate
System from the image.  Then we find which axis of the Coordinate System
(image) pertain to the spectral coordinate.  Then we loop over each
pixel of the spectral axis, and convert a pixel coordinate (one for each
axis of the image) to world.  We obtain the value for the spectral axis
from that world vector, and add it to the vector of frequencies.  Then
we convert that vector of frequencies to velocity.  Then we convert it
back to frequency.  They better agree.

\end{ahexample}
\end{ahfunction}

\end{ahobject}




%% Global functions

\begin{ahfunction}{is\_coordsys}{Is this variable a Coordsys tool ?}
\begin{ahargs}
  \ahaddarg[in]{thing}{Variable to test}{None}{Glish variable}
\end{ahargs}

\ahreturns{T or F}
\begin{ahdescription}

Determine if this variable is a Coordsys tool.  This
is very useful in scripts; for robustness, you check
that the \tool\ is a Coordsys \tool\ before you start applying
Coordsys \toolfunctions.

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
cs := coordsys();
is_coordsys(cs)
T
cs2 := 'doggies'
is_coordsys(cs2)
F
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{coordsystools}{Find the list of current global Coordsys tools}

\ahreturns{Vector of Strings}

\begin{ahdescription}
This function retuns a list of the names of the Coordsys 
\tools\ currently in Global name space.
\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
cs1 := coordsys();
im := shapetoimage(shape=[10,10])
cs2 := im.coordsys();
coordsystools()
cs1 cs2
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{coordsystest}{Run test suite for Coordsys tool}
\begin{ahargs}
  \ahaddarg[in]{which}{Which test to run}{All tests}{Integer or vector of integers}
\end{ahargs}
\ahreturns{T or F}

\begin{ahdescription}

Self-test of the Coordsys \tool.  This function is quite extensive and
includes forced errors.  As long as the function finally returns with a
{\cf T}, it has succeeded (regardless of what error messages you might
see). Note that one of the tests is if the created coordinate system
tools match the actual list of tools. If a coordinate system has
been created outside the test, the tests will fail. The {\stff
coordsystools} function can be used to check for pre-existing
tools. They can be removed by re-assigning them. E.g.:
\begin{verbatim}
cs := T
\end{verbatim}

\end{ahdescription}

\begin{ahexample}
\begin{verbatim}
coordsystest()
\end{verbatim}

Runs all tests.
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
coordsys(4)
\end{verbatim}

Runs only test 4.
\end{ahexample}
\end{ahfunction}


\end{document}

