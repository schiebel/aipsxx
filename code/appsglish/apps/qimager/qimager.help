%% Copyright (C) 1999,2000,2001,2002,2003
%% Associated Universities, Inc. Washington DC, USA.
%%
%% This library is free software; you can redistribute it and/or modify it
%% under the terms of the GNU Library General Public License as published by
%% the Free Software Foundation; either version 2 of the License, or (at your
%% option) any later version.
%%
%% This library is distributed in the hope that it will be useful, but WITHOUT
%% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
%% License for more details.
%%
%% You should have received a copy of the GNU Library General Public License
%% along with this library; if not, write to the Free Software Foundation,
%% Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
%%
%% Correspondence concerning AIPS++ should be addressed as follows:
%%        Internet email: aips2-request@nrao.edu.
%%        Postal address: AIPS++ Project Office
%%                        National Radio Astronomy Observatory
%%                        520 Edgemont Road
%%                        Charlottesville, VA 22903-2475 USA
%%
%% $Id: qimager.help,v 1.6 2004/08/25 01:48:17 cvsmgr Exp $
\documentclass{article}
\usepackage{aips2help, html, epsfig}
\begin{document}
\providecommand{\briggsURL}{http://www.aoc.nrao.edu/ftp/dissertations/dbriggs/diss.html}
\providecommand{\wprojectionURL}{http://www.aoc.nrao.edu/evla/geninfo/memoseries/evlamemo67.pdf}

\begin{ahmodule}{qimager}{Module for synthesis and single dish imaging}
\ahinclude{qimager.g}

\begin{ahdescription} 

{\tt qimager} is a stripped down version of {\tt imager} for
experimentation with processing algorithms. 

New experimental capabilities:

\begin{enumerate}
\item \htmladdnormallink{W projection}{\wprojectionURL} - a new
approach to non-coplanar baseslines.
\end{enumerate}

\end{ahdescription}


\ahobjs{}
\ahfuncs{}

\begin{ahobject}{qimager}{tool for synthesis imaging}
\begin{ahdescription}
qimager is an tool that accomplishes synthesis processing.
A {\tt qimager} must be constructed for each MeasurementSet for which one
wishes to do processing. Multiple copies of {\tt qimager} may
be made at any time (provide they are given different names).
\end{ahdescription}

\ahfuncs{}

\begin{ahconstructor}{qimager}{Construct an qimager tool}
\begin{ahdescription}
This is used to construct {\tt qimager} tools associated
with a MeasurementSet. The {\tt qimager} tool may then be
used to generate various types of images. Note that
a new executable is started every time the constructor
is called. 

This returns a Glish variable containing the tool functions of
qimager.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{filename}{MeasurementSet to be imaged}{''}{Table name}
\ahaddarg{compress}{Compress calibration columns?}{F}{Bool}
\ahaddarg{host}{Host on which to run qimager}{''}{String: '' means localhost}
\ahaddarg{forcenewserver}{Flag to force a new qimager client}{T}{Bool}
\end{ahargs}
\ahreturns{qimager tool}
\begin{ahexample}
\begin{verbatim}
imgr:=qimager('3C273XC1.MS')      
imgr.setimage(nx=256, ny=256, cellx='0.7arcsec', celly='0.7arcsec')
imgr.image(type='corrected', image='3C273XC1.dirty')
imgr.close()
\end{verbatim}
\end{ahexample}
\end{ahconstructor}

\begin{ahfunction}{open}{Open a new MeasurementSet, for processing, closing current MeasurementSet}
\begin{ahdescription}
Close the current MeasurementSet and open a new MeasurementSet
instead. The current state of {\tt qimager} is retained, except for
the data selection.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{thems}{New MeasurementSet to be processed}{'MS'}{Table name}
\ahaddarg{compress}{Compress calibration columns?}{F}{Bool}
\end{ahargs}
\ahreturns{Bool}
\end{ahconstructor}

\begin{ahfunction}{close}{Close the qimager tool, with data written on disk, keeping qimager process running for future use}
\begin{ahdescription}
This is used to close {\tt qimager} tools. Note that the
data is written to disk. The {\tt qimager} process keeps running
until a \ahlink{done}{qimager:qimager.done} tool function call is performed.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr:=qimager('3C273XC1.MS')      
imgr.image(image='3C273XC1.dirty',type='corrected')
imgr.close()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{stop}{stop the currently executing function asap}
\begin{ahdescription}
Stop the currently executing function as soon as possible. Note that
it is not always possible to stop a function. 
\end{ahdescription}
\ahreturns{Bool}
\end{ahfunction}

\begin{ahfunction}{done}{Terminate the qimager process}
\begin{ahdescription}
This is used to totally stop the {\tt qimager} process. It is a good idea
to conserve memory use on your machine by stopping the process once
you no longer need it.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr:=qimager('3C273XC1.MS')      
imgr.image(image='3C273XC1.dirty',type='corrected')
imgr.close()
imgr.done()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{summary}{Summarize the current state of the qimager tool}
\begin{ahdescription}
Writes a summary of the properties of the qimager to the
default logger. This includes:
\begin{itemize}
\item The name of the MeasurementSet (set in construction or via the
\ahlink{open}{qimager:qimager.open} function.
\item The parameters of the image (set via \ahlink{setimage}
{qimager:qimager.setimage})
\item The current beam (set by \ahlink{fitpsf}{qimager:qimager.fitpsf}
or \ahlink{setbeam}{qimager:qimager.setbeam}.
\item The selection of an ms (set via \ahlink{setdata}
{qimager:qimager.setdata})
\item The general processing options (set via \ahlink{setoptions}
{qimager:qimager.setoptions})
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr:=qimager('3C273XC1.MS');
- imgr.setimage(npix=[256,256])
- imgr.summary()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{setdata}{Set the data parameters selection for subsequent processing}
\begin{ahdescription}
This setup tool function selects which data are to be used 
subsequently. After invocation of setdata, only the selected
data are operated on. Thus, for example, in imaging, only the selected
data are gridded into an image, and in plotting, only the
selected data are plotted.

Data can be selected by field and spectral window ids. Note that
all data thus selected are passed to the imaging, and may or
may not be imaged, depending on how the image was constructed
using \ahlink{setimage}{qimager:qimager.setimage}. For example,
in mosaicing, use fieldid in setimage to control what pointing
is used to define the field center, and use fieldid in setdata
to control what pointings are used in the imaging.

For spectral processing,  it is possible to make cubes out
multi-spectral window selections but the selection is terse till a
better selection scheme is devised.

The selection is controlled by the mode argument:

\begin{description}
\item[channel]   Selection in channels using the nchan, start and step
arguments
\item[velocity]  Selection in radio velocity, using the nchan, mstart
and mstep arguments.
\item[opticalvelocity]  As for velocity but the velocity definition
is optical.
\end{description}

For channel mode, the other fields have the following meaning:

\begin{description}
\item[nchan]   is the number of output channels produced. Generally it
defaults to the number of input channels.
\item[start] is the first channel from input dataset that is to be used.
It defaults to 1 (i.e. first channel).
\item[step] gives the increment between selected input channels. 
\end{description}

The channels are centered on velocities: start, start+step,
start+2*step, etc.  

By choosing the parameters for setdata and setimage correctly,
one may obtain various mappings of visibility channels to image
channels. For example, to average 512 visibility channels into 64 
image channels (producing image channels consisting of 8
visibility channels):

\begin{verbatim}
imgr.setimage(mode='channel', nchan=64, start=1, step=8);
imgr.setdata(mode='channel', nchan=512, start=1, step=1)
imgr.clean();
\end{verbatim}

This averages the spectral channels during the gridding process. If
one wanted to only include every 8th channel in the
deconvolution, one would do:

\begin{verbatim}
imgr.setdata(mode='channel', nchan=64, start=1, step=8)
imgr.setimage(mode='channel', nchan=64, start=1, step=8);
imgr.clean();
\end{verbatim}

For velocity and opticalvelocity modes, the mstart and mstep
are the start and step velocities as strings.

\begin{verbatim}
imgr.setimage(mode='velocity', nchan=64, mstart='20km/s', mstep='-100m/s');
imgr.setdata(mode='velocity', nchan=64, mstart='20km/s', mstep='-100m/s');
imgr.clean();
\end{verbatim}

If the image and data selections differ, then averaging is done during
the gridding and degridding process in the image deconvolution.

\begin{verbatim}
imgr.setimage(mode='channel', nchan=64, start=1, step=8);
imgr.setdata(mode='channel', nchan=512, start=1, step=1)
imgr.clean()
\end{verbatim}

Note:  The channels numbers used in {\tt setimage}
and {\tt setdata} refers to the same channel. So if a channel is not
selected in {\tt setdata} but is selected in {\tt setimage}, then
blank channels image are made. The example below will result in the 
having the first 5 channels in the image to be blank.

\begin{verbatim}
imgr.setdata(mode='channel', nchan=50, start=6, step=1) #selected chan 6-55
imgr.setimage(mode='channel', nchan=50, start=1, step=1); 

# will try to image channel 1-50. But as previously only channel 6-55 
# was selected only channel 6-50 will have data; images of channels
# 1-5 are blank 
imgr.clean()
\end{verbatim}


For multi-spectral window cube imaging the selection of the data can
be done as follows

\begin{verbatim}
imgr.setdata(mode='channel', nchan=[50,60], start=[1,1], step=[1,1],
             spwid=[1,2]) 
imgr.setimage(mode='channel', nchan=110, start=1, step=1, spwid=[1,2]); 

\end{verbatim}

The above means that you would make a data selection of 50 channels
(starting from 1 steping 1) from the first spectral window and 60
channels (starting from 1 steping 1). The setimage defines the image
to be a cube of 110 channels. The caveat is the step size in the
frequency direction is the step size of the first spectral window. If
the step size of channels of the two spectral windows are different
then one is better off defining the image cube in velocities (e.g. as below). 

                                                                      
\begin{verbatim}
imgr.setdata(mode='channel', nchan=[50,60], start=[1,1], step=[1,1],
             spwid=[1,2]) 
imgr.setimage(mode='velocity', nchan=200, mstart='20km/s',
             mstep='-100m/s'); 
	

\end{verbatim}






\end{ahdescription}
\begin{ahargs}
\ahaddarg{mode}{Type of processing: channel or velocity}{}{'channel'|'velocity'}
\ahaddarg{nchan}{Number of channels to select}{1}{Vector of Ints}
\ahaddarg{start}{Start channels (1-relative)}{}{ Vector of Ints}
\ahaddarg{step}{Step in channel number}{}{Vector of Int}
\ahaddarg{mstart}{Start velocity (e.g. '20Km/s')}{}{Quantity}
\ahaddarg{mstep}{Step in velocity (e.g. '100m/s'}{}{Quantity}
\ahaddarg{spwid}{Spectral Window Ids (1 relative) to select}{1}{Vector of Ints}
\ahaddarg{fieldid}{Field Ids (1 relative) to select}{1}{Vector of Ints}
\ahaddarg{msselect}{TQL select string applied as a logical "and" with the other selections}{}{String}
\ahaddarg{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
imgr:=qimager('3C273XC1.MS');
imgr.setdata(nchan=512,start=1,step=1, msselect='SCAN_NUMBER > 10 && FIELD_ID==2)
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{setimage}{Set the image parameters for subsequent processing}
\begin{ahdescription}
Define the default image parameters. If an image is to be
made, then these parameters are used in the construction
of the image. Thus, for example, the tool function \ahlink{make}{qimager:qimager.make}
makes an (empty) image using these parameters. 

Note that some parameters can be specified either in canonical units
or via measures. To establish default values, the ids for the default
spectral window and default field id must be given.

The meaning of arguments mode, nchan, step, {\em etc.} is described in
\ahlink{setdata}{qimager:qimager.setdata}. {\tt qimager} can perform multi-frequency
synthesis over several spectral windows (mode='mfs'). To acheive this,
you should set spwid to an array of the required spectral windows
({\em e.g.}  {\tt spwid=1:2}).\\
WARNING: For multifrequency synthesis, 'mfs', it is important that the spwid's
selected in \ahlink{setdata}{qimager:qimager.setdata} be the SAME as the one
selected in 'setimage'.  Otherwise the frequency at which the  image
is made is not going to be the same as to the one as the one used in
gridding the visibility and can lead to image artifacts.  


The phase center of the image defaults to that of the specified
fieldid (the first if none is specified). This is important if you have 
multiple pointings in the data. The user would have used 
\ahlink{setdata}{qimager:qimager.setdata} to select which pointings 
would be used in imaging. Note that the fieldid refers
to the ordering of fields in a MeasurementSet, and has no connection
with the number of facets in an image. A phase center may be also
specified in an argument to setimage using any valid
\ahlink{direction}{measures:measures.direction}. If the conversion
from the observed direction requires frame information then this
is taken as follows:
\begin{itemize}
\item Direction information, including the coordinate system,
is taken from the relevant entry in the Field table of the
MeasurementSet.
\item The epoch is taken from the time of observation of
each visibility.
\item A position is specified via the {\tt qimager} tool function \ahlink{setoptions}
{qimager:qimager.setoptions}
\end{itemize}

If the specified number of facets is greater than unity then the image
is split into facets (this number along the x and y axes) and
processed. This is necessary when using wide-field algorithm for
deconvolving the image, in cases of non-coplanar arrays (e.g the VLA
at low frequencies but can be safely left at 1 for the ATCA or WSRT).

Finally, a position shift may be added using the arguments shiftx,
shifty. This will be added to whatever the phase center was set to
as described above. The shift is a real angle on the {\tt qimager} so that,
in e.g. RA, DEC, the RA shift is divided by cos(DEC) before being
added to the RA. The sense of the shift is that the position after
addition of the shift gives the new phase center of the image. The
shift is in the reference frame of the phase center.

For spectral imaging {\tt setimage} and {\tt setdata} defines the
spectral channels that are imaged. Examples are given in the
\ahlink{setdata} {qimager:qimager.setdata} section.


\end{ahdescription}
\begin{ahargs}
\ahaddarg{nx}{Total number of spatial pixels in x}{128}{Int}
\ahaddarg{ny}{Total number of spatial pixels in y}{128}{Int}
\ahaddarg{cellx}{Cellsize in x (e.g. '1arcsec')}{'1arcsec'}{Quantity}
\ahaddarg{celly}{Cellsize in y (e.g. '1arcsec')}{'1arcsec'}{Quantity}
\ahaddarg{stokes}{Stokes parameters to image (e.g. 'IQUV')}{'I'}{'I'|'IV'|'IQU'|'IQUV'}
\ahaddarg{doshift}{Use the specified phase center? T or F}{F}{Bool}
\ahaddarg{phasecenter}{Direction of phase center as a measure}{}{MDirection}
\ahaddarg{shiftx}{Shift in x (e.g. '23.7arcsec')}{'0arcsec'}{Quantity}
\ahaddarg{shifty}{Shift in y (e.g. '-54.2arcsec')}{'0arcsec'}{Quantity}
\ahaddarg{mode}{Type of processing}{'mfs'}{'mfs'|'channel'|'velocity'}
\ahaddarg{nchan}{Number of channels}{1}{Int}
\ahaddarg{start}{Start channel (1-relative)}{}{Int}
\ahaddarg{step}{Step in channel}{}{Int}
\ahaddarg{mstart}{Start velocity}{}{MRadialVelocity}
\ahaddarg{mstep}{Step in velocity}{}{MRadialVelocity}
\ahaddarg{spwid}{Spectral Window Ids (1 relative)}{1}{Vector of Ints}
\ahaddarg{fieldid}{Field Id (1 relative)}{1}{Int}
\ahaddarg{facets}{Number of facets on each axis}{1}{Integer}
\ahaddarg{distance}{Distance to object: usually ignore this! (m)}{'0m'}{Quantity}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
## Example 1
imgr.setimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
nchan=1, stokes='IV', doshift=T, phasecenter=dm.direction('mars'));
## Example 2
imgr.setimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
nchan=1, stokes='IV', doshift=T, 
phasecenter=image('othermarsimage').coordmeasures().direction);
## Example 3
myqimager.setdata(mode='channel', nchan=10, start=3, spwid=[1,2], fieldid=[3, 4, 5, 6, 7, 9, 10])
myqimager.setimage(nx=500, ny=500, mode='mfs', spwid=[1,2], fieldid=7)
myqimager.clean(algorithm='mfclark', niter=1000, model='mosaic') 

## Example 4

dir1:=dm.direction('J2000', '20h00m00', '21d00m00')
dir2:=dm.direction('J2000', '20h10m00', '21d00m00')
dir3:=dm.direction('J2000', '20h00m00', '21d03m00')
imgr.setimage(nx=100, ny=100, cellx='0.1arcsec', celly='0.1arsec',
              doshift=T, phasecenter=dir1)
imgr.make('box1')
imgr.setimage(nx=100, ny=100, cellx='0.1arcsec', celly='0.1arsec',
              doshift=T, phasecenter=dir2)
imgr.make('box2')
imgr.setimage(nx=100, ny=100, cellx='0.1arcsec', celly='0.1arsec',
              doshift=T, phasecenter=dir3)
imgr.make('box3')
imgr.clean(algorithm='mfclark', model=['box1', 'box2', 'box3'], 
	   image=['box1.restored', 'box2.restored', 'box3.restored'],
	   residual=['box1.residual', 'box2.residual', 'box3.residual'])



\end{verbatim}
\end{ahexample}
\begin{ahcomments}
In the first example, the image parameters are set for 1024 by 1024
pixels of 30marc, 1 channel will be made, Stokes I and V will be
imaged, and the phasecenter will be the direction of Mars as given by
the JPL DE-200 emphemeris. In the second, the phase center is taken
to be that of the reference pixel of another image.

The third example shows the use of setdata and setimage to setup a mosaic. In 
the set data we have chosen 10 channels (for each IF) of data starting form 
channel 3. We also have selected IF 1 and 2. We have selected data from 
fields 3 to 10. In the setimage we decide to use the data to make a 
multifrequency synthesis image. We center the image on the field 7 pointing.  

The fourth example is use to clean regions where the user knows the
sources are and ignore all the other regions. This is very efficient
in large fields with few sources. Smaller images are made and
deconvolved around known sources rather than making a big image
englobing all three fields. Care should be taken in NOT overlapping
the regions imaged this way otherwise the deconvolution will fail.

\end{ahcomments}



\end{ahfunction}

\begin{ahfunction}{advise}{Advise (and optionally use) parameter values}

\begin{ahdescription}
Advise on recommended values of certain parameters. Return these
values and optionally use them in Qimager.

The calculations are performed as following:

\begin{description}
\item[cell] The maximum uv distance in wavelength is found and then half of the
inverse is taken as the maximum cellsize allowed.
\item[pixels] The field of view is converted to a number of pixels
using the calculated cell size.
\item[facets] The number of facets on an axis is calculated in two
different ways. The first method simply requires that the peeling of 
facets away from the celestial sphere should not cause an amplitude
drop of more than the argument {\tt amplitudeloss}. The positions may
be incorrect, but all the sources will be removed correctly. The
second method requires that the source positions be accurate to the
same fraction of the beam specified by {\tt amplitudeloss}. The 
second calculates the second moment in w and in uv distance and
chooses the number of facets correspondingly. The first method does
the same but after fitting a plane to the sampling: $w = a u + b v$.
For an approximately coplanar array, the positions may be wrong but
the removal of sidelobes will be accurate. The number of facets
returned is the second, usually smaller, number. The formula used
is:
\begin{equation}
N_{facets} = N_{pixels} \sqrt{{{\Delta \theta}\over{\sqrt{8 \delta A}}}{w_{rms}}\over{uv_{rms}}}
\end{equation}
where $\Delta \theta$ is the cellsize in radians, and $\delta A$ is
the amplitude loss. This formula can be derived from (a) the peeling
of facets from the celestial sphere, and (b) a quadratic approximation 
for the beam size both in the plane of the sky and along the $w$ axis.
\end{description}


\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{takeadvice}{Use the advised values?}{T}{Bool}
\ahaddarg[in]{amplitudeloss}{Maximum fractional amplitude loss due to faceting}{0.05}{Float}
\ahaddarg[in]{fieldofview}{Desired field of view}{'1deg'}{Quantity}
\ahaddarg[out]{pixels}{Number of pixels on a side}{}{Int}
\ahaddarg[out]{cell}{Recommended maximum cellsize}{}{Quantity}
\ahaddarg[out]{facets}{Recommended number of facets on one axis}{}{Integer}
\ahaddarg[out]{phasecenter}{Direction of phase center as a measure}{}{MDirection}
\end{ahargs}
\end{ahfunction}

\begin{ahfunction}{make}{Make an empty (i.e. blank) image}
\begin{ahdescription}
Make an empty image using the current image parameters. Often this is
unnecessary, but you will typically need to use this if you wish to
deconvolve a set of images. The steps are to make the empty images
that you require to be deconvolved, and then pass them into clean as a
vector of strings.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{image}{name of output image}{}{String}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.setimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
nchan=1, stokes='IV', phasecenter=dm.direction('mars'));
imgr.make('mars.moving');
imgr.setimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
nchan=1, stokes='IV', 
phasecenter=dm.direction('j2000', '12:23:48.7', '-15:56:32.9')
imgr.make('mars.fixed');
imgr.clean(algorithm='mf', model=['mars.moving', 'mars.fixed'],
image=['mars.moving.restored', 'mars.fixed.restored'])
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
This makes two empty images, one moving with mars and one fixed
in j2000, and then deconvolves the two jointly using clean.
Finally the images are restored.
\end{ahcomments}
\end{ahfunction}

\begin{ahfunction}{regionmask}{Construct a mask image from a region}
\begin{ahdescription}
A mask image is an image with the same shape as the other images but
with values between 0.0 and 1.0 as a pixel value. Mask images are used in
qimager to control the region selected in a deconvolution. 

In the Clark CLEAN, the mask image can usefully have any value between
0.0 and 1.0. Intermediate value is discouraged but do not rule out
selection of clean components in that region. This is accomplished by
multiplying the residual image by the mask prior to entering the minor
cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
it must cover only a quarter of the image. boxmask does not enforce
this requirement. 

The function regionmask also allows multiple regions to be used. A record of the regions can be made as in the example below. 

Regions can be made in many different ways using the
\ahlink{regionmanager}{images:regionmanager} functions. An example
using \ahlink{wbox}{images:regionmanager.wbox} function is given
below. The default regionmanager tool 'drm' can be used for most
cases unless it is already set for some other images.

For gui users regions to be masked can be made from an image:

\begin{itemize}

\item  Fill in the desired name of the mask.

\item On the ``Spanner'' button for the region, select the 'FromImage'.

\item This will pop a catalogue GUI, select the image you want to use
a template to draw mask and press the 'send \& Dismiss' button. This 
will display the image using the viewer.

\item  To set a polygonal region, click once on the bottommost button on
the lefthand side of the viewer (clue: it looks like a polygon with a
letter 'R' on it). Then set the vertices of the polygon by left-clicking
each in turn. Finish with a double click on the last vertex and then
another double click inside the polygon.

\item  In the region box a name of the region like 'myregion1' will appear.

\item Press the ``Go'' button for \texttt{qimager:regionmask}.

\end{itemize}

Now to set multiple regions a 'union of  regions' can be easily made
by using the viewer in step 3 above. Under the Tools menu, select
'ImageAnalysis'. A box of rollups will appear. Select the region
rollup.  Select 'union' and press 'Start'. Then on the viewer click on
one of the Region making buttons (the two bottom most buttons on the
left margin with 'R's on them). After making a region click twice
inside. The 'accumulate' on the Region rollup should increment. Keep
repeating this process of making a region at different places and
clicking twice in (remember 'ESC' key is used to get rid of a box you
have drawn before drawing the next one).  Press on the 'Finish' button
and dismiss the rollup and viewer. A region with a name like
'myregion1' would have appeared in the region box, which represent a
union of all the regions the user has selected.

For script writers who still want to interactively set the regions,
 a call to the {gopher}{widgets:gopher} tool can used. 

\end{ahdescription}
\begin{ahargs}
\ahaddarg{mask}{name of mask image}{}{String}
\ahaddarg{region}{Region}{unset}{Any valid region or a record of regions}
\ahaddarg{value}{Value to set the mask to}{1.0}{Any scalar}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}

The following  the image bigmask, and then sets the inner quarter to unity. Then cleans using it as the mask.

- imgr.regionmask(mask='bigmask', region=drm.quarter())
- imgr.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)

Another example using drm.wbox function: 
- im:=image('dirty')
- cs:=im.coordsys()
- drm.setcoordinates(cs,F)
- r1:=drm.wbox(blc=['173pix', '347pix'], trc=['183pix', '370pix'])
- imagr.regionmask(mask='bigmask',region=r1)

Or using a record of regions:

- r2:=drm.wbox(blc=['180pix', '344pix'], trc=['191pix', '369pix'])
- r3:=drm.wbox(blc=['189pix', '341pix'], trc=['204pix', '364pix'])
- rec:=[=]
- rec[1]:=r1
- rec[2]:=r2
- rec[3]:=r3
- imagr.regionmask(mask='bigmask',region=rec)

\end{verbatim}

Now one may wish to make regions and later use it with higher
resolution images etc. Regions can be stored in tables on disk and
recovered later for re-use (especially if its a long series of regions
making using the gui as described above. 

\begin{verbatim}
- drm.fromglobaltotable('mytab.region', 'T', 'F', "myregionoftoday", myregion1) 
\end{verbatim}

The above command using the default regionmanager tool saves the
region 'myregion1' into a table 'mytab.region'
Subsequently this table is used to recover the region and use it to
create a mask image as below. We use the function drm.namesintable()
to remind ourselves under what names the regions was saved and hence
allow us to pick the one we want.

\begin{verbatim}

- drm.namesintable('mytab.region')

myregionoftoday

- myoldregion:=drm.fromtabletoglobal('mytab.region', T, 'myregionoftoday')

- imagr.regionmask(mask='newmask',region=myoldregion)
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{exprmask}{Construct a mask image from a LEL expression}
\begin{ahdescription}
A mask image is an image with the same shape as the other images but
with values between 0.0 and 1.0 as a pixel value. Mask images are used in
qimager to control the region selected in a deconvolution. 

In the Clark CLEAN, the mask image can usefully have any value between
0.0 and 1.0. Intermediate value discourage but do not rule out
selection of clean components in that region. This is accomplished by
multiplying the residual image by the mask prior to entering the minor
cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
it must cover only a quarter of the image. boxmask does not enforce
this requirement.

This function allows Lattice Express Language (LEL) expressions to
be used in defining a mask. See the documentation on 
\ahlink{imagecalc}{images:image.imagecalc.constructor} for more details.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{mask}{name of mask image}{}{String}
\ahaddarg{expr}{Value to set the mask to}{1.0}{Any scalar or LEL expression}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.exprmask(mask='bigmask', expr='"3C273XC1.clean">0.5')
imgr.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Makes the image bigmask, and then sets it to unity for all points in
the region where 3C273XC1.clean is greater than 0.5Jy.
Then cleans using it as the mask.
\end{ahcomments}
\end{ahfunction}
%
\begin{ahfunction}{makeimage}{Calculate images by gridding, etc.}
\begin{ahdescription}
This tool function actually does gridding (and Fourier inversion if
needed) of visibility data to make an image. It allows calculation of
various types of image:
\begin{description}
\item[observed] Make the dirty image from the DATA column 
\item[model] Make the dirty image from the MODEL\_DATA column
\item[corrected] Make the dirty image from the CORRECTED\_DATA column
({\em default})
\item[residual] Make the dirty image from the difference of the
CORRECTED\_DATA and MODEL\_DATA columns
\item[psf] Make the point spread function
\item[singledish] Make a single dish image
\item[coverage] Make a single dish coverage image
\item[holography] Make a complex holography image
\end{description}

Note the full {\tt qimager} equation is not used and so, for example, the
primary beam correction is not performed. Use
\ahlink{restore}{qimager:qimager.restore} to get a residual image
using the full {\tt qimager} equation where primary beam correction is
performed.

A position shift can be applied when specifying the image parameters
with \ahlink{setimage}{qimager:qimager.setimage}. If a shift is specified then
the uvw coordinates are reprojected prior to gridding, and a phase
rotation is applied. If the image is a PSF then no phase shift is
applied but the uvw are recomputed. To see the effects of the uvw
reprojected, you can use the
\ahlink{plotuv}{qimager:qimager.plotuv} function.

If desired, the full complex image (before conversion to stokes
I,Q,U,V) may be retained. Note that the \ahlink{image}{images:image}
tool cannot load a complex image directly. Instead, use the
\ahlink{imagecalc}{images:image.imagecalc.constructor} constructor 
to take {\em e.g.}  the real and imaginary parts of the image.

For making single dish and holography images, the data are convolved onto the
grid using a one of a number of options:
\begin{description}
\item[gridfunction='SF'] Circularly symmetric prolate spheroidal wavefunction. 
This is always the same function in pixels.  To get this to match to
the antenna primary beam, the optimum cellsize to use in constructing
the image is the antenna primary beam half-width-half-maximum times
1.20192.
\item[gridfunction='BOX'] Nearest neighbor gridding.
\item[gridfunction='PB'] The telescope primary beam is used as the
convolution function. This function is the same in arcseconds,
independent of the cellsize. This choice is optimum in the least
squares sense. To override the default choice of telescope primary beam
for a given telescope, use the function
\ahlink{setvp}{synthesis:qimager.qimager.setvp}. Usually the default will be acceptable.
\end{description}

To make a reasonable approximation to the sky, one should divide
the type='singledish' image by the type='coverage' image, thresholding
at some level. For example:

\begin{verbatim}
include 'image.g';
imcov  := image('scanweight'); imcov.view();
s:=0; imcov.statistics(s);	
threshold := s.max / 10.0;
#
im:=imagecalc('sdimage',
	      pixels=spaste('scanimage[scanweight>', threshold,
			    ']/scanweight[scanweight>', threshold, ']'))
im.view(raster=T, axislabels=T);
\end{verbatim}

\end{ahdescription}
\begin{ahargs}
\ahaddarg{type}{Type of output image}{}{String}
\ahaddarg{image}{Name of output image}{}{String}
\ahaddarg{compleximage}{Name of output complex image}{}{String}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.ft(model='3C273XC1.model', complist='3C273XC1.complist');
imgr.image(type='residual', image='3C273XC1.residual')
imgr.image(type='psf', image='3C273XC1.psf')
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Fill in the MODEL\_DATA column from Fourier transforming the model and
the componentlist.  Make the residual image and write it to
3C273XC1.residual. 
\end{ahcomments}
\end{ahfunction}
%
\begin{ahfunction}{weight}{Apply additional weighting to the visibility weights}
\begin{ahdescription}
Apply visibility weighting to correct for the local density of
sampling in the uv plane. The imaging weights are written into a Table
column called IMAGING\_WEIGHT, which may be plotted using 
\ahlink{plotweights}{qimager:qimager.plotweights}. In addition this
columns may be accessed directly using either the
\ahlink{table}{table} or \ahlink{ms}{ms} modules.

To correct for visibility sampling effects, natural, uniform (the
default), radial, and Briggs weighting are supported.  These work as
follows. Then:
\begin{description}
\item[natural]: minimizes the noise in the dirty image. The weight of
the $i$-th sample is set to the inverse variance:
\begin{equation}
w_i={1\over{\sigma_i^2}}
\end{equation}
where $\sigma_i$ is the noise of the $i$'th sample.
\item[radial]: approximately minimizes rms sidelobes for an east-west synthesis
array. The weight of the $i$-th sample is multiplied
by the radial distance from the center of the $u,v$ plane:
\begin{equation}
w_i=w_i \sqrt{u_i^2+v_i^2}
\end{equation}
\item[uniform]: For Briggs and uniform weighting, we first grid the inverse
variance $w_i$ for all selected data onto a grid of size given by the
argument npixels (default to nx) and u,v cell-size given by
$2/$fieldofview where fieldofview is the specified field of view
(defaults to the image field of view).  This forms the gridded weights
$W_k$. The weight of the $i$-th sample is then changed:
\begin{equation}
w_i={w_i\over{W_k}}
\end{equation}
where $W_k$ is the gridded weight of the relevant cell.
It may be shown that this minimizes rms sidelobes over
the field of view. By changing the field of view, one may suppress
the sidelobes over a region different (usually smaller) than the
image size.
\item[briggs: rmode='norm']: The weights are changed:
\begin{equation}
w_i={w_i\over{1 + W_k f^2}}
\end{equation}
where:
\begin{equation}
f^2={{(5*10^{-R})^2}\over{{\sum_k W_k^2}\over{\sum_i w_i}}}
\end{equation}
and $R$ is the robust parameter. The scaling of $R$ is such that
$R=0$ gives a good tradeoff between resolution and sensitivity.
$R$ takes value between -2.0 (close to uniform weighting) to 2.0
(close to natural).
\item[briggs: rmode='abs']: The weights are changed:
\begin{equation}
w_i={w_i\over{W_k*R^2+2*\sigma_R^2}}
\end{equation}
where $R$ is the robust parameter and $\sigma_R$ is the noise
parameter. 
\end{description}
For more details about Briggs (aka robust) weighting, see the \htmladdnormallink{Briggs thesis}
{\briggsURL}.

Note that this weighting is {\em not} cumulative since the imaging weights are
calculated from the specified sigma (expected noise) per visibility
(actually stored in the SIGMA column).

\end{ahdescription}
\begin{ahargs}
\ahaddarg{type}{Type of weighting}{uniform}{String: 'uniform'|'natural'|'briggs'|'radial'}
\ahaddarg{rmode}{Mode of briggs weighting}{none}{String: 'norm'|'abs'|'none'}
\ahaddarg{noise}{Noise used in absolute briggs weighting}{'0.0Jy'}{Quantity}
\ahaddarg{robust}{Parameter in briggs weighting}{0.0}{Double: range
-2.0 to 2.0}
\ahaddarg{fieldofview}{Field of view for uniform weighting}{'0arcsec'}{Quantity}
\ahaddarg{npixels}{Number of pixels in the u and v directions}{0}{Int}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.weight(type='briggs', rmode='norm', robust=0.5)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Applies Briggs (robust) weighting.
\end{ahcomments}
\end{ahfunction}

\begin{ahfunction}{sensitivity}{Calculate rms  sensitivity}
\begin{ahdescription}
Calculate the point source sensitivity for the selected data, both
absolutely and relatively (to that for natural weighting).

To do the calculation, we use the imaging weights (in the 
column called IMAGING\_WEIGHT) and the specified sigma per point
(in the column SIGMA). Therefore, this includes all the effects
of \ahlink{weight}{qimager:qimager.weight} and \ahlink{filter}{qimager:qimager.filter}.

\end{ahdescription}
\begin{ahargs}
\ahaddarg[out]{pointsource}{Calculated point source sensitivity (Jy/beam)}{}{Quantity}
\ahaddarg[out]{relative}{Calculated relative sensitivity}{}{Double}
\ahaddarg[out]{sumweights}{Calculated sum of weights}{}{Double}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}

\begin{ahexample}
\begin{verbatim}
local s,r,sum
ok := imgr.sensitivity(s,r,sum,F)
print 'Sensitivity = ', s
print 'Relative to Natural Weighting = ', r
\end{verbatim}
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
imgr.sensitivity()
# Wait for it to finish and then ask for the result:
- defaultservers.result(1)
[pointsource=[value=0.25, unit='Jy'], relative=2.5, sumweights=642085.45]
\end{verbatim}
\end{ahexample}

\end{ahfunction}
%
\begin{ahfunction}{filter}{Apply additional weighting by filtering (u-v taper)}
\begin{ahdescription}
Apply visibility tapering to emphasize certain scale structures.  The
imaging tapers are applied to a Table column called IMAGING\_WEIGHT,
which may be plotted using 
\ahlink{plotweights}{qimager:qimager.plotweights}. In addition, this column
may be accessed directly using either the \ahlink{table}{table}
or \ahlink{ms}{ms} modules. Note that the taper is multiplicative and
so the weights must be calculated first using
\ahlink{weight}{qimager:qimager.weight}. The points are not flagged!

Note that the scale size to be emphasized is given in the image plane
as the parameters of the corresponding Gaussian. Note also use of this
function provides an optimum detection for the given scale size, which
is not the same as requiring that the resulting dirty beam have the
specified Gaussian fit. The resultant fitted beam size will {\em very
roughly} be the quadratic sum of the original beam and the specified
beam. If you wish to obtain a specified beam, then the best approach
is to perform this calculation and check the value obtained using
\ahlink{qimager.fitpsf}{qimager:qimager.fitpsf}.

\end{ahdescription}
\begin{ahargs}
\ahaddarg{type}{Type of filtering or u-v tapering}{gaussian}{String}
\ahaddarg{bmaj}{Major axis of filter}{'0rad'}{Quantity}
\ahaddarg{bmin}{Minor axis of filter}{'0rad'}{Quantiy}
\ahaddarg{bpa}{Position angle of filter}{'0deg'}{Quantity}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.weight('uniform')
imgr.filter(type='gaussian', bmaj='2.3arcsec', bmin='1.67arcsec',
bpa='-34.5deg')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{uvrange}{Select data within the limit of a given range}
\begin{ahdescription}
Apply a uvrange so that only points within a given uvrange are selected for further usage.  To be noted \ahlink{setdata}{qimager:qimager.setdata} if used after uvrange will reset the selected range. So setdata should be used prior to uvrange or can be used 











to reset it if one changes one's mind. The points are not flagged! Further point to be noted for spectral line data the uv distance is calculated using the mean of the wavelengths of the different spectral channels selected. 

\end{ahdescription}
\begin{ahargs}
\ahaddarg{uvmin}{Minimum uv distance allowed (wavelengths)}{0.0}{Float}
\ahaddarg{uvmax}{Maximum uv distance allowed (wavelengths)}{0.0}{Float}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.weight('uniform')
imgr.uvrange(0, 4000.0)
\end{verbatim}
\end{ahexample}
\end{ahfunction}
%
\begin{ahfunction}{fitpsf}{Fit the point spread function, making psf image first if needed}
\begin{ahdescription}
This fits an elliptical Gaussian to the point spread function
and returns the fitted beam parameters. If psf image is not specified
then a psf is made and used. The values for the beam fit
are saved internally and used whenever needed (for example in the functions \ahlink{restore}{qimager:qimager.restore} or \ahlink{smooth}{qimager:qimager.smooth}) until invalidated. The values
are invalidated by setdata, setimage or any tool function that changes
the weights. Use the function \ahlink{summary}{qimager:qimager.summary} to check if there is a valid fitted psf stored internally.
 
\end{ahdescription}
\begin{ahargs}
\ahaddarg{psf}{Name of input psf}{}{String}
\ahaddarg{bmaj}{Major axis of beam}{}{Quantity record}
\ahaddarg{bmin}{Minor axis of beam}{}{Quantity record}
\ahaddarg{bpa}{Position angle of beam}{}{Quantity record}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.makeimage(type='psf', image='3C273XC1.psf')
- majaxis:=[=]; minaxis:=[=]; pangle:=[=]
- imgr.fitpsf('3C273XC1.psf', bmaj=majaxis, bmin=minaxis, bpa=pangle, async=F)
- print bmaj, bmin, bpa
- imgr.restore(model='bla' , complist='', image='bla.restored' , residual='bla2.residual' )
\end{verbatim}

Or if one wants to generate a psf from the uv coverage and use that subsequently as in the  following example:

\begin{verbatim}
- imgr.fitpsf(psf='')
- imgr.restore(model='bla' , complist='', image='bla.restored' , residual='bla2.residual' )
\end{verbatim}

\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{setbeam}{Set the beam parameters for clean restoration}
\begin{ahdescription}
This sets the clean beam that will be used in all restoration
operations.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{bmaj}{Major axis of beam}{}{Quantity record}
\ahaddarg{bmin}{Minor axis of beam}{}{Quantity record}
\ahaddarg{bpa}{Position angle of beam}{}{Quantity record}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\end{ahfunction}


\begin{ahfunction}{clean}{Calculate a deconvolved image with selected clean algorithm}
\begin{ahdescription}
Makes a clean image using either the Hogbom, Clark, multi-scale or multi-field
algorithms. The Clark algorithm is the default. The clean is performed
on the residual image calculated from the visibility data currently
selected. Hence the first step performed in clean is to transform the
current model or models (optionally including a componentlist) to fill
in the MODEL\_DATA column, and then inverse transform the residual
visibilities to get a residual image. This residual image is then
cleaned using the corresponding point spread function. This means that
the initial model is used as the starting point for the
deconvolution. Thus if you want to restart a clean, simply set the
model to the model that was previously produced by clean.

Rather than explicit CLEAN boxes, mask images are used to constrain
the region that is to be deconvolved. To make mask images,
use either \ahlink{boxmask}{qimager:qimager.boxmask} (to define a mask
via the corner locations blc and trc) or 
\ahlink{mask}{qimager:qimager.mask} (to define a mask via
thresholding an existing image) or \ahlink{regionmask}{qimager:qimager.regionmask} (to make masks via regions using the regionmanager or interactively through the viewer)  . The default mask is the inner quarter
of the image.

The CLEAN deconvolution is joint in whatever Stokes parameters are
present. Thus it searchs for peaks in either $I$ or $I+|V|$ or
$I+\sqrt{Q^2+U^2+V^2}$, the rationale for the latter two forms being
to be biased towards finding strongly polarized pixels first (these
forms are also the maximum eigenvalue of the coherency matrix).  The
PSF is constrained to be the same in all polarizations (a feature of
this implementation, not of the Hamaker-Bregman-Sault formalism).

The clean algorithms possible are:
\begin{description}
\item[Hogbom] The classic algorithm: points are found iteratively
by searching for the peak. Each point is subtracted from the
full residual image using the shifted and scaled point spread
function.
\item[Multiscale] An experimental multi-scale clean algorithm is invoked.
The algorithm is fully described in 
\ahlink{deconvolver}{deconvolver:deconvolver.clean}.
\item[Clark] The faster algorithm: the cleaning is split into
minor and major cycles. In the minor cycles only the brightest
points are cleaned, using a subset of the point spread function.
In the major cycle, the points thus found are subtracted correctly
by using an FFT-based convolution.
\item[Multi-field] Cleaning is split into minor and major
cycles. For each field, a Clark-style minor cycle is performed. 
In the major cycle, the points thus found are subtracted
either from the original visibilities (for multiple fields)
or using a convolution (for only one field). The latter is
much faster.  Multi-field imaging has been implemented for
Clark, Hogbom, and Multi-scale deconvolution algorithms.
\item[Cotton-Schwab] Cleaning is split into minor and major
cycles. For each field, a Clark-style minor cycle is performed. 
In the major cycle, the points thus found are subtracted
from the original visibilities. A fast variant does a convolution
using a FFT. This will be faster for large numbers of
visibilities. Double the image size from that used for Cotton-Schwab
and set a mask to clean only the inner quarter.
\item[Wide-field] The user will need to use a wide-field algorithm to
deconvolve if the array is not coplanar over the field of view being
imaged . The technique used is to break the field being imaged into
smaller pieces (facets), over each of which the array appear
planar. We implement a rectangular facetting scheme. If the number of
facets specified in \ahlink{setimage}{qimager:qimager.setimage} is
greater than one, Either wfhogbom or wfclark algorithm has to be
selected here to perform a wide-field decovolution. The function
\ahlink{advise}{qimager:qimager.advise} can be used to calculate or
check if you need to use a wide-field deconvolution. Note that
aliasing can be reduced by using the {\tt padding} argument in
\ahlink{setoptions}{qimager:qimager.setoptions}. In practice the
previous sentence means that if you notice the clean to diverge at the
edges of the facets then you need to use a larger amount of padding
for the FT; the default being 1.2. Wide-field imaging has been
implemented for Clark and Hogbom algorithms.
\end{description}

The multi-field clean should be used if either of two conditions
hold:
\begin{enumerate}
\item Multiple fields are to be cleaned simultaneously {\bf OR}
\item Primary beam correction is enabled. In this case, a
mosaiced clean is performed.
\end{enumerate}

Note that for the single pointing algorithms, only a quarter of the
image may be cleaned. If no mask is set, then the cleaned region
defaults to the inner quarter. If a mask larger than a quarter of the
image is set, then only the inner quarter part of that mask is used.
However, for the wide-field and multi-field imaging (including the
Cotton-Schwab algorithm), the entire field may be imaged because the
major cycles either do an exact subtraction from the visibilities or
because PSF extent is more than twice the extent of the primary beam
support.

Before {\tt clean} can be run, you must run {\tt setdata} and {\tt setimage}.
Before {\tt clean} can be run with a multi-field algorithm, you should run
{\tt setvp}.  You may want to run {\tt setmfcontrol} before running {\tt clean}
with a multi-field or wide-field algorithm, though the default control values
may be acceptable.  Before {\tt clean} can be run with a multi-scale algorithm,
{\tt setscales} must be run.

Interactive cleaning/masking: If the user wants to see what the clean
image looks like after npercycle iteration and mask or modify the mask
each time, he/she should set interactive=T and give npercycle to a
fraction of niter. A viewer with the last residual image along with an
overlayed mask appear after every npercycle iteration. The user can
add or delete regions (by clicking on the appropriate button) to the
mask using the region button and drawing regions and double clicking
inside the region. Use 'refresh mask' to review the recent changes in
the mask. When satisfied and ready to continue cleaning press 'DONE
with masking' (if the user want to terminate the cleaning process use
the 'STOP' button). The button 'No more mask changes' should be used
if the user want clean to proceed without any further interruption.
PLEASE be patient and wait for the viewer to load both the image and
mask before clicking on the buttons or drawing regions. If impatient
please use interactive=F. Even if interactive=F, and if the parameter
'mask' is non-empty, it is still used in limiting the search area for
clean components.
If the parameter 'masktemplate' is not empty this means that the user
want to use a prior image to make the mask  the first time (e.g
a previously cleaned image) 



\end{ahdescription}
\begin{ahargs}
\ahaddarg{algorithm}{Algorithm to use}{'clark'}{String:'clark'|'hogbom'|'multiscale'|'mfclark'|'csclean'|'csfast'|
'mfhogbom'|'mfmultiscale'|'wfclark'|'wfhogbom'}
\ahaddarg{niter}{Number of Iterations, set to zero for no CLEANing}{1000}{Int}
\ahaddarg{gain}{Loop Gain for CLEANing}{0.1}{Float}
\ahaddarg{threshold}{Flux level at which to stop CLEANing}{'0Jy'}{Quantity}
\ahaddarg{displayprogress}{Display the progress of the cleaning?}{F}{Bool}
\ahaddarg{model}{Names of clean model images}{}{Vector of strings}
\ahaddarg{fixed}{Keep one or more models fixed}{F}{Vector of booleans}
\ahaddarg{complist}{Name of component list}{}{String}
\ahaddarg{mask}{Names of mask images used for CLEANing}{}{Vector of strings}
\ahaddarg{image}{Names of restored images}{}{Vector of strings}
\ahaddarg{residual}{Names of residual images}{}{Vector of strings}
\ahaddarg{interactive}{whether to stop clean and interactively mask}{F}{Boolean}
\ahaddarg{npercycle}{If interactive is 'T', then no of iter of clean 
before stopping, usually a fraction of niter}{100}{Int}
\ahaddarg{masktemplate}{If non empty then will use this image to make
the mask the first time}{''}{String}
\ahaddarg{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.clean(model='3C273XC1.clean.model',
mask='3C283XC1.mask', niter=1000, gain=0.25, threshold='0.03Jy')
\end{verbatim}

A few points should be noted in this example:

\begin{itemize}
\item When the mask parameter is specified, the number of mask images
      listed should be equal to the number of model images.  They
      should also have the same coordinate system as their
      corresponding model images.  
\item If one or more model images are listed in the model parameter
      but the image and residual parameters are empty, the restored
      and residual images are automatically named as the model names
      appended with '.restored' and '.residual', respectively.
\item No restored image is made if the image string is explicitly unset.
\end{itemize}

\begin{verbatim}
include 'qimager.g';
msfile := 'vlac125K.ms';
imgr:=qimager(msfile);
npix := 500; cell:='5arcsec';
#
# CS on 500 by 500
#
imgr.setimage(nx=npix, ny=npix, cellx=cell, celly=cell, stokes='I',
	      spwid=[1,2]);i
imgr.setoptions(padding=1.0);
imgr.setdata(spwid=[1,2]);
imgr.clean('cs', model='vlac125K.cs', image='vlac125K.cs.restored',
	   niter=1000, gain=0.1);
#
# CSF on 1000 by 1000, cleaning inner quarter
#
include 'regionmanager.g';
imgr.setimage(nx=2*npix, ny=2*npix, cellx=cell, celly=cell, stokes='I',
	      spwid=[1,2]);
imgr.regionmask('vlac125K.mask', region=drm.quarter());
imgr.clean('csf', model='vlac125K.csf', image='vlac125K.csf.restored',
	   mask='vlac125K.mask', niter=1000, gain=0.1);

#
# CS on 1000 by 1000, cleaning entire image
#
include 'regionmanager.g';
imgr.setimage(nx=2*npix, ny=2*npix, cellx=cell, celly=cell, stokes='I',
	      spwid=[1,2]);
imgr.clean('cs', model='vlac125K.csl', image='vlac125K.csl.restored',
	   mask='vlac125K.mask', niter=1000, gain=0.1);

imgr.done();
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{mem}{Calculate a deconvolved image with selected mem (maximum entropy) algorithm}
\begin{ahdescription}
Makes a mem image using either the Cornwell-Evans maximum entropy or
maximum emptiness algorithms, using the single field or multi-field
contexts. The maximum entropy algorithm is the default. The mem is performed
on the residual image calculated from the visibility data currently
selected. Hence the first step performed in mem is to transform the
current model or models (optionally including a componentlist) to fill
in the MODEL\_DATA column, and then inverse transform the residual
visibilities to get a residual image. This residual image is then
deconvolved using the corresponding point spread function. This means that
the initial model is used as the starting point for the
deconvolution. Thus if you want to restart a mem, simply set the
model to the model that was previously produced by clean.

Mask images are used to constrain the region that is to be
deconvolved. To make mask images, use either
\ahlink{boxmask}{qimager:qimager.boxmask} (to define a mask via the
corner locations blc and trc) or \ahlink{mask}{qimager:qimager.mask} (to
define a mask via thresholding an existing image). The default mask is
the inner quarter of the image.

The MEM deconvolution only operates on one Stokes parameter at a time.
Joint MEM deconvolution for multiple Stokes parameters will be
implemented in the future.

The mem algorithms possible are:
\begin{description}
\item[Cornwell-Evans Maximum Entropy (entropy)] The classic "vm" or "vtess" 
deconvolution algorithm.
\item[Cornwell-Evans Maximum Emptiness (emptiness)] The historic, but 
largely undocumented, modification to the Cornwell-Evans algorithm
which seeks a model image which is consistent with the data and
simultaneously minimizes the number of pixels with no emission
(meaning "with pixel values below the noise level").
\item[Multi-field Maximum Entropy (mfentropy)] Deconvolution is split
into minor and major cycles. For each field, the MEM analog of a Clark
Clean minor cycle is performed. In the major cycle, the emission thus
modelled is subtracted either from the original visibilities (for
multiple fields) or using a convolution (for only one field). The
latter is much faster.
\item[Multi-field Maximum Emptiness (mfemptiness)] Just like {\tt mfentropy},
but with emptiness.
\end{description}

The multi-field mem ({\tt mfentropy} or {\tt mfemptiness}) should be
used if either of two conditions hold:
\begin{enumerate}
\item Multiple fields are to be deconvolved simultaneously {\bf OR}
\item Primary beam correction is enabled. In this case, a
mosaiced mem is performed.
\end{enumerate}

Note that for the single pointing algorithms, only a quarter of the
image may be deconvolved. If no mask is set, then the deconvolved
region defaults to the inner quarter. If a mask larger than a quarter
of the image is set, then only the quarter starting at the bottom left
corner is used.  However, for the multi-field imaging, the entire
field may be imaged because the major cycles either do an exact
subtraction from the visibilities or because PSF extent is more than
twice the extent of the primary beam support.

Before {\tt mem} can be run, you must run {\tt setdata} and {\tt setimage}.
Before {\tt mem} can be run with a multi-field algorithm, you should run
{\tt setvp}.  You may want to run {\tt setmfcontrol} before running {\tt mem}
with a multi-field algorithm, though the default control values
may be acceptable. 

\end{ahdescription}
\begin{ahargs}
\ahaddarg{algorithm}{Algorithm to use}{'entropy'}{String:'entropy'|'emptiness'|'mfentropy'|'mfemptiness'}
\ahaddarg{niter}{Number of Iterations}{20}{Int}
\ahaddarg{sigma}{Image sigma to try to achieve}{'0.001Jy'}{Quantity}
\ahaddarg{gain}{Gain for step}{0.3}{Float}
\ahaddarg{targetflux}{Target flux for final image}{'1.0Jy'}{Quantity}
\ahaddarg{constrainflux}{Constrain image to match target flux? else targetflux used only to initialize model}{F}{Bool}
\ahaddarg{displayprogress}{Display the progress of the cleaning?}{F}{Bool}
\ahaddarg{model}{Names of model images}{}{Vector of strings}
\ahaddarg{fixed}{Keep model fixed}{F}{Vector of booleans}
\ahaddarg{complist}{Name of component list}{}{String}
\ahaddarg{prior}{Names of mem prior images}{}{Vector of strings}
\ahaddarg{mask}{Names of mask images (0=>no emission, 1=>emission permitted}{}{Vector of strings}
\ahaddarg{image}{Names of restored images}{}{Vector of strings}
\ahaddarg{residual}{Names of residual images}{}{Vector of strings}
\ahaddarg{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.mem(model='3C273XC1.mem.model',
mask='3C283XC1.mask', niter=40, sigma='0.001Jy')
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{nnls}{Calculate a deconvolved image using the 
NNLS algorithm} 

\begin{ahdescription} 

Solve for the model brightness using the Briggs' Non-Negative Least
Squares algorithm. Since NNLS works only on the $I$ image, the $I$
pixels in the current image is set to zero where the fluxmask is $>
0.0$, then NNLS is used to estimate the $I$-pixels for that region.
The deconvolution is performed on the residual image calculated from
the visibility data currently selected. Hence the first step performed
in clean is to transform the current model to fill in the MODEL\_DATA
column, and then inverse transform the residual visibilities to get a
residual image. This residual image is then deconvolved using the
corresponding point spread function.

Some other points to remember are that rather than explicit boxes,
mask images are used to constrain the region that is to be
deconvolved.  For NNLS, there are two masks, the fluxmask specifying
the region within which flux is allowed, and the datamask specifying
the region of the dirty image to be used as constraints. Typically the
datamask will be somewhat larger than the fluxmask. On a large
machine, a practical limit to both will be about 5000-6000
pixels. Hence NNLS is only useful for compact tools.  (For more
details, see the \htmladdnormallink{Briggs thesis}{\briggsURL}).  To
make mask images, use either \ahlink{boxmask}{qimager:qimager.boxmask} (to
define a mask via the corner locations blc and trc) or
\ahlink{mask}{qimager:qimager.mask} (to define a mask via
thresholding an existing image).

On the canonical \aipspp\ machine with 64MBytes of physical memory,
you should try to keep the product of the pixels in the fluxmask
and the datamask below about 5-10 million. Otherwise the 
solution phase will swap badly.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{model}{Name of image}{}{Vector of strings}
\ahaddarg{fixed}{Keep model fixed}{F}{Vector of booleans}
\ahaddarg{complist}{Name of component list}{}{String}
\ahaddarg{niter}{Number of Iterations, set to zero for no NNLS}{0}{Int}
\ahaddarg{tolerance}{Tolerance for solution}{1e-06}{Double}
\ahaddarg{fluxmask}{Name of mask for allowed flux}{}{Vector of strings}
\ahaddarg{datamask}{Name of mask for constraint pixels in dirty image}{}{Vector of strings}
\ahaddarg{image}{Names of restored images}{}{Vector of strings}
\ahaddarg{residual}{Names of restored images}{}{Vector of strings}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.nnls(image='3C273XC1.nnls.image', model='3C273XC1.nnls.model',
fluxmask='3C283XC1.fluxmask', datamask='3C273XC1.datamask', niter=1000,
tolerance=0.00001)
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{setmfcontrol}{Set various cycle control parameters for 
multi-field and wide-field imageing.}
\begin{ahdescription} 
Control parameters for mosaicing or wide-field imaging which are not required in
single field deconvolution are set here to streamline the user interface.
As multifield and widefield imaging is accomplished by deconvolution in cycles,
many of these parameters control how the deconvolution cycles are ended.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{cyclefactor}{Cycle threshold = this * max sidelobe * max resid}{1.5}{Float}
\ahaddarg{cyclespeedup}{Cycle threshold doubles in this number of iterations}{-1}{Float}
\ahaddarg{stoplargenegatives}{Stop the multiscale cycle for the first n cycles when a negative comp is found on the largest scale}{2}{Int}
\ahaddarg{stoppointmode}{Stop multiscale altogether if the smallest scale recieves this many consecutive components}{-1}{Int}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.setmfcontrol(cyclefactor=2.0, cyclespeedup=niter/10, 
stoplargenegatives=T, stoppointmode=10);
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{feather}{Feather together an interferometer and a single dish image
in the Fourier plane} 

\begin{ahdescription} 
Basically the "imerg" algorithm of AIPS and SDE, or the "feather"
algorithm of MIRIAD, we regrid the total power (or low resolution)
image onto the interferometer (or high resolution) image, Fourier
transform both the interferometer and single dish images, down weight
the Fourier transform of the interferometer image by 1.0 - FT(low res psf),
add the weighted interferometer Fourier plane to the single dish Fourier
plane, and transform back into the image plane.

The tapering is by the transform of a point spread function. If lowpsf
is specified, that image is used, otherwise the appropriate telescope
beam is used. The point spread function for a single dish image may be
calculated using \ahlink{approximatepsf}{qimager:qimager.approximatepsf}. 

\end{ahdescription}
\begin{ahargs}
\ahaddarg{image}{Name of output feathered image}{'feathered.image'}{Image}
\ahaddarg{highres}{Name of high resolution (interferometer) image}{}{Image}
\ahaddarg{lowres}{Name of low resolution (single dish) image}{}{Image}
\ahaddarg{lowpsf}{Name of optional low resolution point spread function}{}{Image}
\ahaddarg{usedefaultvp}{Use the default vp type?}{T}{Bool}
\ahaddarg{vptable}{Voltage pattern table from the vpmanager for detailed specification}{}{Table}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.feather(image='feathered.image', highres='casa.vlaonly',
lowres='casa.sd', usedefaultvp=F, vptable='sd.vptable');
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{pb}{Applies or corrects for a primary beam}

\begin{ahdescription} 

Multiply ({\tt operation='apply'}) or divide ({\tt operation='correct'})
by the primary beam function.  The primary beam can be applied to images and/or 
Componentlists.  

If {\tt pointingcenter==F} then you must specify {\tt inimage}
and the pointing center is taken from its reference direction.
Otherwise, {\tt pointingcenter} must be a Direction measure.
It cannot take on the value T.

The applied primary beam function is deterimed as follows.  If you used
function \ahlink{Qimager.setvp}{qimager:qimager.setvp} to set an external
voltage pattern table, then this is where the applied primary beam will
come from (regardless of whether you set {\tt inimage} or not).  If you
did not run this function, then you must supply argument {\tt inimage}. 
The telescope name embedded in its Coordinate System will be used to
determine the primary beam function. 

\end{ahdescription}

\begin{ahargs}
\ahaddarg{inimage}{Input image to apply beam to}{None}{String}
\ahaddarg{outimage}{Output image after beam is applied}{No output image}{String}
\ahaddarg{incomps}{Input Componentlist table name}{None}{String}
\ahaddarg{outcomps}{Output Componentlist table name}{No output Componentlist}{String}
\ahaddarg{operation}{Operation}{'apply'}{String from 'apply' or 'correct'}
\ahaddarg{pointingcenter}{Pointing center for primary beam application}{F in CLI or the N. pole in the GUI}{F or Direction measure}
\ahaddarg{parangle}{Parallactic angle for calculation}{'0deg'}{Quantity}
\ahaddarg{pborvp}{Primary Beam or Voltage Pattern }{'pb'}{String from 'pb' or 'vp'}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}


\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
# make a flat image
imgr.make('flat.image');
img := image('flat.image');
arr := img.getchunk();
arr[1:shape(arr)[1], 1:shape(arr)[2]] := 1.0;
img.putchunk(arr);
img.done()
arr := F;
#
# as we are using "pointingcenter=F", it defaults to the image center
imgr.pb(inimage='flat.image', outimage='pb.image', pointingcenter=F)
\end{verbatim}
\end{ahexample}
\end{ahfunction}





\begin{ahfunction}{linearmosaic}{Make a linear mosaic of several images}

\begin{ahdescription} 
Make a linear mosaic of several images.
Currently, the pointing center is not specified in the image, so
we specify the pointing center in terms of the row numbers of the FIELD subtable.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{images}{Input images to be mosaiced}{}{Vector of strings}
\ahaddarg{mosaic}{Output mosaic image}{}{Image}
\ahaddarg{fluxscale}{Fluxscale image}{}{Image}
\ahaddarg{sensitivity}{Sensitivity image}{}{Image}
\ahaddarg{fieldids}{output component list after PB has been applied [optional]}{}{Vector of Ints}
\ahaddarg{usedefaultvp}{Use the default vp type?}{T}{Bool}
\ahaddarg{vptable}{Voltage pattern table from the vpmanager for detailed specification}{}{Table}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.linearmosaic(images=['orion.1.cln', 'orion.2.cln', 'orion.4.cln'], mosaic='orion.linmos',
fluxscale='orion.linmos.fluxscale', fieldid=[1,2,4]);
\end{verbatim}
\end{ahexample}
\end{ahfunction}


%
\begin{ahfunction}{predict}{Predict the data from the specified model and componentlist}
\begin{ahdescription}
Transform the specified model (and optionally componentlist) 
and insert into the MODEL\_DATA column. The current contents of
the MODEL\_DATA column are replaced unless incremental is set to
T (in which case the results are added to the column).
\end{ahdescription}
\begin{ahargs}
\ahaddarg{model}{Name of image}{}{Vector of strings}
\ahaddarg{complist}{Name of component list}{}{String}
\ahaddarg{incremental}{Add to the existing MODEL\_DATA column?}{F}{Bool}
\ahaddarg{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.ft(model='3C273XC1.nnls.model')
imgr.ft(model='3C273XC1.another.model', incremental=T)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Fourier transforms the model in the image 3C273XC1.nnls.model
and then adds the visibility due to 3C273XC1.another.model
\end{ahcomments}
\end{ahfunction}


\begin{ahfunction}{approximatepsf}{Calculate approximate point spread functions}
\begin{ahdescription}
Calculate the approximate point spread function.
{\em Note that the model visibilities are updated}.

Some types of imaging do not yield a well-defined point spread
function. For example, mosaicing or single dish imaging both yield
point spread functions that are position dependent. Nevertheless, one
can still usefully define an {\em approximate} PSF that is of some
utility. This is calculated by doing the following calculation: a
point source is located at the center of the specified coordinate
system and the model data predicted. The approximate PSF is then formed from
those model data using the full sky equation. For regular sampling in
the image plane, this approximate PSF is actually quite good. It can
be used in a deconvolution. For a mosaic with similar uv sampling per
pointing, the approximate PSF is roughly the PSF per pointing
multiplied by the primary beam. For a single dish image, it is roughly
the telescope primary beam convolved with itself (if the
gridfunction='pb' was selected).
\end{ahdescription}
\begin{ahargs}
\ahaddarg{model}{Names of input models}{}{Vector of Strings}
\ahaddarg{psf}{Names of output point spread functions}{}{Vector of Strings}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.approximate(model='3C273XC1.clean', psf='3C273XC1.clean.psf')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{restore}{Calculate the restored image with restored model, component list, and  residuals}
\begin{ahdescription}
Restore the residuals to a smoothed version of the model. The model
images are convolved with the specified Gaussian beam and then the
residual images are added.  {\em Note that the model visibilities are
updated and thus reflect the model and componentlist that was
used.}. Use \ahlink{setbeam}{qimager:qimager.setbeam} to set the beam
parameters.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{model}{Names of input model}{}{Vector of Strings}
\ahaddarg{complist}{Name of component list}{}{String}
\ahaddarg{image}{Names of output restored images}{}{Vector of Strings}
\ahaddarg{residual}{Names of residual images}{}{Vector of strings}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setbeam(bmaj='2.0arcsec', bmin='2.0arcsec')
- imgr.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{residual}{Calculate the residual image with respect to current model and component list}
\begin{ahdescription}
Calculate the residuals corresponding to the model and
componentlist. {\em Note that the model visibilities are updated}.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{model}{Names of input models}{}{Vector of Strings}
\ahaddarg{complist}{Name of component list}{}{String}
\ahaddarg{image}{Names of output residual images}{}{Vector of Strings}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.residual(model='3C273XC1.clean', complist='3C273XC1.cl',
image='3C273XC1.clean.residual')
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{smooth}{Calculate an image smoothed with a Gaussian beam}
\begin{ahdescription}
The model images are convolved with the specified Gaussian beam.  By
default (normalize=T), the beam volume is normalized to unity so that
the smoothing is flux preserving. The smoothing used in restoration is
not normalized.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{model}{Name of input model}{}{Vector of Strings}
\ahaddarg{image}{Name of output smoothed images}{}{Vector of Strings}
\ahaddarg{usefit}{Use the fitted value (rather than that specified}{T}{Boolean}
\ahaddarg{bmaj}{Major axis of beam}{}{Quantity record}
\ahaddarg{bmin}{Minor axis of beam}{}{Quantity record}
\ahaddarg{bpa}{Position angle of beam}{}{Quantity record}
\ahaddarg{normalize}{Normalize volume of psf to unity}{T}{Bool}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.smooth(model='3C273XC1.clean', image='3C273XC1.clean.restored',
bmaj='2.0arcsec', bmin='2.0arcsec')
\end{verbatim}
\end{ahexample}
\end{ahfunction}
%
\begin{ahfunction}{setoptions}{Set some general options for subsequent processing}
\begin{ahdescription}
Various less-often-used options for processing can be set.

\begin{description}
\item[ftmachine] The options for ftmachine are: 
\begin{description}
\item[wproject] W projection algorithm.
\item[mosaic] Mosaic gridding.
\end{description}
\item[cache] The size of the cache used (in complex pixels) during the
gridding process. The default is to use half the physical memory of
the machine as specified by the aipsrc variable system.resources.memory.
\item[tile] The side of the tile (in complex pixels) during the
gridding process.
are supported.
\end{description}
\end{ahdescription}

\begin{ahargs}
\ahaddarg{ftmachine}{Fourier transform machine}{'ft'}{String:'ft'|'sd'|'both' | 'wfmemoryft'}
\ahaddarg{cache}{Size of gridding cache in complex pixels}{4194304}{Int}
\ahaddarg{tile}{Size of a gridding tile in pixels (in 1 dimension)}{16}{Int}
\ahaddarg{gridfunction}{Gridding function}{'SF'}{String: 'SF'|'BOX'}
\ahaddarg{padding}{Padding factor in image plane (>=1.0)}{1.0}{Float}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setoptions(cache=10000000, tile=32, gridfunction='BOX',
  dm.location('vla'))
\end{verbatim}
\end{ahexample}

\end{ahfunction}

\begin{ahfunction}{setsdoptions}{Set some options for single dish processing}
\begin{ahdescription}
Various less-often-used options for single dish processing can be set.

\begin{description}
\item[scale] The overall scale of the single dish data is multiplied by this
factor.
\item[weight] The weight given to the single dish data in the imaging
is multiplied by this factor.
\end{description}
\item[cache] The size of the cache used (in complex pixels) during the
\end{ahdescription}

\begin{ahargs}
\ahaddarg{scale}{Scaling applied to single dish data}{1.0}{Float}
\ahaddarg{weight}{Weights applied to single dish data}{1.0}{Float}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setoptions(cache=10000000, tile=32, gridfunction='BOX',
  dm.location('vla'))
\end{verbatim}
\end{ahexample}

\end{ahfunction}

\begin{ahfunction}{setvp}{Set the voltage pattern model for subsequent processing}
\begin{ahdescription}
Set the voltage pattern model (and hence, the primary beam) used for a Telecope.
There are currently two ways to set the voltage pattern: by using the extensive
list of defaults which the system knows about, or by creating a voltage pattern
description with the \ahlink{vpmanager}{qimager:vpmanager}.  The default voltage patterns
include both a high and a low frequency VP for the WSRT, a VP for each observing
band at the AT, several VP's for the VLA, including the approrpiate beam squint for
each observing band, and  Gaussian for the BIMA dishes.  Due to temporary limitations
in the internal structure of the visibility buffer, only one telescope's voltage
pattern can be applied to a particular MeasurementSet.  This will be corrected shortly.
\end{ahdescription}

\begin{ahargs}
\ahaddarg{dovp}{Do voltage pattern (ie, primary beam) correction}{F}{Bool}
\ahaddarg{usedefaultvp}{Look up the default VP for this telescope and frequency?}{T}{Bool}
\ahaddarg{vptable}{If usedefaultvp is false, provide a VP Table made with vpmanager}{}{String}
\ahaddarg{dosquint}{Activate the beam squint in the VP model}{F}{Bool}
\ahaddarg{parangleinc}{Parallactice angle increment for squint application}{360deg}{Quantity}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setvp(dovp=T, usedefaultvp=T, dosquint=F);
\end{verbatim}
\end{ahexample}

\end{ahfunction}

\begin{ahfunction}{setscales}{Set the scale sizes for MultiScale Clean}
\begin{ahdescription}

The multiscale clean algorithm cleans an image on a number of
different scales, decomposing the image into Gaussians of these scale sizes.
This function allows the user to set the number
of scales used (using the nscales method), or to directly control the
sizes of the scales in pixels (using the uservector method).  When using the
nscales method, the scales are calculated using the following formula:
\begin{equation}
\theta_{minor}  10.0 ^{(i- N_{scales}/2)/2.0}
\end{equation}
where $\theta_{min}$ is the fitted minor axis of the clean beam. The
first value is zero.
\end{ahdescription}

\begin{ahargs} 
\ahaddarg{scalemethod}{Method by which scales are set}{nscales}{String: 'nscales'|'uservector'}
\ahaddarg{nscales}{Number of scales}{5}{Int}
\ahaddarg{uservector}{Vector of scale sizes to use}{[0, 3, 10]}{Vector of Doubles}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setscales(6);
\end{verbatim}
\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{selfcal}{Self-calibrate the MeasurementSet using a calibrater tool and model+component list}
To self-calibrate, first make a \ahlink{calibrater}{calibrater} tool and
set it up as required. Then use this tool function to do the selfcal.
The steps coded in the tool function may also be done by hand, of
course. These are:
\begin{enumerate}
\item Call \ahlink{qimager.ft}{qimager:qimager.ft} To Fourier transform the model
and optional componentlist
\item Call \ahlink{calibrater.solve}{calibrater:calibrater.solve} to do the solution,
optionally writing out tables containing gain information.
\item Call \ahlink{calibrater.correct}{calibrater:calibrater.correct} to do the correction
of the data.
\end{enumerate}

After the selfcal step, the next stage is to re-image the data using
{\em e.g.} \ahlink{clean}{qimager:qimager.clean} or \ahlink{nnls}{qimager:qimager.nnls}.

\begin{ahdescription}
\begin{ahargs}
\ahaddarg{caltool}{Glish name of calibrater tool}{NONE!}{Any valid calibrater tool}
\ahaddarg{model}{Name of images}{}{Vector of strings}
\ahaddarg{complist}{Name of component list}{}{String}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr:=qimager('3C273XC1.ms')
cl:=calibrater('3C273XC1.ms')
cl.setsolve('T', 60, 'T', -1, '', F)
imgr.selfcal(cl, model='clean')
imgr.clean(model='newclean', image='newclean.restored')
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
\end{ahcomments}
\end{ahfunction}
\end{ahtool}

\begin{ahfunction}{qimagermaketestms}{Make a standard MeasurementSet that can be used for experimentation}
\begin{ahdescription}
A standard dataset is converted from a FITS file to 
a MeasurementSet. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{msfile}{Name of output ms}{'3C273XC1.ms'}{String}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
qimagermaketestms('MY3C273.ms')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagermaketestsdms}{Make a standard single dish MeasurementSet that can be used for experimentation}
\begin{ahdescription}
A standard dataset is converted from a set of GBT fits files
to a MeasurementSet. The dataset used is an
observation of the Cygnus loop at 800MHz using GBT. It
is part of the \aipspp\ distribution.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{msfile}{Name of output ms}{'gbt\_cygnus\_800MHz.ms'}{String}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
qimagermaketestsdms('mySD.ms')
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{qimagermaketestmfms}{Make a standard multifield MeasurementSet that can be used for experimentation}
\begin{ahdescription}
A standard multifield dataset is converted from a FITS file to 
a MeasurementSet. The dataset used is a seven field 
VLA D-array observation of CAS A at 8 GHz and
is part of the \aipspp\ distribution.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{msfile}{Name of output ms}{'XCAS.ms'}{String}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
qimagermaketestmfms('XCAS.ms')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagermaketestcl}{Make a standard componentlist for a standard MeasurementSet}
\begin{ahdescription}
A standard component list is made for the 3C273XC1 data set.
The reference for the component can be specified: the components
will be then converted to this reference (e.g. 'gal') before processing.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{clfile}{Name of output cl}{'3C273XC1.cl'}{String}
\ahaddarg{refer}{Reference}{'gal'}{String}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
qimagermaketestcl('MY3C273.cl', 'gal')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagertest}{Perform a test of imaging from a standard MeasurementSet}
\begin{ahdescription}
Perform a test. The dataset used is an observation of 3C273 at 8GHz
using the C-configuration of the VLA. It is part of the \aipspp\
distribution.

Note that if doshift is set to T then the imaging is done in
Galactic coordinates.

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item A summary of what exists is logged.
\item The data are weighted using the Briggs algorithm.
\item An initial CLEAN-only deconvolution is performed, and then restored.
\item A CLEAN mask is constructed by thresholding $I>0.015$
\item The deconvolution is repeated with 
masks enabled.
\item Residual images are calculated for the North Celestial pole,
on the Sun, and for azimuth elevation (0d, 0d).
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{size}{Number of pixels on a side}{128}{Int}
\ahaddarg{cleanniter}{Number of clean iterations}{1000}{Int}
\ahaddarg{cleangain}{Clean loop gain}{0.1}{Float}
\ahaddarg{doshift}{Shift the phase center}{T}{Bool}
\ahaddarg{doplot}{Plot?}{T}{Bool}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
include 'qimager.g'
qimagertest(size=256)
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagerlongtest}{Perform a long test of imaging from a standard MeasurementSet}
\begin{ahdescription}
Perform a test. The dataset used is an observation of 3C273 at 8GHz
using the C-configuration of the VLA. It is part of the \aipspp\
distribution.

The test is similar to qimagertest, except that the various
functions are checked one by one and status reported.
\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
include 'qimager.g'
qimagerlongtest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagermftest}{Perform a test of multi-field processing using a standard MeasurementSet}
\begin{ahdescription}
Perform a test of multi-field processing. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution.

Note that if doshift is set to T then the imaging is done in
Galactic coordinates.

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item The data are weighted using the Briggs algorithm.
\item Two fields are cleaned, one on the core and one on the
jet, using the standard component list.
\item If doplot=T then the visibilities are plotted.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{doplot}{Plot?}{T}{Bool}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
qimagermftest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagerspectraltest}{Perform a test of spectral processing using a standard spectral line MeasurementSet}
\begin{ahdescription}
Perform a test. The dataset used is an observation of BLLAC
at 110 GHz using the BIMA array. It is part of the \aipspp\
distribution.

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item An CLEAN-only deconvolution is performed, and then restored.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
qimagerspectraltest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}
%
\begin{ahfunction}{qimagerpbtest}{Perform a test of primary beam processing using a standard MeasurementSet}
\begin{ahdescription}
Perform a test of primary processing. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution.

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item A default calibration is applied
\item The data are weighted using the Briggs algorithm.
\item One field is cleaned, using the mf algorithm and the primary
beam is applied both during the subtraction of components (the
major cycle) and in estimating the residuals.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
qimagerpbtest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagercomponenttest}
{Perform a test of component model processing using a standard MeasurementSet}
\begin{ahdescription}
Perform a test of component model processing. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution. 

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item A component list is constructed and using in the
subsequent processing. A point component is placed at the
position of the core of 3C273, but specified in Galactic
coordinates.
\item The component model is used in predicting the
model visibilities.
\item A plot of the visibilities is made.
\item The image is cleaned and restored. The center of the image
is shifted to half way down the jet.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{size}{Number of pixels on a side}{128}{Int}
\ahaddarg{doshift}{Shift the phase center}{T}{Bool}
\ahaddarg{doplot}{Plot?}{T}{Bool}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
qimagercomponenttest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagerselfcaltest}
{Perform a test of selfcal processing using a standard MeasurementSet}
\begin{ahdescription}
Perform a test of selfcal model processing. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution. 

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item {\tt qimager} and \htmlref{calibrater}{calibrater} tools are created.
\item {\tt qimager} is used to clean and restore the image
\item The clean model is clipped at 750mJy
\item The selfcal tool function is used to self-calibrate using the
current model. The Jones matrices are: T, 60s and G, 600s.
\item The clean and restoration are repeated with the 
improved calibration.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{size}{Number of pixels on a side}{128}{Int}
\ahaddarg{doshift}{Shift the phase center}{T}{Bool}
\ahaddarg{doplot}{Plot?}{T}{Bool}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
qimagerselfcaltest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimagersdtest}{Perform a test of single dish imaging from a standard MeasurementSet}
\begin{ahdescription}
Perform a test. The dataset used is an observation of the Cygnus
region at 800 MHz using the GBT. It is part of the \aipspp\
distribution.

The test does the following:
\begin{itemize}
\item The GBT FITS files that are to be read in are
in a standard place in the \aipspp\ data respository.
\item The MeasurementSet is created using the 
\ahlink{gbtmsfiller}{gbtmsfiller}
\item The data are calibrated using 
\ahlink{gbtcal}{gbtcal}.
\item Two images are constructed: the data gridded and the weights
gridded.
\item The \ahlink{image calculator}{imagecalc} is used to normalize
by the weights image.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
include 'qimager.g'
qimagersdtest();
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{qimageralltests}
{Perform all qimager tests using standard MeasurementSets}
\begin{ahdescription}
All tests are run and the status returned. The complete
suite takes about 500s (real-time) on a Pentium Pro 200MHz.
\end{ahdescription}
\end{ahfunction}


\begin{ahfunction}{qimagermultiscale}{Makes multi-resolution multiscale images.}
\begin{ahdescription}
Based on user-specified image sizes and cell sizes, we make several rounds of
multiscale clean images and use each model image as a fisr guess for
successively higher resolution images.  After the first image, each clean
is solving for deltas, and will tend to be neither positive nor negative.

For each round of multiscale cleaning, uniform weighting with a uv taper 
coresponding to 2.5 times the cell size is used.  The number of 
multiscale clean iterations used in each round is given by 
\begin{equation}
niter = nitermult * imsizes[i] ^{niterpower}.
\end{equation}

\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{msname}{Name of input ms}{''}{String}
\ahaddarg{imsizes}{Image sizes for each round (should be monatonically increasing)}{[128, 256]}{Vector of Ints}
\ahaddarg{cellsizes}{Cell sizes [in arcsec] for each round (should be monatonically decreasing)}{[2, 1]}{Vector of Floats}
\ahaddarg{scales}{Name of input ms}{[0, 5, 15]}{Vector of Ints}
\ahaddarg{nitermult}{Multiplier parameter used to adjust niter with imsizes}{0.15}{Float}
\ahaddarg{niterpower}{Exponent of imsizes used to adjust niter with imsizes}{1.2}{Float}
\ahaddarg{fields}{Vector of field ids to image}{[1]}{Vector of Ints}
\ahaddarg{spwid}{Spectral window to image}{1}{Int}
\ahaddarg{centerfield}{Field id for central pointing}{1}{Int}
\end{ahargs}


\begin{ahexample}
\begin{verbatim}
qimagermultiscale(msname='orion.ms', imsizes=[128, 256, 512], cellsizes=[16,8,4], 
scales=[0, 5, 15], nitermult=0.15, niterpower=1.2, fields=[1:4], 
spwid=[1], centerfield=1);
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\end{ahmodule}

\end{document}
