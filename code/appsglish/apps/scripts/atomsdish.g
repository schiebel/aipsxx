# atomsdish.g: help atoms for the dish package. 
# Copyright (C) 1999
# Associated Universities, Inc. Washington DC, USA.
#
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This library is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
# License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
#
# Correspondence concerning AIPS++ should be addressed as follows:
#        Internet email: aips2-request@nrao.edu.
#        Postal address: AIPS++ Project Office
#                        National Radio Astronomy Observatory
#                        520 Edgemont Road
#                        Charlottesville, VA 22903-2475 USA
#
# $Id: atomsdish.g,v 19.949 2006/09/29 01:49:20 wyoung Exp $

pragma include once
val help::pkg.dish := [=];
help::pkg.dish::d := 'package for single dish processing';

help::pkg.dish.dish := [=];
help::pkg.dish.dish.objs := [=];
help::pkg.dish.dish.funs := [=];
help::pkg.dish.dish.d := 'Single Dish Analysis Environment';
help::pkg.dish.dish.objs.dish := [=];
help::pkg.dish.dish.objs.dish.m := [=];
help::pkg.dish.dish.objs.dish.c := [=];
help::pkg.dish.dish.objs.dish.d := 'dish tool (user functions)';
help::pkg.dish.dish.objs.dish.c.dish := [=];
help::pkg.dish.dish.objs.dish.c.dish.d := 'single dish analysis tool';
help::pkg.dish.dish.objs.dish.c.dish.s := 'dish()';
help::pkg.dish.dish.objs.dish.m.accum := [=];
help::pkg.dish.dish.objs.dish.m.accum.d := 'Add spectrum to the accumulator.';
help::pkg.dish.dish.objs.dish.m.accum.a.scans := [=];
help::pkg.dish.dish.objs.dish.m.accum.a.scans.d := 'scan numbers to add to accumulator';
help::pkg.dish.dish.objs.dish.m.accum.a.scans.def := 'globalscan1';
help::pkg.dish.dish.objs.dish.m.accum.a.scans.a := 'integer or vector of integers';
help::pkg.dish.dish.objs.dish.m.accum.s := 'accum(scans)';
help::pkg.dish.dish.objs.dish.m.addstack := [=];
help::pkg.dish.dish.objs.dish.m.addstack.d := 'Append new scans to the stack.';
help::pkg.dish.dish.objs.dish.m.addstack.a.beg := [=];
help::pkg.dish.dish.objs.dish.m.addstack.a.beg.d := 'The beginning scan number';
help::pkg.dish.dish.objs.dish.m.addstack.a.beg.def := 'F';
help::pkg.dish.dish.objs.dish.m.addstack.a.beg.a := 'integer';
help::pkg.dish.dish.objs.dish.m.addstack.a.end := [=];
help::pkg.dish.dish.objs.dish.m.addstack.a.end.d := 'The ending scan number';
help::pkg.dish.dish.objs.dish.m.addstack.a.end.def := 'beg';
help::pkg.dish.dish.objs.dish.m.addstack.a.end.a := 'integer';
help::pkg.dish.dish.objs.dish.m.addstack.a.inc := [=];
help::pkg.dish.dish.objs.dish.m.addstack.a.inc.d := 'the increment';
help::pkg.dish.dish.objs.dish.m.addstack.a.inc.def := '1';
help::pkg.dish.dish.objs.dish.m.addstack.a.inc.a := 'integer';
help::pkg.dish.dish.objs.dish.m.addstack.s := 'addstack(beg, end, inc)';
help::pkg.dish.dish.objs.dish.m.ave := [=];
help::pkg.dish.dish.objs.dish.m.ave.d := 'Average the contents of the accumulator.';
help::pkg.dish.dish.objs.dish.m.ave.s := 'ave()';
help::pkg.dish.dish.objs.dish.m.aver := [=];
help::pkg.dish.dish.objs.dish.m.aver.d := 'Average a group of scans or subscans.';
help::pkg.dish.dish.objs.dish.m.aver.a.scanlist := [=];
help::pkg.dish.dish.objs.dish.m.aver.a.scanlist.d := 'a vector of scan numbers';
help::pkg.dish.dish.objs.dish.m.aver.a.scanlist.def := '';
help::pkg.dish.dish.objs.dish.m.aver.a.scanlist.a := 'vector of integers';
help::pkg.dish.dish.objs.dish.m.aver.a.subscanlist := [=];
help::pkg.dish.dish.objs.dish.m.aver.a.subscanlist.d := 'a vector of subscans or \' odd\' ,\' even\' ,\' n/m\' ';
help::pkg.dish.dish.objs.dish.m.aver.a.subscanlist.def := 'all';
help::pkg.dish.dish.objs.dish.m.aver.a.subscanlist.a := 'vector of integers';
help::pkg.dish.dish.objs.dish.m.aver.a.weighting := [=];
help::pkg.dish.dish.objs.dish.m.aver.a.weighting.d := 'NONE, RMS, TSYS';
help::pkg.dish.dish.objs.dish.m.aver.a.weighting.def := 'RMS';
help::pkg.dish.dish.objs.dish.m.aver.a.weighting.a := 'string';
help::pkg.dish.dish.objs.dish.m.aver.a.alignment := [=];
help::pkg.dish.dish.objs.dish.m.aver.a.alignment.d := 'NONE, VELOCITY, XAXIS';
help::pkg.dish.dish.objs.dish.m.aver.a.alignment.def := 'NONE';
help::pkg.dish.dish.objs.dish.m.aver.a.alignment.a := 'string';
help::pkg.dish.dish.objs.dish.m.aver.s := 'aver(scanlist, subscanlist, weighting, alignment)';
help::pkg.dish.dish.objs.dish.m.avgpols := [=];
help::pkg.dish.dish.objs.dish.m.avgpols.d := 'Average the polarizations in the globalscan1 spectrum';
help::pkg.dish.dish.objs.dish.m.avgpols.s := 'avgpols()';
help::pkg.dish.dish.objs.dish.m.base := [=];
help::pkg.dish.dish.objs.dish.m.base.d := 'Perform a polynomial baseline fit, all in one  function.  An alternative step-by-step method is to use the nfit, setregion,  bshape, and baseline functions';
help::pkg.dish.dish.objs.dish.m.base.a.scanrec := [=];
help::pkg.dish.dish.objs.dish.m.base.a.scanrec.d := 'SDRecord to fit';
help::pkg.dish.dish.objs.dish.m.base.a.scanrec.def := 'Currently displayed data';
help::pkg.dish.dish.objs.dish.m.base.a.scanrec.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.base.a.order := [=];
help::pkg.dish.dish.objs.dish.m.base.a.order.d := 'order of polynomial';
help::pkg.dish.dish.objs.dish.m.base.a.order.def := 'none';
help::pkg.dish.dish.objs.dish.m.base.a.order.a := 'integer';
help::pkg.dish.dish.objs.dish.m.base.a.range := [=];
help::pkg.dish.dish.objs.dish.m.base.a.range.d := 'range for computing polynomial baseline';
help::pkg.dish.dish.objs.dish.m.base.a.range.def := 'none';
help::pkg.dish.dish.objs.dish.m.base.a.range.a := 'string';
help::pkg.dish.dish.objs.dish.m.base.a.action := [=];
help::pkg.dish.dish.objs.dish.m.base.a.action.d := '\' subtract\'  or \' show\' ';
help::pkg.dish.dish.objs.dish.m.base.a.action.def := '\' subtract\' ';
help::pkg.dish.dish.objs.dish.m.base.a.action.a := 'string';
help::pkg.dish.dish.objs.dish.m.base.s := 'base(scanrec, order, range, action)';
help::pkg.dish.dish.objs.dish.m.baseline := [=];
help::pkg.dish.dish.objs.dish.m.baseline.d := 'Perform a polynomial baseline fit to spectrum in {\it globalscan1}';
help::pkg.dish.dish.objs.dish.m.baseline.s := 'baseline()';
help::pkg.dish.dish.objs.dish.m.bdrop := [=];
help::pkg.dish.dish.objs.dish.m.bdrop.d := 'Set number of channels to drop from the beginning of a spectrum, used only in displaying.';
help::pkg.dish.dish.objs.dish.m.bdrop.a.value := [=];
help::pkg.dish.dish.objs.dish.m.bdrop.a.value.d := 'The number of channels to drop';
help::pkg.dish.dish.objs.dish.m.bdrop.a.value.def := '';
help::pkg.dish.dish.objs.dish.m.bdrop.a.value.a := 'integer';
help::pkg.dish.dish.objs.dish.m.bdrop.s := 'bdrop(value)';
help::pkg.dish.dish.objs.dish.m.bias := [=];
help::pkg.dish.dish.objs.dish.m.bias.d := 'Add a bias to the scan in memory';
help::pkg.dish.dish.objs.dish.m.bias.a.factor := [=];
help::pkg.dish.dish.objs.dish.m.bias.a.factor.d := 'The constant or vector to add';
help::pkg.dish.dish.objs.dish.m.bias.a.factor.def := 'none';
help::pkg.dish.dish.objs.dish.m.bias.a.factor.a := 'float or vector of floats';
help::pkg.dish.dish.objs.dish.m.bias.s := 'bias(factor)';
help::pkg.dish.dish.objs.dish.m.boxcar := [=];
help::pkg.dish.dish.objs.dish.m.boxcar.d := 'Perform a boxcar smoothing';
help::pkg.dish.dish.objs.dish.m.boxcar.a.smooth_width := [=];
help::pkg.dish.dish.objs.dish.m.boxcar.a.smooth_width.d := 'The smoothing width';
help::pkg.dish.dish.objs.dish.m.boxcar.a.smooth_width.def := '3';
help::pkg.dish.dish.objs.dish.m.boxcar.a.smooth_width.a := 'integer';
help::pkg.dish.dish.objs.dish.m.boxcar.s := 'boxcar(smooth_width)';
help::pkg.dish.dish.objs.dish.m.bshape := [=];
help::pkg.dish.dish.objs.dish.m.bshape.d := 'Show the baseline fit';
help::pkg.dish.dish.objs.dish.m.bshape.s := 'bshape()';
help::pkg.dish.dish.objs.dish.m.cal := [=];
help::pkg.dish.dish.objs.dish.m.cal.d := 'Apply calibration to a scan (GBT only currently).';
help::pkg.dish.dish.objs.dish.m.cal.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.scan.d := 'scan number';
help::pkg.dish.dish.objs.dish.m.cal.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.cal.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.cal.a.baseline := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.baseline.d := 'toggle baseline subtraction on or off';
help::pkg.dish.dish.objs.dish.m.cal.a.baseline.def := 'F (off)';
help::pkg.dish.dish.objs.dish.m.cal.a.baseline.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.cal.a.range := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.range.d := 'range for baseline';
help::pkg.dish.dish.objs.dish.m.cal.a.range.def := 'F (full range)';
help::pkg.dish.dish.objs.dish.m.cal.a.range.a := 'channel range vector';
help::pkg.dish.dish.objs.dish.m.cal.a.order := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.order.d := 'order of baseline fit';
help::pkg.dish.dish.objs.dish.m.cal.a.order.def := '1';
help::pkg.dish.dish.objs.dish.m.cal.a.order.a := 'integer';
help::pkg.dish.dish.objs.dish.m.cal.a.units := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.units.d := 'units for calibrated result; 1=TA*, 2=TMB, 3=S';
help::pkg.dish.dish.objs.dish.m.cal.a.units.def := '1';
help::pkg.dish.dish.objs.dish.m.cal.a.units.a := 'integer';
help::pkg.dish.dish.objs.dish.m.cal.a.flipsr := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.flipsr.d := 'flip sense of signal and reference';
help::pkg.dish.dish.objs.dish.m.cal.a.flipsr.def := 'F';
help::pkg.dish.dish.objs.dish.m.cal.a.flipsr.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.cal.a.fold := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.fold.d := 'fold data - FSWITCH data only';
help::pkg.dish.dish.objs.dish.m.cal.a.fold.def := 'F';
help::pkg.dish.dish.objs.dish.m.cal.a.fold.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.cal.a.flipfold := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.flipfold.d := 'flip sense of fold - FSWITCH data only';
help::pkg.dish.dish.objs.dish.m.cal.a.flipfold.def := 'F';
help::pkg.dish.dish.objs.dish.m.cal.a.flipfold.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.cal.a.proc := [=];
help::pkg.dish.dish.objs.dish.m.cal.a.proc.d := 'calibrate full procedure or single scan';
help::pkg.dish.dish.objs.dish.m.cal.a.proc.def := 'T';
help::pkg.dish.dish.objs.dish.m.cal.a.proc.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.cal.s := 'cal(scan, baseline, range, order, units, flipsr, fold, flipfold, proc)';
help::pkg.dish.dish.objs.dish.m.calib := [=];
help::pkg.dish.dish.objs.dish.m.calib.d := 'Apply calibration to a scan (GBT only currently).';
help::pkg.dish.dish.objs.dish.m.calib.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.calib.a.scan.d := 'scan number';
help::pkg.dish.dish.objs.dish.m.calib.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.calib.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.calib.a.baseline := [=];
help::pkg.dish.dish.objs.dish.m.calib.a.baseline.d := 'toggle baseline subtraction on or off';
help::pkg.dish.dish.objs.dish.m.calib.a.baseline.def := 'F (off)';
help::pkg.dish.dish.objs.dish.m.calib.a.baseline.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.calib.a.range := [=];
help::pkg.dish.dish.objs.dish.m.calib.a.range.d := 'range for baseline';
help::pkg.dish.dish.objs.dish.m.calib.a.range.def := 'F (full range)';
help::pkg.dish.dish.objs.dish.m.calib.a.range.a := 'channel range vector';
help::pkg.dish.dish.objs.dish.m.calib.a.order := [=];
help::pkg.dish.dish.objs.dish.m.calib.a.order.d := 'order of baseline fit';
help::pkg.dish.dish.objs.dish.m.calib.a.order.def := '1';
help::pkg.dish.dish.objs.dish.m.calib.a.order.a := 'integer';
help::pkg.dish.dish.objs.dish.m.calib.a.units := [=];
help::pkg.dish.dish.objs.dish.m.calib.a.units.d := 'units for calibrated result; 1=TA*, 2=TMB, 3=S';
help::pkg.dish.dish.objs.dish.m.calib.a.units.def := '1';
help::pkg.dish.dish.objs.dish.m.calib.a.units.a := 'integer';
help::pkg.dish.dish.objs.dish.m.calib.a.flipsr := [=];
help::pkg.dish.dish.objs.dish.m.calib.a.flipsr.d := 'flip sense of signal and reference';
help::pkg.dish.dish.objs.dish.m.calib.a.flipsr.def := 'F';
help::pkg.dish.dish.objs.dish.m.calib.a.flipsr.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.calib.a.fold := [=];
help::pkg.dish.dish.objs.dish.m.calib.a.fold.d := 'fold data - FSWITCH data only';
help::pkg.dish.dish.objs.dish.m.calib.a.fold.def := 'F';
help::pkg.dish.dish.objs.dish.m.calib.a.fold.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.calib.a.flipfold := [=];
help::pkg.dish.dish.objs.dish.m.calib.a.flipfold.d := 'flip sense of fold - FSWITCH data only';
help::pkg.dish.dish.objs.dish.m.calib.a.flipfold.def := 'F';
help::pkg.dish.dish.objs.dish.m.calib.a.flipfold.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.calib.s := 'calib(scan, baseline, range, order, units, flipsr, fold, flipfold)';
help::pkg.dish.dish.objs.dish.m.clearrm := [=];
help::pkg.dish.dish.objs.dish.m.clearrm.d := 'Clear all variables from results manager';
help::pkg.dish.dish.objs.dish.m.clearrm.s := 'clearrm()';
help::pkg.dish.dish.objs.dish.m.clip := [=];
help::pkg.dish.dish.objs.dish.m.clip.d := 'Clip/Edit data (set flags)';
help::pkg.dish.dish.objs.dish.m.clip.a.cliplevel := [=];
help::pkg.dish.dish.objs.dish.m.clip.a.cliplevel.d := 'threshold for clipping';
help::pkg.dish.dish.objs.dish.m.clip.a.cliplevel.def := 'no default';
help::pkg.dish.dish.objs.dish.m.clip.a.cliplevel.a := 'float';
help::pkg.dish.dish.objs.dish.m.clip.a.channelrange := [=];
help::pkg.dish.dish.objs.dish.m.clip.a.channelrange.d := 'range of channels to flag';
help::pkg.dish.dish.objs.dish.m.clip.a.channelrange.def := 'all';
help::pkg.dish.dish.objs.dish.m.clip.a.channelrange.a := 'vector of integers';
help::pkg.dish.dish.objs.dish.m.clip.a.clipdir := [=];
help::pkg.dish.dish.objs.dish.m.clip.a.clipdir.d := 'clip direction -- clip above (\' high\' ) or below (\' low\' ) the threshhold';
help::pkg.dish.dish.objs.dish.m.clip.a.clipdir.def := 'high';
help::pkg.dish.dish.objs.dish.m.clip.a.clipdir.a := 'string';
help::pkg.dish.dish.objs.dish.m.clip.s := 'clip(cliplevel, channelrange, clipdir)';
help::pkg.dish.dish.objs.dish.m.copy := [=];
help::pkg.dish.dish.objs.dish.m.copy.d := 'Copy a variable in the global record to another  location';
help::pkg.dish.dish.objs.dish.m.copy.a.fromhere := [=];
help::pkg.dish.dish.objs.dish.m.copy.a.fromhere.d := 'Current variable name';
help::pkg.dish.dish.objs.dish.m.copy.a.fromhere.def := 'no default';
help::pkg.dish.dish.objs.dish.m.copy.a.fromhere.a := 'string';
help::pkg.dish.dish.objs.dish.m.copy.a.tohere := [=];
help::pkg.dish.dish.objs.dish.m.copy.a.tohere.d := 'Desired variable name';
help::pkg.dish.dish.objs.dish.m.copy.a.tohere.def := 'no default';
help::pkg.dish.dish.objs.dish.m.copy.a.tohere.a := 'string';
help::pkg.dish.dish.objs.dish.m.copy.s := 'copy(fromhere, tohere)';
help::pkg.dish.dish.objs.dish.m.dcbase := [=];
help::pkg.dish.dish.objs.dish.m.dcbase.d := 'Subtract a DC baseline (0th order poly) from the spectrum';
help::pkg.dish.dish.objs.dish.m.dcbase.s := 'dcbase()';
help::pkg.dish.dish.objs.dish.m.delete := [=];
help::pkg.dish.dish.objs.dish.m.delete.d := 'Delete a single entry from the stack.';
help::pkg.dish.dish.objs.dish.m.delete.s := 'delete()';
help::pkg.dish.dish.objs.dish.m.divide := [=];
help::pkg.dish.dish.objs.dish.m.divide.d := 'Divide globalscan1 by offscan1.';
help::pkg.dish.dish.objs.dish.m.divide.s := 'divide()';
help::pkg.dish.dish.objs.dish.m.done := [=];
help::pkg.dish.dish.objs.dish.m.done.d := 'Exits dish and destroys the current dish tool.';
help::pkg.dish.dish.objs.dish.m.done.s := 'done()';
help::pkg.dish.dish.objs.dish.m.edrop := [=];
help::pkg.dish.dish.objs.dish.m.edrop.d := 'Set number of channels to drop from the end of a spectrum, used only in displaying.';
help::pkg.dish.dish.objs.dish.m.edrop.a.value := [=];
help::pkg.dish.dish.objs.dish.m.edrop.a.value.d := 'The number of channels to drop';
help::pkg.dish.dish.objs.dish.m.edrop.a.value.def := '';
help::pkg.dish.dish.objs.dish.m.edrop.a.value.a := 'integer';
help::pkg.dish.dish.objs.dish.m.edrop.s := 'edrop(value)';
help::pkg.dish.dish.objs.dish.m.empty := [=];
help::pkg.dish.dish.objs.dish.m.empty.d := 'Clear the stack.';
help::pkg.dish.dish.objs.dish.m.empty.s := 'empty()';
help::pkg.dish.dish.objs.dish.m.filein := [=];
help::pkg.dish.dish.objs.dish.m.filein.d := 'Sets the scan group used by scan access functions.';
help::pkg.dish.dish.objs.dish.m.filein.a.wsname := [=];
help::pkg.dish.dish.objs.dish.m.filein.a.wsname.d := 'scan group name; must already be \' opened\'  (exist in the Result s Manager)';
help::pkg.dish.dish.objs.dish.m.filein.a.wsname.def := 'no default';
help::pkg.dish.dish.objs.dish.m.filein.a.wsname.a := 'string';
help::pkg.dish.dish.objs.dish.m.filein.s := 'filein(wsname)';
help::pkg.dish.dish.objs.dish.m.fileout := [=];
help::pkg.dish.dish.objs.dish.m.fileout.d := 'Sets the scan group that can be written to.';
help::pkg.dish.dish.objs.dish.m.fileout.a.sgname := [=];
help::pkg.dish.dish.objs.dish.m.fileout.a.sgname.d := 'scan group name';
help::pkg.dish.dish.objs.dish.m.fileout.a.sgname.def := 'no default';
help::pkg.dish.dish.objs.dish.m.fileout.a.sgname.a := 'string';
help::pkg.dish.dish.objs.dish.m.fileout.s := 'fileout(sgname)';
help::pkg.dish.dish.objs.dish.m.files := [=];
help::pkg.dish.dish.objs.dish.m.files.d := 'Prints the currently set values for filein and fileout.';
help::pkg.dish.dish.objs.dish.m.files.a.quiet := [=];
help::pkg.dish.dish.objs.dish.m.files.a.quiet.d := 'suppress printing';
help::pkg.dish.dish.objs.dish.m.files.a.quiet.def := 'F';
help::pkg.dish.dish.objs.dish.m.files.a.quiet.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.files.s := 'files(quiet)';
help::pkg.dish.dish.objs.dish.m.find := [=];
help::pkg.dish.dish.objs.dish.m.find.d := 'Search all glish variables for a specified string.';
help::pkg.dish.dish.objs.dish.m.find.a.myfoo := [=];
help::pkg.dish.dish.objs.dish.m.find.a.myfoo.d := 'string to look for in all currently defined glish variables';
help::pkg.dish.dish.objs.dish.m.find.a.myfoo.def := '';
help::pkg.dish.dish.objs.dish.m.find.a.myfoo.a := 'string';
help::pkg.dish.dish.objs.dish.m.find.s := 'find(myfoo)';
help::pkg.dish.dish.objs.dish.m.flag := [=];
help::pkg.dish.dish.objs.dish.m.flag.d := 'Flag data based on various specifications.';
help::pkg.dish.dish.objs.dish.m.flag.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.flag.a.scan.d := 'scan number(s) to flag';
help::pkg.dish.dish.objs.dish.m.flag.a.scan.def := 'F';
help::pkg.dish.dish.objs.dish.m.flag.a.scan.a := 'integer or vector of ints';
help::pkg.dish.dish.objs.dish.m.flag.a.ints := [=];
help::pkg.dish.dish.objs.dish.m.flag.a.ints.d := 'integration number';
help::pkg.dish.dish.objs.dish.m.flag.a.ints.def := 'F';
help::pkg.dish.dish.objs.dish.m.flag.a.ints.a := 'integer or vector of ints';
help::pkg.dish.dish.objs.dish.m.flag.a.polarization := [=];
help::pkg.dish.dish.objs.dish.m.flag.a.polarization.d := 'polarization number(s) to flag';
help::pkg.dish.dish.objs.dish.m.flag.a.polarization.def := 'F';
help::pkg.dish.dish.objs.dish.m.flag.a.polarization.a := 'integer or vector of ints';
help::pkg.dish.dish.objs.dish.m.flag.a.channel := [=];
help::pkg.dish.dish.objs.dish.m.flag.a.channel.d := 'channel (range) to flag';
help::pkg.dish.dish.objs.dish.m.flag.a.channel.def := 'F';
help::pkg.dish.dish.objs.dish.m.flag.a.channel.a := 'integer or vector of ints';
help::pkg.dish.dish.objs.dish.m.flag.a.flag := [=];
help::pkg.dish.dish.objs.dish.m.flag.a.flag.d := 'flag (T) or unflag (F)';
help::pkg.dish.dish.objs.dish.m.flag.a.flag.def := 'T';
help::pkg.dish.dish.objs.dish.m.flag.a.flag.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.flag.s := 'flag(scan, ints, polarization, channel, flag)';
help::pkg.dish.dish.objs.dish.m.galactic := [=];
help::pkg.dish.dish.objs.dish.m.galactic.d := 'Provide coordinates of the globalscan1 spectrum  in the Galactic reference frame.';
help::pkg.dish.dish.objs.dish.m.galactic.a.quiet := [=];
help::pkg.dish.dish.objs.dish.m.galactic.a.quiet.d := 'indicate whether the results should be printed (quiet=F) or  returned as a glish record (quiet=T)';
help::pkg.dish.dish.objs.dish.m.galactic.a.quiet.def := 'F';
help::pkg.dish.dish.objs.dish.m.galactic.a.quiet.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.galactic.s := 'galactic(quiet)';
help::pkg.dish.dish.objs.dish.m.gauss := [=];
help::pkg.dish.dish.objs.dish.m.gauss.d := 'Fit gaussian profiles.';
help::pkg.dish.dish.objs.dish.m.gauss.a.ngauss := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.ngauss.d := 'number of gaussians to fit';
help::pkg.dish.dish.objs.dish.m.gauss.a.ngauss.def := 'no default';
help::pkg.dish.dish.objs.dish.m.gauss.a.ngauss.a := 'integer';
help::pkg.dish.dish.objs.dish.m.gauss.a.guess := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.guess.d := 'array with the guesses for height,center, and width';
help::pkg.dish.dish.objs.dish.m.gauss.a.guess.def := 'function will guess if none given';
help::pkg.dish.dish.objs.dish.m.gauss.a.guess.a := 'float';
help::pkg.dish.dish.objs.dish.m.gauss.a.prompt := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.prompt.d := 'prompt for mouse entry of limits and initial guesses';
help::pkg.dish.dish.objs.dish.m.gauss.a.prompt.def := 'F';
help::pkg.dish.dish.objs.dish.m.gauss.a.prompt.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.gauss.a.pol := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.pol.d := 'polarization number to use';
help::pkg.dish.dish.objs.dish.m.gauss.a.pol.def := '1';
help::pkg.dish.dish.objs.dish.m.gauss.a.pol.a := 'integer';
help::pkg.dish.dish.objs.dish.m.gauss.a.bchan := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.bchan.d := 'beginning channel number (pixel) of range to be fit';
help::pkg.dish.dish.objs.dish.m.gauss.a.bchan.def := '1';
help::pkg.dish.dish.objs.dish.m.gauss.a.bchan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.gauss.a.echan := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.echan.d := 'ending channel number (pixel) of range to be fit';
help::pkg.dish.dish.objs.dish.m.gauss.a.echan.def := 'full range';
help::pkg.dish.dish.objs.dish.m.gauss.a.echan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.gauss.a.plotfit := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.plotfit.d := 'flag to show fit on plot';
help::pkg.dish.dish.objs.dish.m.gauss.a.plotfit.def := 'T';
help::pkg.dish.dish.objs.dish.m.gauss.a.plotfit.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.gauss.a.plotresid := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.plotresid.d := 'flag to show residuals on plot';
help::pkg.dish.dish.objs.dish.m.gauss.a.plotresid.def := 'F';
help::pkg.dish.dish.objs.dish.m.gauss.a.plotresid.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.gauss.a.ploteach := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.ploteach.d := 'flag to show plots of individual components on plot';
help::pkg.dish.dish.objs.dish.m.gauss.a.ploteach.def := 'F';
help::pkg.dish.dish.objs.dish.m.gauss.a.ploteach.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.gauss.a.ret := [=];
help::pkg.dish.dish.objs.dish.m.gauss.a.ret.d := 'return fit components as a glish array?';
help::pkg.dish.dish.objs.dish.m.gauss.a.ret.def := 'F';
help::pkg.dish.dish.objs.dish.m.gauss.a.ret.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.gauss.s := 'gauss(ngauss, guess, prompt, pol, bchan, echan, plotfit, plotresid, ploteach, ret)';
help::pkg.dish.dish.objs.dish.m.gbtsum := [=];
help::pkg.dish.dish.objs.dish.m.gbtsum.d := 'Summarize scans in GBT projects from the /home/gbtdata area (GB only)';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.projname := [=];
help::pkg.dish.dish.objs.dish.m.gbtsum.a.projname.d := 'the project name';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.projname.def := 'no default';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.projname.a := 'string';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.source := [=];
help::pkg.dish.dish.objs.dish.m.gbtsum.a.source.d := 'source name';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.source.def := 'all';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.source.a := 'string';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.bscan := [=];
help::pkg.dish.dish.objs.dish.m.gbtsum.a.bscan.d := 'beginning scan to list';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.bscan.def := 'first';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.bscan.a := 'int';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.escan := [=];
help::pkg.dish.dish.objs.dish.m.gbtsum.a.escan.d := 'end scan to list';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.escan.def := 'last';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.escan.a := 'int';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.verbose := [=];
help::pkg.dish.dish.objs.dish.m.gbtsum.a.verbose.d := 'list extra information?';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.verbose.def := 'F';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.verbose.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.filename := [=];
help::pkg.dish.dish.objs.dish.m.gbtsum.a.filename.d := 'optional name of ASCII file to write';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.filename.def := 'none';
help::pkg.dish.dish.objs.dish.m.gbtsum.a.filename.a := 'string';
help::pkg.dish.dish.objs.dish.m.gbtsum.s := 'gbtsum(projname, source, bscan, escan, verbose, filename)';
help::pkg.dish.dish.objs.dish.m.getc := [=];
help::pkg.dish.dish.objs.dish.m.getc.d := 'Retrieve calibrated data (from the CORRECTED\_DATA column)';
help::pkg.dish.dish.objs.dish.m.getc.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.getc.a.scan.d := 'the scan number';
help::pkg.dish.dish.objs.dish.m.getc.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.getc.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getc.a.int := [=];
help::pkg.dish.dish.objs.dish.m.getc.a.int.d := 'the integration number';
help::pkg.dish.dish.objs.dish.m.getc.a.int.def := 'All integrations';
help::pkg.dish.dish.objs.dish.m.getc.a.int.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getc.a.pol := [=];
help::pkg.dish.dish.objs.dish.m.getc.a.pol.d := 'the polarization number';
help::pkg.dish.dish.objs.dish.m.getc.a.pol.def := 'All polarizations';
help::pkg.dish.dish.objs.dish.m.getc.a.pol.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.getc.a.nif := [=];
help::pkg.dish.dish.objs.dish.m.getc.a.nif.d := 'the IF number';
help::pkg.dish.dish.objs.dish.m.getc.a.nif.def := '1';
help::pkg.dish.dish.objs.dish.m.getc.a.nif.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getc.s := 'getc(scan, int, pol, nif)';
help::pkg.dish.dish.objs.dish.m.getr := [=];
help::pkg.dish.dish.objs.dish.m.getr.d := 'Retrieve raw data (from the FLOAT\_DATA column)';
help::pkg.dish.dish.objs.dish.m.getr.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.getr.a.scan.d := 'the scan number';
help::pkg.dish.dish.objs.dish.m.getr.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.getr.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getr.a.phase := [=];
help::pkg.dish.dish.objs.dish.m.getr.a.phase.d := 'the phase number';
help::pkg.dish.dish.objs.dish.m.getr.a.phase.def := 'no default';
help::pkg.dish.dish.objs.dish.m.getr.a.phase.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getr.a.int := [=];
help::pkg.dish.dish.objs.dish.m.getr.a.int.d := 'the integration number';
help::pkg.dish.dish.objs.dish.m.getr.a.int.def := 'All integrations';
help::pkg.dish.dish.objs.dish.m.getr.a.int.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getr.a.pol := [=];
help::pkg.dish.dish.objs.dish.m.getr.a.pol.d := 'the polarization number';
help::pkg.dish.dish.objs.dish.m.getr.a.pol.def := 'All polarizations';
help::pkg.dish.dish.objs.dish.m.getr.a.pol.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.getr.a.nif := [=];
help::pkg.dish.dish.objs.dish.m.getr.a.nif.d := 'the IF number';
help::pkg.dish.dish.objs.dish.m.getr.a.nif.def := '1';
help::pkg.dish.dish.objs.dish.m.getr.a.nif.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getr.s := 'getr(scan, phase, int, pol, nif)';
help::pkg.dish.dish.objs.dish.m.getscan := [=];
help::pkg.dish.dish.objs.dish.m.getscan.d := 'Retrieve a scan (SDRecord) from a scan group.';
help::pkg.dish.dish.objs.dish.m.getscan.a.scannumber := [=];
help::pkg.dish.dish.objs.dish.m.getscan.a.scannumber.d := 'the scan number';
help::pkg.dish.dish.objs.dish.m.getscan.a.scannumber.def := 'no default';
help::pkg.dish.dish.objs.dish.m.getscan.a.scannumber.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getscan.a.subscan := [=];
help::pkg.dish.dish.objs.dish.m.getscan.a.subscan.d := 'the subscan number';
help::pkg.dish.dish.objs.dish.m.getscan.a.subscan.def := '1';
help::pkg.dish.dish.objs.dish.m.getscan.a.subscan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getscan.a.resync := [=];
help::pkg.dish.dish.objs.dish.m.getscan.a.resync.d := 'update the cache';
help::pkg.dish.dish.objs.dish.m.getscan.a.resync.def := 'F';
help::pkg.dish.dish.objs.dish.m.getscan.a.resync.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.getscan.a.setgs := [=];
help::pkg.dish.dish.objs.dish.m.getscan.a.setgs.d := 'copy the result to the globalscan array?';
help::pkg.dish.dish.objs.dish.m.getscan.a.setgs.def := 'T';
help::pkg.dish.dish.objs.dish.m.getscan.a.setgs.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.getscan.s := 'getscan(scannumber, subscan, resync, setgs)';
help::pkg.dish.dish.objs.dish.m.getvf := [=];
help::pkg.dish.dish.objs.dish.m.getvf.d := 'Prints the velocity and frequency for a specified channel.';
help::pkg.dish.dish.objs.dish.m.getvf.a.chan := [=];
help::pkg.dish.dish.objs.dish.m.getvf.a.chan.d := 'channel of interest';
help::pkg.dish.dish.objs.dish.m.getvf.a.chan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.getvf.a.chan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.getvf.a.dop := [=];
help::pkg.dish.dish.objs.dish.m.getvf.a.dop.d := 'Doppler convention';
help::pkg.dish.dish.objs.dish.m.getvf.a.dop.def := 'RADIO';
help::pkg.dish.dish.objs.dish.m.getvf.a.dop.a := 'RADIO, OPTICAL or TRUE';
help::pkg.dish.dish.objs.dish.m.getvf.a.refframe := [=];
help::pkg.dish.dish.objs.dish.m.getvf.a.refframe.d := 'Reference Frame';
help::pkg.dish.dish.objs.dish.m.getvf.a.refframe.def := 'LSRK';
help::pkg.dish.dish.objs.dish.m.getvf.a.refframe.a := 'LSRK, LSRD, BARY, GEO, TOPO or GALACTO';
help::pkg.dish.dish.objs.dish.m.getvf.s := 'getvf(chan, dop, refframe)';
help::pkg.dish.dish.objs.dish.m.getvfarray := [=];
help::pkg.dish.dish.objs.dish.m.getvfarray.d := 'Return the velocities and frequencies for  the globalscan1 spectrum.';
help::pkg.dish.dish.objs.dish.m.getvfarray.a.dop := [=];
help::pkg.dish.dish.objs.dish.m.getvfarray.a.dop.d := 'Doppler convention';
help::pkg.dish.dish.objs.dish.m.getvfarray.a.dop.def := 'RADIO';
help::pkg.dish.dish.objs.dish.m.getvfarray.a.dop.a := 'RADIO, OPTICAL or TRUE';
help::pkg.dish.dish.objs.dish.m.getvfarray.a.refframe := [=];
help::pkg.dish.dish.objs.dish.m.getvfarray.a.refframe.d := 'Reference Frame';
help::pkg.dish.dish.objs.dish.m.getvfarray.a.refframe.def := 'LSRK';
help::pkg.dish.dish.objs.dish.m.getvfarray.a.refframe.a := 'LSRK, LSRD, BARY, GEO, TOPO or GALACTO';
help::pkg.dish.dish.objs.dish.m.getvfarray.s := 'getvfarray(dop, refframe)';
help::pkg.dish.dish.objs.dish.m.gms := [=];
help::pkg.dish.dish.objs.dish.m.gms.d := 'Summarize the scans in the currently opened data set.';
help::pkg.dish.dish.objs.dish.m.gms.a.verbose := [=];
help::pkg.dish.dish.objs.dish.m.gms.a.verbose.d := 'indicate level of output';
help::pkg.dish.dish.objs.dish.m.gms.a.verbose.def := 'F';
help::pkg.dish.dish.objs.dish.m.gms.a.verbose.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.gms.s := 'gms(verbose)';
help::pkg.dish.dish.objs.dish.m.gsflag := [=];
help::pkg.dish.dish.objs.dish.m.gsflag.d := 'Flag some channels in the globalscan1 spectrum';
help::pkg.dish.dish.objs.dish.m.gsflag.a.pol := [=];
help::pkg.dish.dish.objs.dish.m.gsflag.a.pol.d := 'polarization to flag; 0 means flag all';
help::pkg.dish.dish.objs.dish.m.gsflag.a.pol.def := '0';
help::pkg.dish.dish.objs.dish.m.gsflag.a.pol.a := 'integer';
help::pkg.dish.dish.objs.dish.m.gsflag.a.bchan := [=];
help::pkg.dish.dish.objs.dish.m.gsflag.a.bchan.d := 'beginning channel in range';
help::pkg.dish.dish.objs.dish.m.gsflag.a.bchan.def := 'F';
help::pkg.dish.dish.objs.dish.m.gsflag.a.bchan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.gsflag.a.echan := [=];
help::pkg.dish.dish.objs.dish.m.gsflag.a.echan.d := 'ending channel in range';
help::pkg.dish.dish.objs.dish.m.gsflag.a.echan.def := 'bchan';
help::pkg.dish.dish.objs.dish.m.gsflag.a.echan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.gsflag.a.flagval := [=];
help::pkg.dish.dish.objs.dish.m.gsflag.a.flagval.d := 'flag (T) or unflag (F)';
help::pkg.dish.dish.objs.dish.m.gsflag.a.flagval.def := 'T';
help::pkg.dish.dish.objs.dish.m.gsflag.a.flagval.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.gsflag.s := 'gsflag(pol, bchan, echan, flagval)';
help::pkg.dish.dish.objs.dish.m.gsget := [=];
help::pkg.dish.dish.objs.dish.m.gsget.d := 'Retrieves the globalscan1 record to a glish variable';
help::pkg.dish.dish.objs.dish.m.gsget.s := 'gsget()';
help::pkg.dish.dish.objs.dish.m.gsput := [=];
help::pkg.dish.dish.objs.dish.m.gsput.d := 'Sends an sdrecord from glish to the globalscan1 record';
help::pkg.dish.dish.objs.dish.m.gsput.a.sdrec := [=];
help::pkg.dish.dish.objs.dish.m.gsput.a.sdrec.d := 'sdrecord to place into globalscan1';
help::pkg.dish.dish.objs.dish.m.gsput.a.sdrec.def := '';
help::pkg.dish.dish.objs.dish.m.gsput.a.sdrec.a := 'sdrecord';
help::pkg.dish.dish.objs.dish.m.gsput.s := 'gsput(sdrec)';
help::pkg.dish.dish.objs.dish.m.gsread := [=];
help::pkg.dish.dish.objs.dish.m.gsread.d := 'Retrieve a spectrum saved to disk into the globalscan1 record';
help::pkg.dish.dish.objs.dish.m.gsread.a.file := [=];
help::pkg.dish.dish.objs.dish.m.gsread.a.file.d := 'filename';
help::pkg.dish.dish.objs.dish.m.gsread.a.file.def := '';
help::pkg.dish.dish.objs.dish.m.gsread.a.file.a := 'string';
help::pkg.dish.dish.objs.dish.m.gsread.s := 'gsread(file)';
help::pkg.dish.dish.objs.dish.m.gswrite := [=];
help::pkg.dish.dish.objs.dish.m.gswrite.d := 'Write the globalscan1 spectrum to disk';
help::pkg.dish.dish.objs.dish.m.gswrite.a.file := [=];
help::pkg.dish.dish.objs.dish.m.gswrite.a.file.d := 'filename';
help::pkg.dish.dish.objs.dish.m.gswrite.a.file.def := '';
help::pkg.dish.dish.objs.dish.m.gswrite.a.file.a := 'string';
help::pkg.dish.dish.objs.dish.m.gswrite.s := 'gswrite(file)';
help::pkg.dish.dish.objs.dish.m.gui := [=];
help::pkg.dish.dish.objs.dish.m.gui.d := 'Toggles mapping of DISH main gui (results manager).';
help::pkg.dish.dish.objs.dish.m.gui.s := 'gui()';
help::pkg.dish.dish.objs.dish.m.hanning := [=];
help::pkg.dish.dish.objs.dish.m.hanning.d := 'Perform a hanning smooth';
help::pkg.dish.dish.objs.dish.m.hanning.s := 'hanning()';
help::pkg.dish.dish.objs.dish.m.header := [=];
help::pkg.dish.dish.objs.dish.m.header.d := 'Print formatted header information to the command line window';
help::pkg.dish.dish.objs.dish.m.header.s := 'header()';
help::pkg.dish.dish.objs.dish.m.help := [=];
help::pkg.dish.dish.objs.dish.m.help.d := 'Provide simple help on dish functions';
help::pkg.dish.dish.objs.dish.m.help.a.dishfn := [=];
help::pkg.dish.dish.objs.dish.m.help.a.dishfn.d := 'Name of dish function';
help::pkg.dish.dish.objs.dish.m.help.a.dishfn.def := 'no default';
help::pkg.dish.dish.objs.dish.m.help.a.dishfn.a := 'String';
help::pkg.dish.dish.objs.dish.m.help.a.driveweb := [=];
help::pkg.dish.dish.objs.dish.m.help.a.driveweb.d := 'Drive the browser to the URM help';
help::pkg.dish.dish.objs.dish.m.help.a.driveweb.def := 'F';
help::pkg.dish.dish.objs.dish.m.help.a.driveweb.a := 'Boolean';
help::pkg.dish.dish.objs.dish.m.help.s := 'help(dishfn, driveweb)';
help::pkg.dish.dish.objs.dish.m.history := [=];
help::pkg.dish.dish.objs.dish.m.history.d := 'Add a string or vector of strings to the history of a current SDRecord.';
help::pkg.dish.dish.objs.dish.m.history.a.scanrec := [=];
help::pkg.dish.dish.objs.dish.m.history.a.scanrec.d := 'SDRecord to add history to';
help::pkg.dish.dish.objs.dish.m.history.a.scanrec.def := 'no default';
help::pkg.dish.dish.objs.dish.m.history.a.scanrec.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.history.a.history := [=];
help::pkg.dish.dish.objs.dish.m.history.a.history.d := 'text to add to history';
help::pkg.dish.dish.objs.dish.m.history.a.history.def := 'no default';
help::pkg.dish.dish.objs.dish.m.history.a.history.a := 'string';
help::pkg.dish.dish.objs.dish.m.history.s := 'history(scanrec, history)';
help::pkg.dish.dish.objs.dish.m.imagems := [=];
help::pkg.dish.dish.objs.dish.m.imagems.d := 'Make an image from all scans in a MeasurementSet.';
help::pkg.dish.dish.objs.dish.m.imagems.a.msname := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.msname.d := 'MeasurementSet name';
help::pkg.dish.dish.objs.dish.m.imagems.a.msname.def := 'no default';
help::pkg.dish.dish.objs.dish.m.imagems.a.msname.a := 'string';
help::pkg.dish.dish.objs.dish.m.imagems.a.start := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.start.d := 'starting channel';
help::pkg.dish.dish.objs.dish.m.imagems.a.start.def := 'no default';
help::pkg.dish.dish.objs.dish.m.imagems.a.start.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imagems.a.stop := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.stop.d := 'stopping channel';
help::pkg.dish.dish.objs.dish.m.imagems.a.stop.def := 'no default';
help::pkg.dish.dish.objs.dish.m.imagems.a.stop.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imagems.a.step := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.step.d := 'number of channels to average over for final cube';
help::pkg.dish.dish.objs.dish.m.imagems.a.step.def := '1';
help::pkg.dish.dish.objs.dish.m.imagems.a.step.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imagems.a.imname := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.imname.d := 'name of output image';
help::pkg.dish.dish.objs.dish.m.imagems.a.imname.def := 'scanimage';
help::pkg.dish.dish.objs.dish.m.imagems.a.imname.a := 'string';
help::pkg.dish.dish.objs.dish.m.imagems.a.spwid := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.spwid.d := 'spectral window id number';
help::pkg.dish.dish.objs.dish.m.imagems.a.spwid.def := 'F';
help::pkg.dish.dish.objs.dish.m.imagems.a.spwid.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imagems.a.nx := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.nx.d := 'number of cells in x';
help::pkg.dish.dish.objs.dish.m.imagems.a.nx.def := 'F';
help::pkg.dish.dish.objs.dish.m.imagems.a.nx.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imagems.a.ny := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.ny.d := 'number of cells in y';
help::pkg.dish.dish.objs.dish.m.imagems.a.ny.def := 'F';
help::pkg.dish.dish.objs.dish.m.imagems.a.ny.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imagems.a.cellx := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.cellx.d := 'cell size in x';
help::pkg.dish.dish.objs.dish.m.imagems.a.cellx.def := 'F';
help::pkg.dish.dish.objs.dish.m.imagems.a.cellx.a := 'string';
help::pkg.dish.dish.objs.dish.m.imagems.a.celly := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.celly.d := 'cell size in y';
help::pkg.dish.dish.objs.dish.m.imagems.a.celly.def := 'F';
help::pkg.dish.dish.objs.dish.m.imagems.a.celly.a := 'string';
help::pkg.dish.dish.objs.dish.m.imagems.a.gridfn := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.gridfn.d := 'gridfunction to use; BOX, PB or SF';
help::pkg.dish.dish.objs.dish.m.imagems.a.gridfn.def := 'BOX';
help::pkg.dish.dish.objs.dish.m.imagems.a.gridfn.a := 'string';
help::pkg.dish.dish.objs.dish.m.imagems.a.convsupport := [=];
help::pkg.dish.dish.objs.dish.m.imagems.a.convsupport.d := 'convolution support radius for BOX or SF';
help::pkg.dish.dish.objs.dish.m.imagems.a.convsupport.def := 'F';
help::pkg.dish.dish.objs.dish.m.imagems.a.convsupport.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imagems.s := 'imagems(msname, start, stop, step, imname, spwid, nx, ny, cellx, celly, gridfn, convsupport)';
help::pkg.dish.dish.objs.dish.m.imcal := [=];
help::pkg.dish.dish.objs.dish.m.imcal.d := 'Calibrate an imaging/mapping procedure';
help::pkg.dish.dish.objs.dish.m.imcal.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.imcal.a.scan.d := 'scan number';
help::pkg.dish.dish.objs.dish.m.imcal.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.imcal.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imcal.a.baseline := [=];
help::pkg.dish.dish.objs.dish.m.imcal.a.baseline.d := 'toggle baseline subtraction on or off';
help::pkg.dish.dish.objs.dish.m.imcal.a.baseline.def := 'F';
help::pkg.dish.dish.objs.dish.m.imcal.a.baseline.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.imcal.a.range := [=];
help::pkg.dish.dish.objs.dish.m.imcal.a.range.d := 'range for baseline';
help::pkg.dish.dish.objs.dish.m.imcal.a.range.def := 'F(full range)';
help::pkg.dish.dish.objs.dish.m.imcal.a.range.a := 'string';
help::pkg.dish.dish.objs.dish.m.imcal.a.order := [=];
help::pkg.dish.dish.objs.dish.m.imcal.a.order.d := 'order of baseline fit';
help::pkg.dish.dish.objs.dish.m.imcal.a.order.def := '1';
help::pkg.dish.dish.objs.dish.m.imcal.a.order.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imcal.a.units := [=];
help::pkg.dish.dish.objs.dish.m.imcal.a.units.d := 'units for calibrated result';
help::pkg.dish.dish.objs.dish.m.imcal.a.units.def := '1=TA*,2=TMB,3=S';
help::pkg.dish.dish.objs.dish.m.imcal.a.units.a := 'integer';
help::pkg.dish.dish.objs.dish.m.imcal.s := 'imcal(scan, baseline, range, order, units)';
help::pkg.dish.dish.objs.dish.m.import := [=];
help::pkg.dish.dish.objs.dish.m.import.d := 'Import GBT data into an AIPS++ MeasurementSet';
help::pkg.dish.dish.objs.dish.m.import.a.projdir := [=];
help::pkg.dish.dish.objs.dish.m.import.a.projdir.d := 'project directory';
help::pkg.dish.dish.objs.dish.m.import.a.projdir.def := 'no default';
help::pkg.dish.dish.objs.dish.m.import.a.projdir.a := 'string';
help::pkg.dish.dish.objs.dish.m.import.a.outms := [=];
help::pkg.dish.dish.objs.dish.m.import.a.outms.d := 'output MeasurementSet';
help::pkg.dish.dish.objs.dish.m.import.a.outms.def := 'name derived from projdir';
help::pkg.dish.dish.objs.dish.m.import.a.outms.a := 'string';
help::pkg.dish.dish.objs.dish.m.import.a.outmsdir := [=];
help::pkg.dish.dish.objs.dish.m.import.a.outmsdir.d := 'directory for output MS';
help::pkg.dish.dish.objs.dish.m.import.a.outmsdir.def := 'current directory';
help::pkg.dish.dish.objs.dish.m.import.a.outmsdir.a := 'string';
help::pkg.dish.dish.objs.dish.m.import.a.startscan := [=];
help::pkg.dish.dish.objs.dish.m.import.a.startscan.d := 'starting scan to begin filling';
help::pkg.dish.dish.objs.dish.m.import.a.startscan.def := 'first scan in projdir';
help::pkg.dish.dish.objs.dish.m.import.a.startscan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.import.a.stopscan := [=];
help::pkg.dish.dish.objs.dish.m.import.a.stopscan.d := 'ending scan for filling';
help::pkg.dish.dish.objs.dish.m.import.a.stopscan.def := 'last scan in projdir';
help::pkg.dish.dish.objs.dish.m.import.a.stopscan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.import.a.backend := [=];
help::pkg.dish.dish.objs.dish.m.import.a.backend.d := 'which backend to fill';
help::pkg.dish.dish.objs.dish.m.import.a.backend.def := 'all';
help::pkg.dish.dish.objs.dish.m.import.a.backend.a := 'string';
help::pkg.dish.dish.objs.dish.m.import.a.calflag := [=];
help::pkg.dish.dish.objs.dish.m.import.a.calflag.d := 'toggle to permit automated calibration upon filling';
help::pkg.dish.dish.objs.dish.m.import.a.calflag.def := 'F';
help::pkg.dish.dish.objs.dish.m.import.a.calflag.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.import.s := 'import(projdir, outms, outmsdir, startscan, stopscan, backend, calflag)';
help::pkg.dish.dish.objs.dish.m.keep := [=];
help::pkg.dish.dish.objs.dish.m.keep.d := 'Saves the current globalscan1 SDRecord to the designated fileout.';
help::pkg.dish.dish.objs.dish.m.keep.s := 'keep()';
help::pkg.dish.dish.objs.dish.m.listscans := [=];
help::pkg.dish.dish.objs.dish.m.listscans.d := 'List the scan numbers from the active scan group.';
help::pkg.dish.dish.objs.dish.m.listscans.s := 'listscans()';
help::pkg.dish.dish.objs.dish.m.logcommand := [=];
help::pkg.dish.dish.objs.dish.m.logcommand.d := 'Writes command to scripter.';
help::pkg.dish.dish.objs.dish.m.logcommand.s := 'logcommand()';
help::pkg.dish.dish.objs.dish.m.lsoutfile := [=];
help::pkg.dish.dish.objs.dish.m.lsoutfile.d := 'Lists scans in the fileout scangroup';
help::pkg.dish.dish.objs.dish.m.lsoutfile.s := 'lsoutfile()';
help::pkg.dish.dish.objs.dish.m.makeim := [=];
help::pkg.dish.dish.objs.dish.m.makeim.d := 'Make an image from scans in a MeasurementSet.';
help::pkg.dish.dish.objs.dish.m.makeim.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.scan.d := 'scan number';
help::pkg.dish.dish.objs.dish.m.makeim.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.makeim.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.makeim.a.start := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.start.d := 'starting channel';
help::pkg.dish.dish.objs.dish.m.makeim.a.start.def := 'no default';
help::pkg.dish.dish.objs.dish.m.makeim.a.start.a := 'integer';
help::pkg.dish.dish.objs.dish.m.makeim.a.stop := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.stop.d := 'stopping channel';
help::pkg.dish.dish.objs.dish.m.makeim.a.stop.def := 'no default';
help::pkg.dish.dish.objs.dish.m.makeim.a.stop.a := 'integer';
help::pkg.dish.dish.objs.dish.m.makeim.a.step := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.step.d := 'number of channels to average over for final cube';
help::pkg.dish.dish.objs.dish.m.makeim.a.step.def := '1';
help::pkg.dish.dish.objs.dish.m.makeim.a.step.a := 'integer';
help::pkg.dish.dish.objs.dish.m.makeim.a.imname := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.imname.d := 'name of output image';
help::pkg.dish.dish.objs.dish.m.makeim.a.imname.def := 'scanimage';
help::pkg.dish.dish.objs.dish.m.makeim.a.imname.a := 'string';
help::pkg.dish.dish.objs.dish.m.makeim.a.spwid := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.spwid.d := 'spectral window id number';
help::pkg.dish.dish.objs.dish.m.makeim.a.spwid.def := 'F';
help::pkg.dish.dish.objs.dish.m.makeim.a.spwid.a := 'integer';
help::pkg.dish.dish.objs.dish.m.makeim.a.nx := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.nx.d := 'number of cells in x';
help::pkg.dish.dish.objs.dish.m.makeim.a.nx.def := 'F';
help::pkg.dish.dish.objs.dish.m.makeim.a.nx.a := 'integer';
help::pkg.dish.dish.objs.dish.m.makeim.a.ny := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.ny.d := 'number of cells in y';
help::pkg.dish.dish.objs.dish.m.makeim.a.ny.def := 'F';
help::pkg.dish.dish.objs.dish.m.makeim.a.ny.a := 'integer';
help::pkg.dish.dish.objs.dish.m.makeim.a.cellx := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.cellx.d := 'cell size in x';
help::pkg.dish.dish.objs.dish.m.makeim.a.cellx.def := 'F';
help::pkg.dish.dish.objs.dish.m.makeim.a.cellx.a := 'string';
help::pkg.dish.dish.objs.dish.m.makeim.a.celly := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.celly.d := 'cell size in y';
help::pkg.dish.dish.objs.dish.m.makeim.a.celly.def := 'F';
help::pkg.dish.dish.objs.dish.m.makeim.a.celly.a := 'string';
help::pkg.dish.dish.objs.dish.m.makeim.a.gridfn := [=];
help::pkg.dish.dish.objs.dish.m.makeim.a.gridfn.d := 'gridding function';
help::pkg.dish.dish.objs.dish.m.makeim.a.gridfn.def := 'BOX';
help::pkg.dish.dish.objs.dish.m.makeim.a.gridfn.a := '\' BOX\' , \' PB\' , or \' SF\' ';
help::pkg.dish.dish.objs.dish.m.makeim.s := 'makeim(scan, start, stop, step, imname, spwid, nx, ny, cellx, celly, gridfn)';
help::pkg.dish.dish.objs.dish.m.message := [=];
help::pkg.dish.dish.objs.dish.m.message.d := 'Writes text to the DISH GUI message line.';
help::pkg.dish.dish.objs.dish.m.message.a.message := [=];
help::pkg.dish.dish.objs.dish.m.message.a.message.d := 'The message to send to DISH message line';
help::pkg.dish.dish.objs.dish.m.message.a.message.def := 'no default';
help::pkg.dish.dish.objs.dish.m.message.a.message.a := 'string';
help::pkg.dish.dish.objs.dish.m.message.s := 'message(message)';
help::pkg.dish.dish.objs.dish.m.minus := [=];
help::pkg.dish.dish.objs.dish.m.minus.d := 'Subtract offscan1 from globalscan1.';
help::pkg.dish.dish.objs.dish.m.minus.s := 'minus()';
help::pkg.dish.dish.objs.dish.m.mscal := [=];
help::pkg.dish.dish.objs.dish.m.mscal.d := 'Calibrate a MeasurementSet.';
help::pkg.dish.dish.objs.dish.m.mscal.a.baseline := [=];
help::pkg.dish.dish.objs.dish.m.mscal.a.baseline.d := 'toggle to permit baselines to be subtracted';
help::pkg.dish.dish.objs.dish.m.mscal.a.baseline.def := 'F';
help::pkg.dish.dish.objs.dish.m.mscal.a.baseline.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.mscal.a.range := [=];
help::pkg.dish.dish.objs.dish.m.mscal.a.range.d := 'the range for the baseline';
help::pkg.dish.dish.objs.dish.m.mscal.a.range.def := 'F(full range)';
help::pkg.dish.dish.objs.dish.m.mscal.a.range.a := 'string';
help::pkg.dish.dish.objs.dish.m.mscal.a.order := [=];
help::pkg.dish.dish.objs.dish.m.mscal.a.order.d := 'the polynomial order for the baseline';
help::pkg.dish.dish.objs.dish.m.mscal.a.order.def := '1';
help::pkg.dish.dish.objs.dish.m.mscal.a.order.a := 'integer';
help::pkg.dish.dish.objs.dish.m.mscal.a.units := [=];
help::pkg.dish.dish.objs.dish.m.mscal.a.units.d := 'the units of the calibrated output';
help::pkg.dish.dish.objs.dish.m.mscal.a.units.def := '1(TA*)';
help::pkg.dish.dish.objs.dish.m.mscal.a.units.a := 'integer';
help::pkg.dish.dish.objs.dish.m.mscal.s := 'mscal(baseline, range, order, units)';
help::pkg.dish.dish.objs.dish.m.mult := [=];
help::pkg.dish.dish.objs.dish.m.mult.d := 'Scales (multiplies) a scan by a value.';
help::pkg.dish.dish.objs.dish.m.mult.a.factor := [=];
help::pkg.dish.dish.objs.dish.m.mult.a.factor.d := 'The factor to multiply by';
help::pkg.dish.dish.objs.dish.m.mult.a.factor.def := 'no default';
help::pkg.dish.dish.objs.dish.m.mult.a.factor.a := 'float';
help::pkg.dish.dish.objs.dish.m.mult.s := 'mult(factor)';
help::pkg.dish.dish.objs.dish.m.multiply := [=];
help::pkg.dish.dish.objs.dish.m.multiply.d := 'Multiply globalscan1 by offscan1.';
help::pkg.dish.dish.objs.dish.m.multiply.s := 'multiply()';
help::pkg.dish.dish.objs.dish.m.nfit := [=];
help::pkg.dish.dish.objs.dish.m.nfit.d := 'Set the order of the polynomial for baseline subtraction.';
help::pkg.dish.dish.objs.dish.m.nfit.a.value := [=];
help::pkg.dish.dish.objs.dish.m.nfit.a.value.d := 'The order of the polynomial';
help::pkg.dish.dish.objs.dish.m.nfit.a.value.def := 'none';
help::pkg.dish.dish.objs.dish.m.nfit.a.value.a := 'integer';
help::pkg.dish.dish.objs.dish.m.nfit.s := 'nfit(value)';
help::pkg.dish.dish.objs.dish.m.nogui := [=];
help::pkg.dish.dish.objs.dish.m.nogui.d := 'Dismisses the DISH main GUI.';
help::pkg.dish.dish.objs.dish.m.nogui.s := 'nogui()';
help::pkg.dish.dish.objs.dish.m.nregion := [=];
help::pkg.dish.dish.objs.dish.m.nregion.d := 'Set the channel ranges for baseline subtraction.';
help::pkg.dish.dish.objs.dish.m.nregion.a.dots := [=];
help::pkg.dish.dish.objs.dish.m.nregion.a.dots.d := 'channel numbers to demark a range';
help::pkg.dish.dish.objs.dish.m.nregion.a.dots.def := '';
help::pkg.dish.dish.objs.dish.m.nregion.a.dots.a := 'integers';
help::pkg.dish.dish.objs.dish.m.nregion.s := 'nregion(...)';
help::pkg.dish.dish.objs.dish.m.open := [=];
help::pkg.dish.dish.objs.dish.m.open.d := 'Load a scan group from disk into DISH and perform a filein on it.';
help::pkg.dish.dish.objs.dish.m.open.a.file := [=];
help::pkg.dish.dish.objs.dish.m.open.a.file.d := 'File on disk to be opened. This file becomes a glish variable in  the Results Manager';
help::pkg.dish.dish.objs.dish.m.open.a.file.def := 'no default';
help::pkg.dish.dish.objs.dish.m.open.a.file.a := 'string';
help::pkg.dish.dish.objs.dish.m.open.a.access := [=];
help::pkg.dish.dish.objs.dish.m.open.a.access.d := 'permissions for file (\' r\'  readonly or \' w\'  for writable';
help::pkg.dish.dish.objs.dish.m.open.a.access.def := '\' r\' ';
help::pkg.dish.dish.objs.dish.m.open.a.access.a := 'string';
help::pkg.dish.dish.objs.dish.m.open.a.new := [=];
help::pkg.dish.dish.objs.dish.m.open.a.new.d := 'Should it create an empty file on disk (for saving to)';
help::pkg.dish.dish.objs.dish.m.open.a.new.def := 'F';
help::pkg.dish.dish.objs.dish.m.open.a.new.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.open.a.corrdata := [=];
help::pkg.dish.dish.objs.dish.m.open.a.corrdata.d := 'look at CORRECTED\_DATA column?';
help::pkg.dish.dish.objs.dish.m.open.a.corrdata.def := 'T';
help::pkg.dish.dish.objs.dish.m.open.a.corrdata.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.open.a.filein := [=];
help::pkg.dish.dish.objs.dish.m.open.a.filein.d := 'should this dataset be the default filein';
help::pkg.dish.dish.objs.dish.m.open.a.filein.def := 'T';
help::pkg.dish.dish.objs.dish.m.open.a.filein.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.open.s := 'open(file, access, new, corrdata, filein)';
help::pkg.dish.dish.objs.dish.m.page := [=];
help::pkg.dish.dish.objs.dish.m.page.d := 'Clears the DISH plotter display.';
help::pkg.dish.dish.objs.dish.m.page.s := 'page()';
help::pkg.dish.dish.objs.dish.m.peak := [=];
help::pkg.dish.dish.objs.dish.m.peak.d := 'Obtain the peak amplitude, half-width and center in the displayed spectrum';
help::pkg.dish.dish.objs.dish.m.peak.a.quiet := [=];
help::pkg.dish.dish.objs.dish.m.peak.a.quiet.d := 'Display the output to command window';
help::pkg.dish.dish.objs.dish.m.peak.a.quiet.def := 'F';
help::pkg.dish.dish.objs.dish.m.peak.a.quiet.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.peak.s := 'peak(quiet)';
help::pkg.dish.dish.objs.dish.m.plotc := [=];
help::pkg.dish.dish.objs.dish.m.plotc.d := 'Plot calibrated data (from the CORRECTED\_DATA column)';
help::pkg.dish.dish.objs.dish.m.plotc.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.plotc.a.scan.d := 'the scan number';
help::pkg.dish.dish.objs.dish.m.plotc.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.plotc.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.plotc.a.int := [=];
help::pkg.dish.dish.objs.dish.m.plotc.a.int.d := 'the integration number';
help::pkg.dish.dish.objs.dish.m.plotc.a.int.def := 'All integrations';
help::pkg.dish.dish.objs.dish.m.plotc.a.int.a := 'integer';
help::pkg.dish.dish.objs.dish.m.plotc.a.pol := [=];
help::pkg.dish.dish.objs.dish.m.plotc.a.pol.d := 'the polarization number';
help::pkg.dish.dish.objs.dish.m.plotc.a.pol.def := 'All polarizations';
help::pkg.dish.dish.objs.dish.m.plotc.a.pol.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.plotc.a.nif := [=];
help::pkg.dish.dish.objs.dish.m.plotc.a.nif.d := 'the IF number';
help::pkg.dish.dish.objs.dish.m.plotc.a.nif.def := '1';
help::pkg.dish.dish.objs.dish.m.plotc.a.nif.a := 'integer';
help::pkg.dish.dish.objs.dish.m.plotc.s := 'plotc(scan, int, pol, nif)';
help::pkg.dish.dish.objs.dish.m.plotr := [=];
help::pkg.dish.dish.objs.dish.m.plotr.d := 'Plot raw data (from the FLOAT\_DATA column)';
help::pkg.dish.dish.objs.dish.m.plotr.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.plotr.a.scan.d := 'the scan number';
help::pkg.dish.dish.objs.dish.m.plotr.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.plotr.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.plotr.a.phase := [=];
help::pkg.dish.dish.objs.dish.m.plotr.a.phase.d := 'the phase number';
help::pkg.dish.dish.objs.dish.m.plotr.a.phase.def := 'no default';
help::pkg.dish.dish.objs.dish.m.plotr.a.phase.a := 'integer';
help::pkg.dish.dish.objs.dish.m.plotr.a.int := [=];
help::pkg.dish.dish.objs.dish.m.plotr.a.int.d := 'the integration number';
help::pkg.dish.dish.objs.dish.m.plotr.a.int.def := 'All integrations';
help::pkg.dish.dish.objs.dish.m.plotr.a.int.a := 'integer';
help::pkg.dish.dish.objs.dish.m.plotr.a.pol := [=];
help::pkg.dish.dish.objs.dish.m.plotr.a.pol.d := 'the polarization number';
help::pkg.dish.dish.objs.dish.m.plotr.a.pol.def := 'All polarizations';
help::pkg.dish.dish.objs.dish.m.plotr.a.pol.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.plotr.a.nif := [=];
help::pkg.dish.dish.objs.dish.m.plotr.a.nif.d := 'the IF number';
help::pkg.dish.dish.objs.dish.m.plotr.a.nif.def := '1';
help::pkg.dish.dish.objs.dish.m.plotr.a.nif.a := 'integer';
help::pkg.dish.dish.objs.dish.m.plotr.s := 'plotr(scan, phase, int, pol, nif)';
help::pkg.dish.dish.objs.dish.m.plotscan := [=];
help::pkg.dish.dish.objs.dish.m.plotscan.d := 'Plot an SDRecord.';
help::pkg.dish.dish.objs.dish.m.plotscan.a.scanrec := [=];
help::pkg.dish.dish.objs.dish.m.plotscan.a.scanrec.d := 'An SDRecord to be plotted';
help::pkg.dish.dish.objs.dish.m.plotscan.a.scanrec.def := 'no default';
help::pkg.dish.dish.objs.dish.m.plotscan.a.scanrec.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.plotscan.a.overlay := [=];
help::pkg.dish.dish.objs.dish.m.plotscan.a.overlay.d := 'overlay (T) or don\' t overlay(F)';
help::pkg.dish.dish.objs.dish.m.plotscan.a.overlay.def := 'F';
help::pkg.dish.dish.objs.dish.m.plotscan.a.overlay.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.plotscan.s := 'plotscan(scanrec, overlay)';
help::pkg.dish.dish.objs.dish.m.plotxy := [=];
help::pkg.dish.dish.objs.dish.m.plotxy.d := 'Plot two vectors in the DISH plotter.';
help::pkg.dish.dish.objs.dish.m.plotxy.a.xarray := [=];
help::pkg.dish.dish.objs.dish.m.plotxy.a.xarray.d := 'vector of values for the x axis';
help::pkg.dish.dish.objs.dish.m.plotxy.a.xarray.def := 'no default';
help::pkg.dish.dish.objs.dish.m.plotxy.a.xarray.a := 'vector of floats';
help::pkg.dish.dish.objs.dish.m.plotxy.a.yarray := [=];
help::pkg.dish.dish.objs.dish.m.plotxy.a.yarray.d := 'vector of values for the y axis';
help::pkg.dish.dish.objs.dish.m.plotxy.a.yarray.def := 'no default';
help::pkg.dish.dish.objs.dish.m.plotxy.a.yarray.a := 'vector of floats';
help::pkg.dish.dish.objs.dish.m.plotxy.a.newplot := [=];
help::pkg.dish.dish.objs.dish.m.plotxy.a.newplot.d := 'Create a new plot(T) or overlay this(F)';
help::pkg.dish.dish.objs.dish.m.plotxy.a.newplot.def := 'T';
help::pkg.dish.dish.objs.dish.m.plotxy.a.newplot.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.plotxy.s := 'plotxy(xarray, yarray, newplot)';
help::pkg.dish.dish.objs.dish.m.plus := [=];
help::pkg.dish.dish.objs.dish.m.plus.d := 'Add offscan1 to globalscan1.';
help::pkg.dish.dish.objs.dish.m.plus.s := 'plus()';
help::pkg.dish.dish.objs.dish.m.qscan := [=];
help::pkg.dish.dish.objs.dish.m.qscan.d := 'Query characteristics of scan.';
help::pkg.dish.dish.objs.dish.m.qscan.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.qscan.a.scan.d := 'scan number';
help::pkg.dish.dish.objs.dish.m.qscan.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.qscan.a.scan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.qscan.s := 'qscan(scan)';
help::pkg.dish.dish.objs.dish.m.reference := [=];
help::pkg.dish.dish.objs.dish.m.reference.d := 'Designate the reference spectrum';
help::pkg.dish.dish.objs.dish.m.reference.s := 'reference()';
help::pkg.dish.dish.objs.dish.m.restore := [=];
help::pkg.dish.dish.objs.dish.m.restore.d := 'Retrieve the contents of the uni Record from disk.';
help::pkg.dish.dish.objs.dish.m.restore.s := 'restore()';
help::pkg.dish.dish.objs.dish.m.restorestate := [=];
help::pkg.dish.dish.objs.dish.m.restorestate.d := 'Restore the state of DISH s GUIs.';
help::pkg.dish.dish.objs.dish.m.restorestate.s := 'restorestate()';
help::pkg.dish.dish.objs.dish.m.rmadd := [=];
help::pkg.dish.dish.objs.dish.m.rmadd.d := 'Add an SDRecord to the results manager.';
help::pkg.dish.dish.objs.dish.m.rmadd.a.scanrec := [=];
help::pkg.dish.dish.objs.dish.m.rmadd.a.scanrec.d := 'an SDRecord';
help::pkg.dish.dish.objs.dish.m.rmadd.a.scanrec.def := 'globalscan1';
help::pkg.dish.dish.objs.dish.m.rmadd.a.scanrec.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.rmadd.a.name := [=];
help::pkg.dish.dish.objs.dish.m.rmadd.a.name.d := 'the name of the SDRecord in the Results Manager';
help::pkg.dish.dish.objs.dish.m.rmadd.a.name.def := 'auto-generated name';
help::pkg.dish.dish.objs.dish.m.rmadd.a.name.a := 'string';
help::pkg.dish.dish.objs.dish.m.rmadd.a.desc := [=];
help::pkg.dish.dish.objs.dish.m.rmadd.a.desc.d := 'the description of the SDRecord';
help::pkg.dish.dish.objs.dish.m.rmadd.a.desc.def := 'none';
help::pkg.dish.dish.objs.dish.m.rmadd.a.desc.a := 'string';
help::pkg.dish.dish.objs.dish.m.rmadd.s := 'rmadd(scanrec, name, desc)';
help::pkg.dish.dish.objs.dish.m.rms := [=];
help::pkg.dish.dish.objs.dish.m.rms.d := 'Display statistics on baseline regions.';
help::pkg.dish.dish.objs.dish.m.rms.s := 'rms()';
help::pkg.dish.dish.objs.dish.m.saxis := [=];
help::pkg.dish.dish.objs.dish.m.saxis.d := 'Set the units of the x axis in the plotter';
help::pkg.dish.dish.objs.dish.m.saxis.a.strval := [=];
help::pkg.dish.dish.objs.dish.m.saxis.a.strval.d := 'units to be displayed';
help::pkg.dish.dish.objs.dish.m.saxis.a.strval.def := 'none';
help::pkg.dish.dish.objs.dish.m.saxis.a.strval.a := 'GHz, MHz, kHz, Hz, km/s, m/s, pix,index';
help::pkg.dish.dish.objs.dish.m.saxis.s := 'saxis(strval)';
help::pkg.dish.dish.objs.dish.m.save := [=];
help::pkg.dish.dish.objs.dish.m.save.d := 'Save an SDRecord to file.';
help::pkg.dish.dish.objs.dish.m.save.a.sdrec := [=];
help::pkg.dish.dish.objs.dish.m.save.a.sdrec.d := 'SDRecord to be saved';
help::pkg.dish.dish.objs.dish.m.save.a.sdrec.def := 'currently viewed';
help::pkg.dish.dish.objs.dish.m.save.a.sdrec.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.save.a.outfile := [=];
help::pkg.dish.dish.objs.dish.m.save.a.outfile.d := 'outfile (scan group) to be written to';
help::pkg.dish.dish.objs.dish.m.save.a.outfile.def := 'fileout, as listed by d.files()';
help::pkg.dish.dish.objs.dish.m.save.a.outfile.a := 'string';
help::pkg.dish.dish.objs.dish.m.save.s := 'save(sdrec, outfile)';
help::pkg.dish.dish.objs.dish.m.savestate := [=];
help::pkg.dish.dish.objs.dish.m.savestate.d := 'Save the current state of DISH.';
help::pkg.dish.dish.objs.dish.m.savestate.s := 'savestate()';
help::pkg.dish.dish.objs.dish.m.scale := [=];
help::pkg.dish.dish.objs.dish.m.scale.d := 'Multiply the globalscan1 spectrum by a value.';
help::pkg.dish.dish.objs.dish.m.scale.a.factor := [=];
help::pkg.dish.dish.objs.dish.m.scale.a.factor.d := 'value to scale (multiply) by';
help::pkg.dish.dish.objs.dish.m.scale.a.factor.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scale.a.factor.a := 'float';
help::pkg.dish.dish.objs.dish.m.scale.s := 'scale(factor)';
help::pkg.dish.dish.objs.dish.m.scanadd := [=];
help::pkg.dish.dish.objs.dish.m.scanadd.d := 'Add scan1 and scan2.';
help::pkg.dish.dish.objs.dish.m.scanadd.a.scan1 := [=];
help::pkg.dish.dish.objs.dish.m.scanadd.a.scan1.d := 'first scan';
help::pkg.dish.dish.objs.dish.m.scanadd.a.scan1.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scanadd.a.scan1.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scanadd.a.scan2 := [=];
help::pkg.dish.dish.objs.dish.m.scanadd.a.scan2.d := 'second scan';
help::pkg.dish.dish.objs.dish.m.scanadd.a.scan2.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scanadd.a.scan2.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scanadd.s := 'scanadd(scan1, scan2)';
help::pkg.dish.dish.objs.dish.m.scanbias := [=];
help::pkg.dish.dish.objs.dish.m.scanbias.d := 'Adds a bias level to a scan.';
help::pkg.dish.dish.objs.dish.m.scanbias.a.scan := [=];
help::pkg.dish.dish.objs.dish.m.scanbias.a.scan.d := 'scan';
help::pkg.dish.dish.objs.dish.m.scanbias.a.scan.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scanbias.a.scan.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scanbias.a.offset := [=];
help::pkg.dish.dish.objs.dish.m.scanbias.a.offset.d := 'bias level to add';
help::pkg.dish.dish.objs.dish.m.scanbias.a.offset.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scanbias.a.offset.a := 'float or array of floats';
help::pkg.dish.dish.objs.dish.m.scanbias.s := 'scanbias(scan, offset)';
help::pkg.dish.dish.objs.dish.m.scandiv := [=];
help::pkg.dish.dish.objs.dish.m.scandiv.d := 'Divide scan 1 by scan 2.';
help::pkg.dish.dish.objs.dish.m.scandiv.a.scan1 := [=];
help::pkg.dish.dish.objs.dish.m.scandiv.a.scan1.d := 'numerator';
help::pkg.dish.dish.objs.dish.m.scandiv.a.scan1.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scandiv.a.scan1.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scandiv.a.scan2 := [=];
help::pkg.dish.dish.objs.dish.m.scandiv.a.scan2.d := 'denominator';
help::pkg.dish.dish.objs.dish.m.scandiv.a.scan2.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scandiv.a.scan2.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scandiv.s := 'scandiv(scan1, scan2)';
help::pkg.dish.dish.objs.dish.m.scanmult := [=];
help::pkg.dish.dish.objs.dish.m.scanmult.d := 'Multiply scan 1 by scan 2.';
help::pkg.dish.dish.objs.dish.m.scanmult.a.scan1 := [=];
help::pkg.dish.dish.objs.dish.m.scanmult.a.scan1.d := 'numerator';
help::pkg.dish.dish.objs.dish.m.scanmult.a.scan1.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scanmult.a.scan1.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scanmult.a.scan2 := [=];
help::pkg.dish.dish.objs.dish.m.scanmult.a.scan2.d := 'denominator';
help::pkg.dish.dish.objs.dish.m.scanmult.a.scan2.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scanmult.a.scan2.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scanmult.s := 'scanmult(scan1, scan2)';
help::pkg.dish.dish.objs.dish.m.scanscale := [=];
help::pkg.dish.dish.objs.dish.m.scanscale.d := 'Multiply an sdrecord s spectrum by a value or array';
help::pkg.dish.dish.objs.dish.m.scanscale.a.scan1 := [=];
help::pkg.dish.dish.objs.dish.m.scanscale.a.scan1.d := 'SDRecord to be scaled';
help::pkg.dish.dish.objs.dish.m.scanscale.a.scan1.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scanscale.a.scan1.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scanscale.a.sfactor := [=];
help::pkg.dish.dish.objs.dish.m.scanscale.a.sfactor.d := 'multiplicative factor';
help::pkg.dish.dish.objs.dish.m.scanscale.a.sfactor.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scanscale.a.sfactor.a := 'float or array of floats';
help::pkg.dish.dish.objs.dish.m.scanscale.s := 'scanscale(scan1, sfactor)';
help::pkg.dish.dish.objs.dish.m.scansrr := [=];
help::pkg.dish.dish.objs.dish.m.scansrr.d := 'Performs a (signal-reference)/reference.';
help::pkg.dish.dish.objs.dish.m.scansrr.a.scan1 := [=];
help::pkg.dish.dish.objs.dish.m.scansrr.a.scan1.d := 'signal scan';
help::pkg.dish.dish.objs.dish.m.scansrr.a.scan1.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scansrr.a.scan1.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scansrr.a.scan2 := [=];
help::pkg.dish.dish.objs.dish.m.scansrr.a.scan2.d := 'reference scan';
help::pkg.dish.dish.objs.dish.m.scansrr.a.scan2.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scansrr.a.scan2.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scansrr.s := 'scansrr(scan1, scan2)';
help::pkg.dish.dish.objs.dish.m.scansub := [=];
help::pkg.dish.dish.objs.dish.m.scansub.d := 'Subtract scan2 from scan1.';
help::pkg.dish.dish.objs.dish.m.scansub.a.scan1 := [=];
help::pkg.dish.dish.objs.dish.m.scansub.a.scan1.d := 'scan to be subtracted from';
help::pkg.dish.dish.objs.dish.m.scansub.a.scan1.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scansub.a.scan1.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scansub.a.scan2 := [=];
help::pkg.dish.dish.objs.dish.m.scansub.a.scan2.d := 'scan to subtract';
help::pkg.dish.dish.objs.dish.m.scansub.a.scan2.def := 'no default';
help::pkg.dish.dish.objs.dish.m.scansub.a.scan2.a := 'SDRecord';
help::pkg.dish.dish.objs.dish.m.scansub.s := 'scansub(scan1, scan2)';
help::pkg.dish.dish.objs.dish.m.sclear := [=];
help::pkg.dish.dish.objs.dish.m.sclear.d := 'Clear the contents of the accumulator.';
help::pkg.dish.dish.objs.dish.m.sclear.s := 'sclear()';
help::pkg.dish.dish.objs.dish.m.select := [=];
help::pkg.dish.dish.objs.dish.m.select.d := 'Select a subset of a scangroup.';
help::pkg.dish.dish.objs.dish.m.select.a.scans := [=];
help::pkg.dish.dish.objs.dish.m.select.a.scans.d := 'scan numbers';
help::pkg.dish.dish.objs.dish.m.select.a.scans.def := 'all';
help::pkg.dish.dish.objs.dish.m.select.a.scans.a := 'string - e.g., \' [4,7,9]\' ';
help::pkg.dish.dish.objs.dish.m.select.a.rows := [=];
help::pkg.dish.dish.objs.dish.m.select.a.rows.d := 'row numbers in the MS';
help::pkg.dish.dish.objs.dish.m.select.a.rows.def := 'all';
help::pkg.dish.dish.objs.dish.m.select.a.rows.a := 'string - e.g., \' [4:8],10\' ';
help::pkg.dish.dish.objs.dish.m.select.a.source := [=];
help::pkg.dish.dish.objs.dish.m.select.a.source.d := 'source names';
help::pkg.dish.dish.objs.dish.m.select.a.source.def := 'all';
help::pkg.dish.dish.objs.dish.m.select.a.source.a := 'string';
help::pkg.dish.dish.objs.dish.m.select.a.restfrequency := [=];
help::pkg.dish.dish.objs.dish.m.select.a.restfrequency.d := 'the restfrequency';
help::pkg.dish.dish.objs.dish.m.select.a.restfrequency.def := 'all';
help::pkg.dish.dish.objs.dish.m.select.a.restfrequency.a := 'vector of doubles';
help::pkg.dish.dish.objs.dish.m.select.a.date := [=];
help::pkg.dish.dish.objs.dish.m.select.a.date.d := 'date of the observation';
help::pkg.dish.dish.objs.dish.m.select.a.date.def := 'all';
help::pkg.dish.dish.objs.dish.m.select.a.date.a := 'string';
help::pkg.dish.dish.objs.dish.m.select.a.ut := [=];
help::pkg.dish.dish.objs.dish.m.select.a.ut.d := 'seconds of UT time since the observations started';
help::pkg.dish.dish.objs.dish.m.select.a.ut.def := 'all';
help::pkg.dish.dish.objs.dish.m.select.a.ut.a := 'vector of floats';
help::pkg.dish.dish.objs.dish.m.select.s := 'select(scans, rows, source, restfrequency, date, ut)';
help::pkg.dish.dish.objs.dish.m.setregion := [=];
help::pkg.dish.dish.objs.dish.m.setregion.d := 'Set the channel range for use in baseline subtraction';
help::pkg.dish.dish.objs.dish.m.setregion.s := 'setregion()';
help::pkg.dish.dish.objs.dish.m.setYUnit := [=];
help::pkg.dish.dish.objs.dish.m.setYUnit.d := 'Set the y-axis unit for a spectrum';
help::pkg.dish.dish.objs.dish.m.setYUnit.a.unit := [=];
help::pkg.dish.dish.objs.dish.m.setYUnit.a.unit.d := 'The units';
help::pkg.dish.dish.objs.dish.m.setYUnit.a.unit.def := 'no default';
help::pkg.dish.dish.objs.dish.m.setYUnit.a.unit.a := 'string';
help::pkg.dish.dish.objs.dish.m.setYUnit.s := 'setYUnit(unit)';
help::pkg.dish.dish.objs.dish.m.show := [=];
help::pkg.dish.dish.objs.dish.m.show.d := 'Display the globalscan1 SDRecord';
help::pkg.dish.dish.objs.dish.m.show.s := 'show()';
help::pkg.dish.dish.objs.dish.m.show1 := [=];
help::pkg.dish.dish.objs.dish.m.show1.d := 'Display one polarization of the globalscan1 SDRecord';
help::pkg.dish.dish.objs.dish.m.show1.a.ifeed := [=];
help::pkg.dish.dish.objs.dish.m.show1.a.ifeed.d := 'numeric designation for polarization';
help::pkg.dish.dish.objs.dish.m.show1.a.ifeed.def := 'integer';
help::pkg.dish.dish.objs.dish.m.show1.a.ifeed.a := 'no default';
help::pkg.dish.dish.objs.dish.m.show1.s := 'show1(ifeed)';
help::pkg.dish.dish.objs.dish.m.showref := [=];
help::pkg.dish.dish.objs.dish.m.showref.d := 'Display the vref SDRecord';
help::pkg.dish.dish.objs.dish.m.showref.s := 'showref()';
help::pkg.dish.dish.objs.dish.m.signal := [=];
help::pkg.dish.dish.objs.dish.m.signal.d := 'Designate the signal spectrum';
help::pkg.dish.dish.objs.dish.m.signal.s := 'signal()';
help::pkg.dish.dish.objs.dish.m.smooth := [=];
help::pkg.dish.dish.objs.dish.m.smooth.d := 'Smooth (hanning, boxcar or gaussian) an SDRecord.';
help::pkg.dish.dish.objs.dish.m.smooth.a.scanrec := [=];
help::pkg.dish.dish.objs.dish.m.smooth.a.scanrec.d := 'an SDRecord';
help::pkg.dish.dish.objs.dish.m.smooth.a.scanrec.def := 'currently displayed';
help::pkg.dish.dish.objs.dish.m.smooth.a.scanrec.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.smooth.a.type := [=];
help::pkg.dish.dish.objs.dish.m.smooth.a.type.d := 'type of smoothing function to be applied';
help::pkg.dish.dish.objs.dish.m.smooth.a.type.def := 'HANNING';
help::pkg.dish.dish.objs.dish.m.smooth.a.type.a := '\' HANNING\' , \' BOXCAR\' , or \' GAUSSIAN\' ';
help::pkg.dish.dish.objs.dish.m.smooth.a.width := [=];
help::pkg.dish.dish.objs.dish.m.smooth.a.width.d := 'width of the boxcar or gaussian';
help::pkg.dish.dish.objs.dish.m.smooth.a.width.def := '3';
help::pkg.dish.dish.objs.dish.m.smooth.a.width.a := 'float';
help::pkg.dish.dish.objs.dish.m.smooth.a.units := [=];
help::pkg.dish.dish.objs.dish.m.smooth.a.units.d := 'units for the width';
help::pkg.dish.dish.objs.dish.m.smooth.a.units.def := '\' channels\'  or \' native\' --only relevant for GAUSSIAN';
help::pkg.dish.dish.objs.dish.m.smooth.a.units.a := 'string';
help::pkg.dish.dish.objs.dish.m.smooth.a.decimate := [=];
help::pkg.dish.dish.objs.dish.m.smooth.a.decimate.d := 'decimate when smoothing (for HANNING)';
help::pkg.dish.dish.objs.dish.m.smooth.a.decimate.def := 'F';
help::pkg.dish.dish.objs.dish.m.smooth.a.decimate.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.smooth.s := 'smooth(scanrec, type, width, units, decimate)';
help::pkg.dish.dish.objs.dish.m.stat := [=];
help::pkg.dish.dish.objs.dish.m.stat.d := 'Generate statistics over a line region.';
help::pkg.dish.dish.objs.dish.m.stat.a.scanrec := [=];
help::pkg.dish.dish.objs.dish.m.stat.a.scanrec.d := 'an SDRecord';
help::pkg.dish.dish.objs.dish.m.stat.a.scanrec.def := 'currently displayed';
help::pkg.dish.dish.objs.dish.m.stat.a.scanrec.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.stat.a.range := [=];
help::pkg.dish.dish.objs.dish.m.stat.a.range.d := 'the range over which the statistics will be generated';
help::pkg.dish.dish.objs.dish.m.stat.a.range.def := 'no default';
help::pkg.dish.dish.objs.dish.m.stat.a.range.a := 'string';
help::pkg.dish.dish.objs.dish.m.stat.a.units := [=];
help::pkg.dish.dish.objs.dish.m.stat.a.units.d := 'the units used for the range';
help::pkg.dish.dish.objs.dish.m.stat.a.units.def := '\' channels\' ';
help::pkg.dish.dish.objs.dish.m.stat.a.units.a := 'string';
help::pkg.dish.dish.objs.dish.m.stat.s := 'stat(scanrec, range, units)';
help::pkg.dish.dish.objs.dish.m.statefile := [=];
help::pkg.dish.dish.objs.dish.m.statefile.d := 'Changes file for state saving.';
help::pkg.dish.dish.objs.dish.m.statefile.s := 'statefile()';
help::pkg.dish.dish.objs.dish.m.stats := [=];
help::pkg.dish.dish.objs.dish.m.stats.d := 'Generate statistics over a region.';
help::pkg.dish.dish.objs.dish.m.stats.a.quiet := [=];
help::pkg.dish.dish.objs.dish.m.stats.a.quiet.d := 'Suppress write of information to screen';
help::pkg.dish.dish.objs.dish.m.stats.a.quiet.def := 'F';
help::pkg.dish.dish.objs.dish.m.stats.a.quiet.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.stats.a.feed := [=];
help::pkg.dish.dish.objs.dish.m.stats.a.feed.d := 'Limit information to a single polarization';
help::pkg.dish.dish.objs.dish.m.stats.a.feed.def := 'all';
help::pkg.dish.dish.objs.dish.m.stats.a.feed.a := 'integer';
help::pkg.dish.dish.objs.dish.m.stats.a.bchan := [=];
help::pkg.dish.dish.objs.dish.m.stats.a.bchan.d := 'Beginning channel to calculate statistics';
help::pkg.dish.dish.objs.dish.m.stats.a.bchan.def := '1';
help::pkg.dish.dish.objs.dish.m.stats.a.bchan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.stats.a.echan := [=];
help::pkg.dish.dish.objs.dish.m.stats.a.echan.d := 'End channel for statistics';
help::pkg.dish.dish.objs.dish.m.stats.a.echan.def := 'last';
help::pkg.dish.dish.objs.dish.m.stats.a.echan.a := 'integer';
help::pkg.dish.dish.objs.dish.m.stats.s := 'stats(quiet, feed, bchan, echan)';
help::pkg.dish.dish.objs.dish.m.store := [=];
help::pkg.dish.dish.objs.dish.m.store.d := 'Store the contents of the uni Record to disk.';
help::pkg.dish.dish.objs.dish.m.store.s := 'store()';
help::pkg.dish.dish.objs.dish.m.summary := [=];
help::pkg.dish.dish.objs.dish.m.summary.d := 'List a summary for a Measurement Set';
help::pkg.dish.dish.objs.dish.m.summary.s := 'summary()';
help::pkg.dish.dish.objs.dish.m.tellstack := [=];
help::pkg.dish.dish.objs.dish.m.tellstack.d := 'Return contents of the stack.';
help::pkg.dish.dish.objs.dish.m.tellstack.s := 'tellstack()';
help::pkg.dish.dish.objs.dish.m.upr := [=];
help::pkg.dish.dish.objs.dish.m.upr.d := 'Print the current value of variables in the uni-record.';
help::pkg.dish.dish.objs.dish.m.upr.a.dots := [=];
help::pkg.dish.dish.objs.dish.m.upr.a.dots.d := 'list of variables';
help::pkg.dish.dish.objs.dish.m.upr.a.dots.def := 'all';
help::pkg.dish.dish.objs.dish.m.upr.a.dots.a := 'strings';
help::pkg.dish.dish.objs.dish.m.upr.s := 'upr(...)';
help::pkg.dish.dish.objs.dish.m.utable := [=];
help::pkg.dish.dish.objs.dish.m.utable.d := 'Print channel and data columns to command window';
help::pkg.dish.dish.objs.dish.m.utable.s := 'utable()';
help::pkg.dish.dish.objs.dish.m.writetofile := [=];
help::pkg.dish.dish.objs.dish.m.writetofile.d := 'Write X,Y axes to an ascii file on disk.';
help::pkg.dish.dish.objs.dish.m.writetofile.a.outfile := [=];
help::pkg.dish.dish.objs.dish.m.writetofile.a.outfile.d := 'the name of the file on disk where the data will be written';
help::pkg.dish.dish.objs.dish.m.writetofile.a.outfile.def := ' no default';
help::pkg.dish.dish.objs.dish.m.writetofile.a.outfile.a := 'string';
help::pkg.dish.dish.objs.dish.m.writetofile.a.scanrec := [=];
help::pkg.dish.dish.objs.dish.m.writetofile.a.scanrec.d := 'an SDRecord';
help::pkg.dish.dish.objs.dish.m.writetofile.a.scanrec.def := 'currently displayed';
help::pkg.dish.dish.objs.dish.m.writetofile.a.scanrec.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.writetofile.s := 'writetofile(outfile, scanrec)';
help::pkg.dish.dish.objs.dish.m.zline := [=];
help::pkg.dish.dish.objs.dish.m.zline.d := 'Draw a horizontal line at zero intensity on the plotter.';
help::pkg.dish.dish.objs.dish.m.zline.a.torF := [=];
help::pkg.dish.dish.objs.dish.m.zline.a.torF.d := 'T indicates draw the line';
help::pkg.dish.dish.objs.dish.m.zline.a.torF.def := 'no default';
help::pkg.dish.dish.objs.dish.m.zline.a.torF.a := 'boolean';
help::pkg.dish.dish.objs.dish.m.zline.s := 'zline(torF)';
help::pkg.dish.dish.objs.dishd := [=];
help::pkg.dish.dish.objs.dishd.m := [=];
help::pkg.dish.dish.objs.dishd.c := [=];
help::pkg.dish.dish.objs.dishd.d := 'dish tool (developer functions)';
help::pkg.dish.dish.objs.dishd.m.addop := [=];
help::pkg.dish.dish.objs.dishd.m.addop.d := 'Add new operation to DISH tool';
help::pkg.dish.dish.objs.dishd.m.addop.s := 'addop()';
help::pkg.dish.dish.objs.dishd.m.dologging := [=];
help::pkg.dish.dish.objs.dishd.m.dologging.d := 'Switch to determine whether commands from the GUI are logged to the scripter';
help::pkg.dish.dish.objs.dishd.m.dologging.s := 'dologging()';
help::pkg.dish.dish.objs.dishd.m.doselect := [=];
help::pkg.dish.dish.objs.dishd.m.doselect.d := 'Toggle selection between last plotted and RM  selection';
help::pkg.dish.dish.objs.dishd.m.doselect.s := 'doselect()';
help::pkg.dish.dish.objs.dishd.m.history := [=];
help::pkg.dish.dish.objs.dishd.m.history.d := 'Writes message to history of SDRecord.';
help::pkg.dish.dish.objs.dishd.m.history.s := 'history()';
help::pkg.dish.dish.objs.dishd.m.logcommand := [=];
help::pkg.dish.dish.objs.dishd.m.logcommand.d := 'Writes command to scripter.';
help::pkg.dish.dish.objs.dishd.m.logcommand.s := 'logcommand()';
help::pkg.dish.dish.objs.dishd.m.message := [=];
help::pkg.dish.dish.objs.dishd.m.message.d := 'Writes a command to the DISH GUI message entry.';
help::pkg.dish.dish.objs.dishd.m.message.s := 'message()';
help::pkg.dish.dish.objs.dishd.m.type := [=];
help::pkg.dish.dish.objs.dishd.m.type.d := 'Returns the type of the DISH tool.';
help::pkg.dish.dish.objs.dishd.m.type.s := 'type()';
help::pkg.dish.dish.objs.msr := [=];
help::pkg.dish.dish.objs.msr.m := [=];
help::pkg.dish.dish.objs.msr.c := [=];
help::pkg.dish.dish.objs.msr.d := 'dish spectral line measure tool';
help::pkg.dish.dish.objs.msr.m.areape := [=];
help::pkg.dish.dish.objs.msr.m.areape.d := 'Derives profile characteristic values.';
help::pkg.dish.dish.objs.msr.m.areape.a.lv := [=];
help::pkg.dish.dish.objs.msr.m.areape.a.lv.d := 'an SDRecord';
help::pkg.dish.dish.objs.msr.m.areape.a.lv.def := 'F';
help::pkg.dish.dish.objs.msr.m.areape.a.lv.a := 'SDRecord - Not enabled';
help::pkg.dish.dish.objs.msr.m.areape.a.first := [=];
help::pkg.dish.dish.objs.msr.m.areape.a.first.d := 'first channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.areape.a.first.def := 'F';
help::pkg.dish.dish.objs.msr.m.areape.a.first.a := 'integer';
help::pkg.dish.dish.objs.msr.m.areape.a.last := [=];
help::pkg.dish.dish.objs.msr.m.areape.a.last.d := 'last channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.areape.a.last.def := 'F';
help::pkg.dish.dish.objs.msr.m.areape.a.last.a := 'integer';
help::pkg.dish.dish.objs.msr.m.areape.a.levs := [=];
help::pkg.dish.dish.objs.msr.m.areape.a.levs.d := 'define levels relative to each peak flux';
help::pkg.dish.dish.objs.msr.m.areape.a.levs.def := '[0.8,0.2,0.4]';
help::pkg.dish.dish.objs.msr.m.areape.a.levs.a := 'vector';
help::pkg.dish.dish.objs.msr.m.areape.a.rms := [=];
help::pkg.dish.dish.objs.msr.m.areape.a.rms.d := 'rms of the spectrum (non-line)';
help::pkg.dish.dish.objs.msr.m.areape.a.rms.def := '0.0';
help::pkg.dish.dish.objs.msr.m.areape.a.rms.a := 'float';
help::pkg.dish.dish.objs.msr.m.areape.a.usecurs := [=];
help::pkg.dish.dish.objs.msr.m.areape.a.usecurs.d := 'optionally set ranges with cursor';
help::pkg.dish.dish.objs.msr.m.areape.a.usecurs.def := 'F';
help::pkg.dish.dish.objs.msr.m.areape.a.usecurs.a := 'boolean';
help::pkg.dish.dish.objs.msr.m.areape.a.norder := [=];
help::pkg.dish.dish.objs.msr.m.areape.a.norder.d := 'order of the fit';
help::pkg.dish.dish.objs.msr.m.areape.a.norder.def := '1';
help::pkg.dish.dish.objs.msr.m.areape.a.norder.a := 'integer';
help::pkg.dish.dish.objs.msr.m.areape.s := 'areape(lv, first, last, levs, rms, usecurs, norder)';
help::pkg.dish.dish.objs.msr.m.areapf := [=];
help::pkg.dish.dish.objs.msr.m.areapf.d := 'Derives profile characteristic values.';
help::pkg.dish.dish.objs.msr.m.areapf.a.lv := [=];
help::pkg.dish.dish.objs.msr.m.areapf.a.lv.d := 'an SDRecord';
help::pkg.dish.dish.objs.msr.m.areapf.a.lv.def := 'F';
help::pkg.dish.dish.objs.msr.m.areapf.a.lv.a := 'SDRecord - Not enabled';
help::pkg.dish.dish.objs.msr.m.areapf.a.first := [=];
help::pkg.dish.dish.objs.msr.m.areapf.a.first.d := 'first channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.areapf.a.first.def := 'F';
help::pkg.dish.dish.objs.msr.m.areapf.a.first.a := 'integer';
help::pkg.dish.dish.objs.msr.m.areapf.a.last := [=];
help::pkg.dish.dish.objs.msr.m.areapf.a.last.d := 'last channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.areapf.a.last.def := 'F';
help::pkg.dish.dish.objs.msr.m.areapf.a.last.a := 'integer';
help::pkg.dish.dish.objs.msr.m.areapf.a.levs := [=];
help::pkg.dish.dish.objs.msr.m.areapf.a.levs.d := 'define levels relative to each peak flux';
help::pkg.dish.dish.objs.msr.m.areapf.a.levs.def := '[0.8,0.2,0.4]';
help::pkg.dish.dish.objs.msr.m.areapf.a.levs.a := 'vector';
help::pkg.dish.dish.objs.msr.m.areapf.a.rms := [=];
help::pkg.dish.dish.objs.msr.m.areapf.a.rms.d := 'rms of the spectrum (non-line)';
help::pkg.dish.dish.objs.msr.m.areapf.a.rms.def := '0.0';
help::pkg.dish.dish.objs.msr.m.areapf.a.rms.a := 'float';
help::pkg.dish.dish.objs.msr.m.areapf.a.usecurs := [=];
help::pkg.dish.dish.objs.msr.m.areapf.a.usecurs.d := 'optionally set ranges with cursor';
help::pkg.dish.dish.objs.msr.m.areapf.a.usecurs.def := 'F';
help::pkg.dish.dish.objs.msr.m.areapf.a.usecurs.a := 'boolean';
help::pkg.dish.dish.objs.msr.m.areapf.a.norder := [=];
help::pkg.dish.dish.objs.msr.m.areapf.a.norder.d := 'order of the fit';
help::pkg.dish.dish.objs.msr.m.areapf.a.norder.def := '1';
help::pkg.dish.dish.objs.msr.m.areapf.a.norder.a := 'integer';
help::pkg.dish.dish.objs.msr.m.areapf.s := 'areapf(lv, first, last, levs, rms, usecurs, norder)';
help::pkg.dish.dish.objs.msr.m.mean := [=];
help::pkg.dish.dish.objs.msr.m.mean.d := 'Derives characteristic values based on the mean.';
help::pkg.dish.dish.objs.msr.m.mean.a.lv := [=];
help::pkg.dish.dish.objs.msr.m.mean.a.lv.d := 'an SDRecord';
help::pkg.dish.dish.objs.msr.m.mean.a.lv.def := 'F';
help::pkg.dish.dish.objs.msr.m.mean.a.lv.a := 'SDRecord - Not enabled';
help::pkg.dish.dish.objs.msr.m.mean.a.first := [=];
help::pkg.dish.dish.objs.msr.m.mean.a.first.d := 'first channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.mean.a.first.def := 'F';
help::pkg.dish.dish.objs.msr.m.mean.a.first.a := 'integer';
help::pkg.dish.dish.objs.msr.m.mean.a.last := [=];
help::pkg.dish.dish.objs.msr.m.mean.a.last.d := 'last channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.mean.a.last.def := 'F';
help::pkg.dish.dish.objs.msr.m.mean.a.last.a := 'integer';
help::pkg.dish.dish.objs.msr.m.mean.a.flevel := [=];
help::pkg.dish.dish.objs.msr.m.mean.a.flevel.d := 'fractional flux level';
help::pkg.dish.dish.objs.msr.m.mean.a.flevel.def := '0.3';
help::pkg.dish.dish.objs.msr.m.mean.a.flevel.a := 'float';
help::pkg.dish.dish.objs.msr.m.mean.a.usecurs := [=];
help::pkg.dish.dish.objs.msr.m.mean.a.usecurs.d := 'optionally set ranges with cursor';
help::pkg.dish.dish.objs.msr.m.mean.a.usecurs.def := 'F';
help::pkg.dish.dish.objs.msr.m.mean.a.usecurs.a := 'boolean';
help::pkg.dish.dish.objs.msr.m.mean.s := 'mean(lv, first, last, flevel, usecurs)';
help::pkg.dish.dish.objs.msr.m.peak := [=];
help::pkg.dish.dish.objs.msr.m.peak.d := 'Derives characteristic values based on the peak.';
help::pkg.dish.dish.objs.msr.m.peak.a.lv := [=];
help::pkg.dish.dish.objs.msr.m.peak.a.lv.d := 'an SDRecord';
help::pkg.dish.dish.objs.msr.m.peak.a.lv.def := 'F';
help::pkg.dish.dish.objs.msr.m.peak.a.lv.a := 'SDRecord - Not enabled';
help::pkg.dish.dish.objs.msr.m.peak.a.first := [=];
help::pkg.dish.dish.objs.msr.m.peak.a.first.d := 'first channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.peak.a.first.def := 'F';
help::pkg.dish.dish.objs.msr.m.peak.a.first.a := 'integer';
help::pkg.dish.dish.objs.msr.m.peak.a.last := [=];
help::pkg.dish.dish.objs.msr.m.peak.a.last.d := 'last channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.peak.a.last.def := 'F';
help::pkg.dish.dish.objs.msr.m.peak.a.last.a := 'integer';
help::pkg.dish.dish.objs.msr.m.peak.a.flevel := [=];
help::pkg.dish.dish.objs.msr.m.peak.a.flevel.d := 'fractional flux level';
help::pkg.dish.dish.objs.msr.m.peak.a.flevel.def := '0.3';
help::pkg.dish.dish.objs.msr.m.peak.a.flevel.a := 'float';
help::pkg.dish.dish.objs.msr.m.peak.a.rms := [=];
help::pkg.dish.dish.objs.msr.m.peak.a.rms.d := 'rms of spectrum';
help::pkg.dish.dish.objs.msr.m.peak.a.rms.def := '0.';
help::pkg.dish.dish.objs.msr.m.peak.a.rms.a := 'float';
help::pkg.dish.dish.objs.msr.m.peak.a.usecurs := [=];
help::pkg.dish.dish.objs.msr.m.peak.a.usecurs.d := 'optionally set ranges with cursor';
help::pkg.dish.dish.objs.msr.m.peak.a.usecurs.def := 'F';
help::pkg.dish.dish.objs.msr.m.peak.a.usecurs.a := 'boolean';
help::pkg.dish.dish.objs.msr.m.peak.s := 'peak(lv, first, last, flevel, rms, usecurs)';
help::pkg.dish.dish.objs.msr.m.twopeak := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.d := 'Derives characteristic values based on the peaks.';
help::pkg.dish.dish.objs.msr.m.twopeak.a.lv := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.a.lv.d := 'an SDRecord';
help::pkg.dish.dish.objs.msr.m.twopeak.a.lv.def := 'F';
help::pkg.dish.dish.objs.msr.m.twopeak.a.lv.a := 'SDRecord - Not enabled';
help::pkg.dish.dish.objs.msr.m.twopeak.a.first := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.a.first.d := 'first channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.twopeak.a.first.def := 'F';
help::pkg.dish.dish.objs.msr.m.twopeak.a.first.a := 'integer';
help::pkg.dish.dish.objs.msr.m.twopeak.a.last := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.a.last.d := 'last channel number in range to integrate';
help::pkg.dish.dish.objs.msr.m.twopeak.a.last.def := 'F';
help::pkg.dish.dish.objs.msr.m.twopeak.a.last.a := 'integer';
help::pkg.dish.dish.objs.msr.m.twopeak.a.peak1 := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.a.peak1.d := 'guess of first peak channel number';
help::pkg.dish.dish.objs.msr.m.twopeak.a.peak1.def := 'F';
help::pkg.dish.dish.objs.msr.m.twopeak.a.peak1.a := 'integer';
help::pkg.dish.dish.objs.msr.m.twopeak.a.peak2 := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.a.peak2.d := 'guess of second peak channel number';
help::pkg.dish.dish.objs.msr.m.twopeak.a.peak2.def := 'F';
help::pkg.dish.dish.objs.msr.m.twopeak.a.peak2.a := 'integer';
help::pkg.dish.dish.objs.msr.m.twopeak.a.flevel := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.a.flevel.d := 'fractional flux level';
help::pkg.dish.dish.objs.msr.m.twopeak.a.flevel.def := '0.3';
help::pkg.dish.dish.objs.msr.m.twopeak.a.flevel.a := 'float';
help::pkg.dish.dish.objs.msr.m.twopeak.a.rms := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.a.rms.d := 'rms of spectrum';
help::pkg.dish.dish.objs.msr.m.twopeak.a.rms.def := '0.';
help::pkg.dish.dish.objs.msr.m.twopeak.a.rms.a := 'float';
help::pkg.dish.dish.objs.msr.m.twopeak.a.usecurs := [=];
help::pkg.dish.dish.objs.msr.m.twopeak.a.usecurs.d := 'optionally set ranges with cursor';
help::pkg.dish.dish.objs.msr.m.twopeak.a.usecurs.def := 'F';
help::pkg.dish.dish.objs.msr.m.twopeak.a.usecurs.a := 'boolean';
help::pkg.dish.dish.objs.msr.m.twopeak.s := 'twopeak(lv, first, last, peak1, peak2, flevel, rms, usecurs)';
help::pkg.dish.dish.objs.plotter := [=];
help::pkg.dish.dish.objs.plotter.m := [=];
help::pkg.dish.dish.objs.plotter.c := [=];
help::pkg.dish.dish.objs.plotter.d := 'dish plotter tool';
help::pkg.dish.dish.objs.plotter.m.ips := [=];
help::pkg.dish.dish.objs.plotter.m.ips.d := 'Image profile support.';
help::pkg.dish.dish.objs.plotter.m.ips.s := 'ips()';
help::pkg.dish.dish.objs.plotter.m.plotrec := [=];
help::pkg.dish.dish.objs.plotter.m.plotrec.d := 'Plot an SDRecord.';
help::pkg.dish.dish.objs.plotter.m.plotrec.s := 'plotrec()';
help::pkg.dish.dish.objs.plotter.m.putranges := [=];
help::pkg.dish.dish.objs.plotter.m.putranges.d := 'This allows setting of range regions for use by future operations.';
help::pkg.dish.dish.objs.plotter.m.putranges.s := 'putranges()';
help::pkg.dish.dish.objs.plotter.m.ranges := [=];
help::pkg.dish.dish.objs.plotter.m.ranges.d := 'Retrieves any active ranges.';
help::pkg.dish.dish.objs.plotter.m.ranges.s := 'ranges()';
help::pkg.dish.dish.objs.rm := [=];
help::pkg.dish.dish.objs.rm.m := [=];
help::pkg.dish.dish.objs.rm.c := [=];
help::pkg.dish.dish.objs.rm.d := 'dish results manager';
help::pkg.dish.dish.objs.rm.m.add := [=];
help::pkg.dish.dish.objs.rm.m.add.d := 'Add an SDRecord to the Results Manager.';
help::pkg.dish.dish.objs.rm.m.add.s := 'add()';
help::pkg.dish.dish.objs.rm.m.copy := [=];
help::pkg.dish.dish.objs.rm.m.copy.d := 'Copies currently viewed to the clipboard.';
help::pkg.dish.dish.objs.rm.m.copy.s := 'copy()';
help::pkg.dish.dish.objs.rm.m.delete := [=];
help::pkg.dish.dish.objs.rm.m.delete.d := 'Deletes the Results Manager Variable with the specified index.';
help::pkg.dish.dish.objs.rm.m.delete.s := 'delete()';
help::pkg.dish.dish.objs.rm.m.done := [=];
help::pkg.dish.dish.objs.rm.m.done.d := 'Deletes and closes down the results manager tool (not recommended!).';
help::pkg.dish.dish.objs.rm.m.done.s := 'done()';
help::pkg.dish.dish.objs.rm.m.getdescriptions := [=];
help::pkg.dish.dish.objs.rm.m.getdescriptions.d := 'Gets descriptions from an index value in the results manager.';
help::pkg.dish.dish.objs.rm.m.getdescriptions.s := 'getdescriptions()';
help::pkg.dish.dish.objs.rm.m.getlastviewed := [=];
help::pkg.dish.dish.objs.rm.m.getlastviewed.d := 'Returns the SDRecord of the last viewed item in the plotter.';
help::pkg.dish.dish.objs.rm.m.getlastviewed.s := 'getlastviewed()';
help::pkg.dish.dish.objs.rm.m.getnames := [=];
help::pkg.dish.dish.objs.rm.m.getnames.d := 'Gets name from an index value in the results manager.';
help::pkg.dish.dish.objs.rm.m.getnames.s := 'getnames()';
help::pkg.dish.dish.objs.rm.m.getselectiondescriptions := [=];
help::pkg.dish.dish.objs.rm.m.getselectiondescriptions.d := 'Gets the descriptions of all selected items in the Results Manager.';
help::pkg.dish.dish.objs.rm.m.getselectiondescriptions.s := 'getselectiondescriptions()';
help::pkg.dish.dish.objs.rm.m.getselectionnames := [=];
help::pkg.dish.dish.objs.rm.m.getselectionnames.d := 'Gets the names of all selected items in the Results Manager.';
help::pkg.dish.dish.objs.rm.m.getselectionnames.s := 'getselectionnames()';
help::pkg.dish.dish.objs.rm.m.getselectionvalues := [=];
help::pkg.dish.dish.objs.rm.m.getselectionvalues.d := 'Gets the values of all selected items in the Results Manager.';
help::pkg.dish.dish.objs.rm.m.getselectionvalues.s := 'getselectionvalues()';
help::pkg.dish.dish.objs.rm.m.getvalues := [=];
help::pkg.dish.dish.objs.rm.m.getvalues.d := 'Returns values of selected in results manager.';
help::pkg.dish.dish.objs.rm.m.getvalues.s := 'getvalues()';
help::pkg.dish.dish.objs.rm.m.gui := [=];
help::pkg.dish.dish.objs.rm.m.gui.d := 'Opens the GUI for the results manager if it isn t already viewed.';
help::pkg.dish.dish.objs.rm.m.gui.s := 'gui()';
help::pkg.dish.dish.objs.rm.m.nogui := [=];
help::pkg.dish.dish.objs.rm.m.nogui.d := 'Specifies whether the GUI for the Results Manager should be viewed.';
help::pkg.dish.dish.objs.rm.m.nogui.s := 'nogui()';
help::pkg.dish.dish.objs.rm.m.paste := [=];
help::pkg.dish.dish.objs.rm.m.paste.d := 'Pastes from the clipboard into the results manager.';
help::pkg.dish.dish.objs.rm.m.paste.s := 'paste()';
help::pkg.dish.dish.objs.rm.m.rename := [=];
help::pkg.dish.dish.objs.rm.m.rename.d := 'Renames a selected Results Manager variable.';
help::pkg.dish.dish.objs.rm.m.rename.s := 'rename()';
help::pkg.dish.dish.objs.rm.m.select := [=];
help::pkg.dish.dish.objs.rm.m.select.d := 'Selects an item in the results manager.';
help::pkg.dish.dish.objs.rm.m.select.s := 'select()';
help::pkg.dish.dish.objs.rm.m.selectbyname := [=];
help::pkg.dish.dish.objs.rm.m.selectbyname.d := 'Selects an item in the results manager by name rather than by index number.';
help::pkg.dish.dish.objs.rm.m.selectbyname.s := 'selectbyname()';
help::pkg.dish.dish.objs.rm.m.selectionsize := [=];
help::pkg.dish.dish.objs.rm.m.selectionsize.d := 'Gives the number of items selected in the results manager.';
help::pkg.dish.dish.objs.rm.m.selectionsize.s := 'selectionsize()';
help::pkg.dish.dish.objs.rm.m.setdescription := [=];
help::pkg.dish.dish.objs.rm.m.setdescription.d := 'Sets description to a specified string.';
help::pkg.dish.dish.objs.rm.m.setdescription.s := 'setdescription()';
help::pkg.dish.dish.objs.rm.m.setlastviewed := [=];
help::pkg.dish.dish.objs.rm.m.setlastviewed.d := 'For a specified index value in the results manager, it will set this as the last viewed item.';
help::pkg.dish.dish.objs.rm.m.setlastviewed.s := 'setlastviewed()';
help::pkg.dish.dish.objs.rm.m.size := [=];
help::pkg.dish.dish.objs.rm.m.size.d := 'Gives the number of items in the results manager.';
help::pkg.dish.dish.objs.rm.m.size.s := 'size()';
help::pkg.dish.dish.objs.rm.m.wsname := [=];
help::pkg.dish.dish.objs.rm.m.wsname.d := 'Retrieves name of MS that will be used for any selections.';
help::pkg.dish.dish.objs.rm.m.wsname.s := 'wsname()';
help::pkg.dish.dish.funs.dishdemodata := [=];
help::pkg.dish.dish.funs.dishdemodata.a := [=];
help::pkg.dish.dish.funs.dishdemodata.d := 'Set up demonstration data for Dish';
help::pkg.dish.dish.funs.dishdemodata.s := 'dishdemodata()';
help::pkg.dish.dish.objs.sdaverager := [=];
help::pkg.dish.dish.objs.sdaverager.m := [=];
help::pkg.dish.dish.objs.sdaverager.c := [=];
help::pkg.dish.dish.objs.sdaverager.d := 'A tool for averaging single dish data';
help::pkg.dish.dish.objs.sdaverager.c.sdaverager := [=];
help::pkg.dish.dish.objs.sdaverager.c.sdaverager.d := 'An sdaverager';
help::pkg.dish.dish.objs.sdaverager.c.sdaverager.s := 'sdaverager()';
help::pkg.dish.dish.objs.sdaverager.m.clear := [=];
help::pkg.dish.dish.objs.sdaverager.m.clear.d := 'Clear the on-going average.';
help::pkg.dish.dish.objs.sdaverager.m.clear.s := 'clear()';
help::pkg.dish.dish.objs.sdaverager.m.setweighting := [=];
help::pkg.dish.dish.objs.sdaverager.m.setweighting.d := 'Set the weighting option.';
help::pkg.dish.dish.objs.sdaverager.m.setweighting.a.option := [=];
help::pkg.dish.dish.objs.sdaverager.m.setweighting.a.option.d := 'The weighting option';
help::pkg.dish.dish.objs.sdaverager.m.setweighting.a.option.def := '';
help::pkg.dish.dish.objs.sdaverager.m.setweighting.a.option.a := '\' NONE\' ,\' RMS\' ,\' SIGMA\' ';
help::pkg.dish.dish.objs.sdaverager.m.setweighting.s := 'setweighting(option)';
help::pkg.dish.dish.objs.sdaverager.m.getweighting := [=];
help::pkg.dish.dish.objs.sdaverager.m.getweighting.d := 'Return the current weighting option.';
help::pkg.dish.dish.objs.sdaverager.m.getweighting.s := 'getweighting()';
help::pkg.dish.dish.objs.sdaverager.m.setalignment := [=];
help::pkg.dish.dish.objs.sdaverager.m.setalignment.d := 'Set the alignment option.';
help::pkg.dish.dish.objs.sdaverager.m.setalignment.a.option := [=];
help::pkg.dish.dish.objs.sdaverager.m.setalignment.a.option.d := 'The alignment option';
help::pkg.dish.dish.objs.sdaverager.m.setalignment.a.option.def := '';
help::pkg.dish.dish.objs.sdaverager.m.setalignment.a.option.a := '\' NONE\' ,\' VELOCITY\' ';
help::pkg.dish.dish.objs.sdaverager.m.setalignment.s := 'setalignment(option)';
help::pkg.dish.dish.objs.sdaverager.m.getalignment := [=];
help::pkg.dish.dish.objs.sdaverager.m.getalignment.d := 'Return the current alignment option.';
help::pkg.dish.dish.objs.sdaverager.m.getalignment.s := 'getalignment()';
help::pkg.dish.dish.objs.sdaverager.m.dorestshift := [=];
help::pkg.dish.dish.objs.sdaverager.m.dorestshift.d := 'Do we align by rest frequency?';
help::pkg.dish.dish.objs.sdaverager.m.dorestshift.a.torf := [=];
help::pkg.dish.dish.objs.sdaverager.m.dorestshift.a.torf.d := 'Do we align by rest frequency?';
help::pkg.dish.dish.objs.sdaverager.m.dorestshift.a.torf.def := '';
help::pkg.dish.dish.objs.sdaverager.m.dorestshift.a.torf.a := 'boolean';
help::pkg.dish.dish.objs.sdaverager.m.dorestshift.s := 'dorestshift(torf)';
help::pkg.dish.dish.objs.sdaverager.m.restshiftstate := [=];
help::pkg.dish.dish.objs.sdaverager.m.restshiftstate.d := 'Are we aligning by rest frequency?';
help::pkg.dish.dish.objs.sdaverager.m.restshiftstate.s := 'restshiftstate()';
help::pkg.dish.dish.objs.sdaverager.m.accumulate := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.d := 'Add the data array to the internal accumulation.';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.data := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.data.d := 'The data array';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.data.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.data.a := 'Float matrix';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.tsys := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.tsys.d := 'The system temp';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.tsys.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.tsys.a := 'Float';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.crpix := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.crpix.d := 'X axis reference pixel';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.crpix.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.crpix.a := 'Double';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.crval := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.crval.d := 'X axis value at crpix';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.crval.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.crval.a := 'Double';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.cdelt := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.cdelt.d := 'X axis increment per pixel';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.cdelt.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.cdelt.a := 'Double';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.cunit := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.cunit.d := 'X axis units';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.cunit.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.cunit.a := 'string';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.ctype := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.ctype.d := 'Type of X axis';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.ctype.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.ctype.a := 'string';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.veldef := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.veldef.d := 'Velocity definition';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.veldef.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.veldef.a := 'string';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.restfrequency := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.restfrequency.d := 'The rest frequency';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.restfrequency.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.restfrequency.a := 'Double';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.exposure := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.exposure.d := 'The effective integration time';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.exposure.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.exposure.a := 'Float';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.duration := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.duration.d := 'The total integration time';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.duration.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.a.duration.a := 'Float';
help::pkg.dish.dish.objs.sdaverager.m.accumulate.s := 'accumulate(data, tsys, crpix, crval, cdelt, cunit, ctype, veldef, restfrequency, exposure, duration)';
help::pkg.dish.dish.objs.sdaverager.m.accumiterator := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumiterator.d := 'Add an entire iterator to the internal accumulation';
help::pkg.dish.dish.objs.sdaverager.m.accumiterator.a.sditerator := [=];
help::pkg.dish.dish.objs.sdaverager.m.accumiterator.a.sditerator.d := 'The sditerator to averager';
help::pkg.dish.dish.objs.sdaverager.m.accumiterator.a.sditerator.def := '';
help::pkg.dish.dish.objs.sdaverager.m.accumiterator.a.sditerator.a := 'sditerator';
help::pkg.dish.dish.objs.sdaverager.m.accumiterator.s := 'accumiterator(sditerator)';
help::pkg.dish.dish.objs.sdaverager.m.average := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.d := 'Get the current internal accumulation';
help::pkg.dish.dish.objs.sdaverager.m.average.a.data := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.data.d := 'The average data array';
help::pkg.dish.dish.objs.sdaverager.m.average.a.data.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.data.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.tsys := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.tsys.d := 'The average system temperature';
help::pkg.dish.dish.objs.sdaverager.m.average.a.tsys.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.tsys.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.crpix := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.crpix.d := 'X axis reference pixel of the average';
help::pkg.dish.dish.objs.sdaverager.m.average.a.crpix.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.crpix.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.crval := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.crval.d := 'X axis value at the reference pixel';
help::pkg.dish.dish.objs.sdaverager.m.average.a.crval.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.crval.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.cdelt := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.cdelt.d := 'X axis increment per pixel';
help::pkg.dish.dish.objs.sdaverager.m.average.a.cdelt.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.cdelt.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.cunit := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.cunit.d := 'X axis units';
help::pkg.dish.dish.objs.sdaverager.m.average.a.cunit.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.cunit.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.ctype := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.ctype.d := 'X axis type';
help::pkg.dish.dish.objs.sdaverager.m.average.a.ctype.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.ctype.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.veldef := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.veldef.d := 'Velocity definition';
help::pkg.dish.dish.objs.sdaverager.m.average.a.veldef.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.veldef.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.restfrequency := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.restfrequency.d := 'The rest frequency';
help::pkg.dish.dish.objs.sdaverager.m.average.a.restfrequency.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.restfrequency.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.exposure := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.exposure.d := 'The effective integration time';
help::pkg.dish.dish.objs.sdaverager.m.average.a.exposure.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.exposure.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.duration := [=];
help::pkg.dish.dish.objs.sdaverager.m.average.a.duration.d := 'The total integration time';
help::pkg.dish.dish.objs.sdaverager.m.average.a.duration.def := '';
help::pkg.dish.dish.objs.sdaverager.m.average.a.duration.a := '';
help::pkg.dish.dish.objs.sdaverager.m.average.s := 'average(data, tsys, crpix, crval, cdelt, cunit, ctype, veldef, restfrequency, exposure, duration)';
help::pkg.dish.dish.objs.sditerator := [=];
help::pkg.dish.dish.objs.sditerator.m := [=];
help::pkg.dish.dish.objs.sditerator.c := [=];
help::pkg.dish.dish.objs.sditerator.d := 'A \tool\ for interacting with single dish data.';
help::pkg.dish.dish.objs.sditerator.c.sditerator := [=];
help::pkg.dish.dish.objs.sditerator.c.sditerator.d := 'An sditerator from an existing file on disk.';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.filename := [=];
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.filename.d := 'Name of SDFITS file on disk';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.filename.def := '';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.filename.a := 'String';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.readonly := [=];
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.readonly.d := 'Open Read-only?';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.readonly.def := 'T';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.readonly.a := 'Bool';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.selection := [=];
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.selection.d := 'Record describing any selections to do on opening';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.selection.def := '[=]';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.selection.a := '\glish\  record';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.lockoptions := [=];
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.lockoptions.d := 'locking to be used';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.lockoptions.def := 'auto';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.lockoptions.a := 'String';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.correcteddata := [=];
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.correcteddata.d := 'Use the CORRECTED\_DATA column?';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.correcteddata.def := 'F';
help::pkg.dish.dish.objs.sditerator.c.sditerator.a.correcteddata.a := 'Bool';
help::pkg.dish.dish.objs.sditerator.c.sditerator.s := 'sditerator(filename, readonly, selection, lockoptions, correcteddata)';
help::pkg.dish.dish.objs.sditerator.c.newsditerator := [=];
help::pkg.dish.dish.objs.sditerator.c.newsditerator.d := 'Make a new, empty sditerator.';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.filename := [=];
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.filename.d := 'Name of new data set on disk.';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.filename.def := '';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.filename.a := 'String';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.type := [=];
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.type.d := 'The type of data set.';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.type.def := '\' Table\' ';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.type.a := 'String';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.lockoptions := [=];
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.lockoptions.d := 'locking to be used';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.lockoptions.def := 'auto';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.a.lockoptions.a := 'String';
help::pkg.dish.dish.objs.sditerator.c.newsditerator.s := 'newsditerator(filename, type, lockoptions)';
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit := [=];
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.d := 'An sditerator from another sditerator.';
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.a.sdit := [=];
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.a.sdit.d := 'An sditerator';
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.a.sdit.def := '';
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.a.sdit.a := 'sditerator \tool\ ';
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.a.selection := [=];
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.a.selection.d := 'Record describing any selections to do on opening';
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.a.selection.def := '[=]';
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.a.selection.a := '\glish\  record';
help::pkg.dish.dish.objs.sditerator.c.sditfromsdit.s := 'sditfromsdit(sdit, selection)';
help::pkg.dish.dish.objs.sditerator.m.appendHistory := [=];
help::pkg.dish.dish.objs.sditerator.m.appendHistory.d := 'Add a history element to the global sditerator history.';
help::pkg.dish.dish.objs.sditerator.m.appendHistory.a.newHistory := [=];
help::pkg.dish.dish.objs.sditerator.m.appendHistory.a.newHistory.d := 'The history string to append.';
help::pkg.dish.dish.objs.sditerator.m.appendHistory.a.newHistory.def := '';
help::pkg.dish.dish.objs.sditerator.m.appendHistory.a.newHistory.a := 'String';
help::pkg.dish.dish.objs.sditerator.m.appendHistory.s := 'appendHistory(newHistory)';
help::pkg.dish.dish.objs.sditerator.m.appendrec := [=];
help::pkg.dish.dish.objs.sditerator.m.appendrec.d := 'Put an sdrecord at the end of the sditerator.';
help::pkg.dish.dish.objs.sditerator.m.appendrec.a.rec := [=];
help::pkg.dish.dish.objs.sditerator.m.appendrec.a.rec.d := 'The sdrecord to append to this sditerator.';
help::pkg.dish.dish.objs.sditerator.m.appendrec.a.rec.def := '';
help::pkg.dish.dish.objs.sditerator.m.appendrec.a.rec.a := 'sdrecord';
help::pkg.dish.dish.objs.sditerator.m.appendrec.s := 'appendrec(rec)';
help::pkg.dish.dish.objs.sditerator.m.correcteddata := [=];
help::pkg.dish.dish.objs.sditerator.m.correcteddata.d := 'Is the CORRECTED\_DATA column being used?.';
help::pkg.dish.dish.objs.sditerator.m.correcteddata.s := 'correcteddata()';
help::pkg.dish.dish.objs.sditerator.m.deepcopy := [=];
help::pkg.dish.dish.objs.sditerator.m.deepcopy.d := 'Make a true copy of this data set.';
help::pkg.dish.dish.objs.sditerator.m.deepcopy.a.newname := [=];
help::pkg.dish.dish.objs.sditerator.m.deepcopy.a.newname.d := 'The name of the disk file to hold the new copy';
help::pkg.dish.dish.objs.sditerator.m.deepcopy.a.newname.def := '';
help::pkg.dish.dish.objs.sditerator.m.deepcopy.a.newname.a := 'String';
help::pkg.dish.dish.objs.sditerator.m.deepcopy.s := 'deepcopy(newname)';
help::pkg.dish.dish.objs.sditerator.m.deleterec := [=];
help::pkg.dish.dish.objs.sditerator.m.deleterec.d := 'Delete the sdrecord at the current location pointer.';
help::pkg.dish.dish.objs.sditerator.m.deleterec.s := 'deleterec()';
help::pkg.dish.dish.objs.sditerator.m.done := [=];
help::pkg.dish.dish.objs.sditerator.m.done.d := 'Close this sditerator and disconnect it from the data set.';
help::pkg.dish.dish.objs.sditerator.m.done.s := 'done()';
help::pkg.dish.dish.objs.sditerator.m.get := [=];
help::pkg.dish.dish.objs.sditerator.m.get.d := 'Get an sdrecord.';
help::pkg.dish.dish.objs.sditerator.m.get.s := 'get()';
help::pkg.dish.dish.objs.sditerator.m.getempty := [=];
help::pkg.dish.dish.objs.sditerator.m.getempty.d := 'Get an empty sdrecord.';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.rec := [=];
help::pkg.dish.dish.objs.sditerator.m.getempty.a.rec.d := 'the requested empty sdrecord';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.rec.def := '';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.rec.a := 'sdrecord';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.nchan := [=];
help::pkg.dish.dish.objs.sditerator.m.getempty.a.nchan.d := 'The number of channels';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.nchan.def := '';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.nchan.a := 'Integer';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.nstokes := [=];
help::pkg.dish.dish.objs.sditerator.m.getempty.a.nstokes.d := 'The number of pixels along the stokes axis';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.nstokes.def := '';
help::pkg.dish.dish.objs.sditerator.m.getempty.a.nstokes.a := 'Integer';
help::pkg.dish.dish.objs.sditerator.m.getempty.s := 'getempty(rec, nchan, nstokes)';
help::pkg.dish.dish.objs.sditerator.m.getdata := [=];
help::pkg.dish.dish.objs.sditerator.m.getdata.d := 'Get the data part of the sdrecord.';
help::pkg.dish.dish.objs.sditerator.m.getdata.s := 'getdata()';
help::pkg.dish.dish.objs.sditerator.m.getdesc := [=];
help::pkg.dish.dish.objs.sditerator.m.getdesc.d := 'Get the desc part of the field of the sdrecord.';
help::pkg.dish.dish.objs.sditerator.m.getdesc.s := 'getdesc()';
help::pkg.dish.dish.objs.sditerator.m.getdescvector := [=];
help::pkg.dish.dish.objs.sditerator.m.getdescvector.d := 'Get a vector of values from the desc record.';
help::pkg.dish.dish.objs.sditerator.m.getdescvector.a.fieldNames := [=];
help::pkg.dish.dish.objs.sditerator.m.getdescvector.a.fieldNames.d := 'A vector of desc fields to fetch.';
help::pkg.dish.dish.objs.sditerator.m.getdescvector.a.fieldNames.def := '';
help::pkg.dish.dish.objs.sditerator.m.getdescvector.a.fieldNames.a := 'string vector';
help::pkg.dish.dish.objs.sditerator.m.getdescvector.s := 'getdescvector(fieldNames)';
help::pkg.dish.dish.objs.sditerator.m.getheader := [=];
help::pkg.dish.dish.objs.sditerator.m.getheader.d := 'Get the header part of the sdrecord.';
help::pkg.dish.dish.objs.sditerator.m.getheader.s := 'getheader()';
help::pkg.dish.dish.objs.sditerator.m.getheadervector := [=];
help::pkg.dish.dish.objs.sditerator.m.getheadervector.d := 'Get a vector of values from the header record.';
help::pkg.dish.dish.objs.sditerator.m.getheadervector.a.fieldNames := [=];
help::pkg.dish.dish.objs.sditerator.m.getheadervector.a.fieldNames.d := 'A vector of header fields to fetch.';
help::pkg.dish.dish.objs.sditerator.m.getheadervector.a.fieldNames.def := '';
help::pkg.dish.dish.objs.sditerator.m.getheadervector.a.fieldNames.a := 'string vector';
help::pkg.dish.dish.objs.sditerator.m.getheadervector.s := 'getheadervector(fieldNames)';
help::pkg.dish.dish.objs.sditerator.m.getother := [=];
help::pkg.dish.dish.objs.sditerator.m.getother.d := 'Get the other part of the sdrecord.';
help::pkg.dish.dish.objs.sditerator.m.getother.s := 'getother()';
help::pkg.dish.dish.objs.sditerator.m.getvectors := [=];
help::pkg.dish.dish.objs.sditerator.m.getvectors.d := 'Get a vector of values for the fields in the template.';
help::pkg.dish.dish.objs.sditerator.m.getvectors.a.template := [=];
help::pkg.dish.dish.objs.sditerator.m.getvectors.a.template.d := 'The template indicating which fields to fetch.';
help::pkg.dish.dish.objs.sditerator.m.getvectors.a.template.def := '';
help::pkg.dish.dish.objs.sditerator.m.getvectors.a.template.a := 'record';
help::pkg.dish.dish.objs.sditerator.m.getvectors.s := 'getvectors(template)';
help::pkg.dish.dish.objs.sditerator.m.history := [=];
help::pkg.dish.dish.objs.sditerator.m.history.d := 'Get the global history associated with all sdrecords';
help::pkg.dish.dish.objs.sditerator.m.history.s := 'history()';
help::pkg.dish.dish.objs.sditerator.m.id := [=];
help::pkg.dish.dish.objs.sditerator.m.id.d := 'Return the ID record of this sditerator.';
help::pkg.dish.dish.objs.sditerator.m.id.s := 'id()';
help::pkg.dish.dish.objs.sditerator.m.iswritable := [=];
help::pkg.dish.dish.objs.sditerator.m.iswritable.d := 'Can sdrecords be stored (written) to this sditerator?';
help::pkg.dish.dish.objs.sditerator.m.iswritable.s := 'iswritable()';
help::pkg.dish.dish.objs.sditerator.m.length := [=];
help::pkg.dish.dish.objs.sditerator.m.length.d := 'Get the total number of sdrecords in this sditerator.';
help::pkg.dish.dish.objs.sditerator.m.length.s := 'length()';
help::pkg.dish.dish.objs.sditerator.m.location := [=];
help::pkg.dish.dish.objs.sditerator.m.location.d := 'Get the value of the location pointer.';
help::pkg.dish.dish.objs.sditerator.m.location.s := 'location()';
help::pkg.dish.dish.objs.sditerator.m.more := [=];
help::pkg.dish.dish.objs.sditerator.m.more.d := 'Are there more sdrecords after this location?';
help::pkg.dish.dish.objs.sditerator.m.more.s := 'more()';
help::pkg.dish.dish.objs.sditerator.m.name := [=];
help::pkg.dish.dish.objs.sditerator.m.name.d := 'What is the name of the underlying data on disk.';
help::pkg.dish.dish.objs.sditerator.m.name.s := 'name()';
help::pkg.dish.dish.objs.sditerator.m.next := [=];
help::pkg.dish.dish.objs.sditerator.m.next.d := 'Set the location pointer to the next record.';
help::pkg.dish.dish.objs.sditerator.m.next.s := 'next()';
help::pkg.dish.dish.objs.sditerator.m.unlock := [=];
help::pkg.dish.dish.objs.sditerator.m.unlock.d := 'Release the lock on all associated tables.';
help::pkg.dish.dish.objs.sditerator.m.unlock.s := 'unlock()';
help::pkg.dish.dish.objs.sditerator.m.lock := [=];
help::pkg.dish.dish.objs.sditerator.m.lock.d := 'Set the appropriate lock on all associated tables.';
help::pkg.dish.dish.objs.sditerator.m.lock.a.nattempts := [=];
help::pkg.dish.dish.objs.sditerator.m.lock.a.nattempts.d := 'The number of times to attempt to set the lock.';
help::pkg.dish.dish.objs.sditerator.m.lock.a.nattempts.def := '';
help::pkg.dish.dish.objs.sditerator.m.lock.a.nattempts.a := 'Integer';
help::pkg.dish.dish.objs.sditerator.m.lock.s := 'lock(nattempts)';
help::pkg.dish.dish.objs.sditerator.m.origin := [=];
help::pkg.dish.dish.objs.sditerator.m.origin.d := 'Set the location pointer to the first record.';
help::pkg.dish.dish.objs.sditerator.m.origin.s := 'origin()';
help::pkg.dish.dish.objs.sditerator.m.previous := [=];
help::pkg.dish.dish.objs.sditerator.m.previous.d := 'Set the location pointer to the previous record.';
help::pkg.dish.dish.objs.sditerator.m.previous.s := 'previous()';
help::pkg.dish.dish.objs.sditerator.m.put := [=];
help::pkg.dish.dish.objs.sditerator.m.put.d := 'Put an sdrecord at the current location pointer.';
help::pkg.dish.dish.objs.sditerator.m.put.a.rec := [=];
help::pkg.dish.dish.objs.sditerator.m.put.a.rec.d := 'The replacement sdrecord';
help::pkg.dish.dish.objs.sditerator.m.put.a.rec.def := '';
help::pkg.dish.dish.objs.sditerator.m.put.a.rec.a := 'sdrecord';
help::pkg.dish.dish.objs.sditerator.m.put.s := 'put(rec)';
help::pkg.dish.dish.objs.sditerator.m.reselect := [=];
help::pkg.dish.dish.objs.sditerator.m.reselect.d := 'Re-apply the previous selection to the parent data set.';
help::pkg.dish.dish.objs.sditerator.m.reselect.s := 'reselect()';
help::pkg.dish.dish.objs.sditerator.m.resync := [=];
help::pkg.dish.dish.objs.sditerator.m.resync.d := 'Resynchronize with the data on disk.';
help::pkg.dish.dish.objs.sditerator.m.resync.s := 'resync()';
help::pkg.dish.dish.objs.sditerator.m.flush := [=];
help::pkg.dish.dish.objs.sditerator.m.flush.d := 'Flush the contents to disk.';
help::pkg.dish.dish.objs.sditerator.m.flush.s := 'flush()';
help::pkg.dish.dish.objs.sditerator.m.select := [=];
help::pkg.dish.dish.objs.sditerator.m.select.d := 'Make a new sditerator by applying a selection criteria record';
help::pkg.dish.dish.objs.sditerator.m.select.a.selection := [=];
help::pkg.dish.dish.objs.sditerator.m.select.a.selection.d := 'Selection criteria record';
help::pkg.dish.dish.objs.sditerator.m.select.a.selection.def := '[=]';
help::pkg.dish.dish.objs.sditerator.m.select.a.selection.a := '\glish\  record';
help::pkg.dish.dish.objs.sditerator.m.select.s := 'select(selection)';
help::pkg.dish.dish.objs.sditerator.m.sel2string := [=];
help::pkg.dish.dish.objs.sditerator.m.sel2string.d := 'Convert a selection record to a string.';
help::pkg.dish.dish.objs.sditerator.m.sel2string.a.selrec := [=];
help::pkg.dish.dish.objs.sditerator.m.sel2string.a.selrec.d := 'Selection criteria record';
help::pkg.dish.dish.objs.sditerator.m.sel2string.a.selrec.def := '';
help::pkg.dish.dish.objs.sditerator.m.sel2string.a.selrec.a := '\glish\  record';
help::pkg.dish.dish.objs.sditerator.m.sel2string.s := 'sel2string(selrec)';
help::pkg.dish.dish.objs.sditerator.m.setlocation := [=];
help::pkg.dish.dish.objs.sditerator.m.setlocation.d := 'Set the location pointer to the indicated record.';
help::pkg.dish.dish.objs.sditerator.m.setlocation.a.location := [=];
help::pkg.dish.dish.objs.sditerator.m.setlocation.a.location.d := 'The desired record number.';
help::pkg.dish.dish.objs.sditerator.m.setlocation.a.location.def := '';
help::pkg.dish.dish.objs.sditerator.m.setlocation.a.location.a := 'Integer';
help::pkg.dish.dish.objs.sditerator.m.setlocation.s := 'setlocation(location)';
help::pkg.dish.dish.objs.sditerator.m.stringfields := [=];
help::pkg.dish.dish.objs.sditerator.m.stringfields.d := 'Returns a record indicating which fields in the sditerator are strings.';
help::pkg.dish.dish.objs.sditerator.m.stringfields.s := 'stringfields()';
help::pkg.dish.dish.objs.sditerator.m.type := [=];
help::pkg.dish.dish.objs.sditerator.m.type.d := 'Return the type of the underlying data.';
help::pkg.dish.dish.objs.sditerator.m.type.s := 'type()';
help::pkg.dish.dish.objs.sditerator.m.usecorrecteddata := [=];
help::pkg.dish.dish.objs.sditerator.m.usecorrecteddata.d := 'Use the CORRECTED\_DATA column?.';
help::pkg.dish.dish.objs.sditerator.m.usecorrecteddata.a.correcteddata := [=];
help::pkg.dish.dish.objs.sditerator.m.usecorrecteddata.a.correcteddata.d := 'Use the CORRECTED\_DATA column?';
help::pkg.dish.dish.objs.sditerator.m.usecorrecteddata.a.correcteddata.def := '';
help::pkg.dish.dish.objs.sditerator.m.usecorrecteddata.a.correcteddata.a := 'Bool';
help::pkg.dish.dish.objs.sditerator.m.usecorrecteddata.s := 'usecorrecteddata(correcteddata)';

