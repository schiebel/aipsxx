# atomssynthesis.g: help atoms for the synthesis package. 
# Copyright (C) 1999
# Associated Universities, Inc. Washington DC, USA.
#
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This library is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
# License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
#
# Correspondence concerning AIPS++ should be addressed as follows:
#        Internet email: aips2-request@nrao.edu.
#        Postal address: AIPS++ Project Office
#                        National Radio Astronomy Observatory
#                        520 Edgemont Road
#                        Charlottesville, VA 22903-2475 USA
#
# $Id: atomssynthesis.g,v 19.959 2006/09/29 01:49:20 wyoung Exp $

pragma include once
val help::pkg.synthesis := [=];
help::pkg.synthesis::d := 'package for processing synthesis data';

help::pkg.synthesis.autoflag := [=];
help::pkg.synthesis.autoflag.objs := [=];
help::pkg.synthesis.autoflag.funs := [=];
help::pkg.synthesis.autoflag.d := 'Module for automatic flagging of synthesis data';
help::pkg.synthesis.autoflag.objs.autoflag := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m := [=];
help::pkg.synthesis.autoflag.objs.autoflag.c := [=];
help::pkg.synthesis.autoflag.objs.autoflag.d := 'Automatic synthesis flagging';
help::pkg.synthesis.autoflag.objs.autoflag.c.autoflag := [=];
help::pkg.synthesis.autoflag.objs.autoflag.c.autoflag.d := 'Construct an autoflag tool from a MeasurementSet';
help::pkg.synthesis.autoflag.objs.autoflag.c.autoflag.a.msname := [=];
help::pkg.synthesis.autoflag.objs.autoflag.c.autoflag.a.msname.d := 'Measurement set to be processed';
help::pkg.synthesis.autoflag.objs.autoflag.c.autoflag.a.msname.def := 'none';
help::pkg.synthesis.autoflag.objs.autoflag.c.autoflag.a.msname.a := 'Table name';
help::pkg.synthesis.autoflag.objs.autoflag.c.autoflag.s := 'autoflag(msname)';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.d := 'Sets up the time-median flagging method';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.thr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.thr.d := 'Flagging threshold';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.thr.def := '5';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.thr.a := 'numeric (real)';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.hw := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.hw.d := 'Half-window for the sliding median, if time slots is less than  4 times half window, ignoring this chunk';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.hw.def := '10';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.hw.a := 'Int';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.rowthr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.rowthr.d := 'Row flagging threshold';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.rowthr.def := '10';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.rowthr.a := 'numeric (real)';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.rowhw := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.rowhw.d := 'Half-window for the sliding median of the MAD';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.rowhw.def := '10';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.rowhw.a := 'Int';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.norow := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.norow.d := 'Disable row flagging';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.norow.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.norow.a := 'Boolean';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.column := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.column.d := 'Which column to base flagging on';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.column.def := '"DATA"';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.column.a := '"DATA", "MODEL" or "CORR"';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.expr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.expr.d := 'Expression to use';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.expr.def := '"ABS I"';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.expr.a := 'see text';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.fignore := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.fignore.d := 'Ignore existing flags';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.fignore.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.a.fignore.a := 'Boolean';
help::pkg.synthesis.autoflag.objs.autoflag.m.settimemed.s := 'settimemed(thr, hw, rowthr, rowhw, norow, column, expr, fignore)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.d := 'Sets up the new time-median flagging method';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.thr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.thr.d := 'Flagging threshold';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.thr.def := '3';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.thr.a := 'numeric (real)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.column := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.column.d := 'Which column to base flagging on';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.column.def := '"DATA"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.column.a := '"DATA", "MODEL" or "CORR"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.expr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.expr.d := 'Expression to use';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.expr.def := '"ABS I"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.expr.a := 'see text';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.fignore := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.fignore.d := 'Ignore existing flags';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.fignore.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.a.fignore.a := 'Boolean';
help::pkg.synthesis.autoflag.objs.autoflag.m.setnewtimemed.s := 'setnewtimemed(thr, column, expr, fignore)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.d := 'Set the data parameters selection for subsequent  processing';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mode := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mode.d := 'Type of processing: fieldids, spwids, channel or velocity';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mode.def := '';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mode.a := '\' fieldids\' |\' spwids\' |\' channel\' |\' velocity\' ';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.nchan := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.nchan.d := 'Number of channels to select';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.nchan.def := '1';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.nchan.a := 'Vector of Ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.start := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.start.d := 'Start channels (1-relative)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.start.def := '';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.start.a := ' Vector of Ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.step := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.step.d := 'Step in channel number';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.step.def := '';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.step.a := 'Vector of Int';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mstart := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mstart.d := 'Start velocity (e.g. \' 20Km/s\' )';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mstart.def := '';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mstart.a := 'Quantity';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mstep := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mstep.d := 'Step in velocity (e.g. \' 100m/s\' ';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mstep.def := '';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.mstep.a := 'Quantity';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.spwid := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.spwid.d := 'Spectral Window Ids (1 relative) to select';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.spwid.def := '[]';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.spwid.a := 'Vector of Ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.fieldid := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.fieldid.d := 'Field Ids (1 relative) to select';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.fieldid.def := '[]';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.fieldid.a := 'Vector of Ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.msselect := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.msselect.d := 'TQL select string applied as a logical "and" with the other selections';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.msselect.def := '';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.msselect.a := 'String';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.async := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.async.def := '!dowait';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.a.async.a := 'Bool';
help::pkg.synthesis.autoflag.objs.autoflag.m.setdata.s := 'setdata(mode, nchan, start, step, mstart, mstep, spwid, fieldid, msselect, async)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.d := 'Sets up the freq-median flagging method';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.thr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.thr.d := 'Flagging threshold';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.thr.def := '5';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.thr.a := 'numeric (real)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.hw := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.hw.d := 'Half-window for the sliding median';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.hw.def := '10';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.hw.a := 'Int';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.rowthr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.rowthr.d := 'Row flagging threshold';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.rowthr.def := '10';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.rowthr.a := 'numeric (real)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.rowhw := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.rowhw.d := 'Half-window for the sliding median of the MAD';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.rowhw.def := '10';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.rowhw.a := 'Int';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.column := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.column.d := 'Which column to base flagging on';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.column.def := 'DATA';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.column.a := '"DATA", "MODEL" or "CORR"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.expr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.expr.d := 'Expression to use';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.expr.def := '"ABS I"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.expr.a := 'see text';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.fignore := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.fignore.d := 'Ignore existing flags';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.fignore.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.a.fignore.a := 'Bool';
help::pkg.synthesis.autoflag.objs.autoflag.m.setfreqmed.s := 'setfreqmed(thr, hw, rowthr, rowhw, column, expr, fignore)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.d := 'Sets up the spectral rejection flagging method';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.ndeg := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.ndeg.d := 'Number of degrees for polynomial';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.ndeg.def := '2';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.ndeg.a := 'Int';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.rowthr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.rowthr.d := 'Flagging threshold, in MADs of $\chi^2$';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.rowthr.def := '5';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.rowthr.a := 'numeric (real)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.rowhw := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.rowhw.d := 'Half-window for the sliding median';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.rowhw.def := '6';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.rowhw.a := 'Int';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.norow := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.norow.d := 'Disable row flagging';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.norow.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.norow.a := 'Boolean';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.spwid := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.spwid.d := 'Spectral window number (1-based), or [\/] or F for  all windows';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.spwid.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.spwid.a := 'F or [\/] or Int';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.fq := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.fq.d := 'Range of frequencies';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.fq.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.fq.a := '2N or (2,N) array of Strings w/units or Floats';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.chan := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.chan.d := 'Range of channels (1-based). Either ``fq\' \'  or ``chan\' \'  must be specified.';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.chan.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.chan.a := '2N or (2,N) array of Ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.region := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.region.d := 'A compound spectral segment specification (see example)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.region.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.region.a := 'Record of records';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.column := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.column.d := 'Which column to base flagging on';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.column.def := '"DATA"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.column.a := '"DATA", "MODEL" or "CORR"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.expr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.expr.d := 'Expression to use';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.expr.def := '"ABS I"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.expr.a := 'see text';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.fignore := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.fignore.d := 'Ignore existing flags';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.fignore.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.a.fignore.a := 'Bool';
help::pkg.synthesis.autoflag.objs.autoflag.m.setsprej.s := 'setsprej(ndeg, rowthr, rowhw, norow, spwid, fq, chan, region, column, expr, fignore)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.d := 'Sets up the UV Binner flagging method';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.thr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.thr.d := 'Population cut-off, as $p(N)$ value.';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.thr.def := '0';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.thr.a := 'Float, 0 for none';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.minpop := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.minpop.d := 'Population cut-off, as minimum bin count. Either thr or maxpop must be specified, or both.';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.minpop.def := '0';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.minpop.a := 'Int, 0 for none';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.nbins := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.nbins.d := 'Number of bins (one number for both axes, or separate for UV, value)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.nbins.def := '50';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.nbins.a := 'Int or 2 Ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.plotchan := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.plotchan.d := 'Channel number (1-based) to plot, T for middle channel, or F for no plot';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.plotchan.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.plotchan.a := 'Int or Bool';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.econoplot := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.econoplot.d := 'Produce an economical plot (crowded bins are not resolved)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.econoplot.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.econoplot.a := 'Bool';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.column := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.column.d := 'Which column to base flagging on';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.column.def := '"DATA"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.column.a := '"DATA", "MODEL" or "CORR"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.expr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.expr.d := 'Expression to use';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.expr.def := '"ABS I"';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.expr.a := 'see text';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.fignore := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.fignore.d := 'Ignore existing flags';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.fignore.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.a.fignore.a := 'Bool';
help::pkg.synthesis.autoflag.objs.autoflag.m.setuvbin.s := 'setuvbin(thr, minpop, nbins, plotchan, econoplot, column, expr, fignore)';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.d := 'Sets up the Selector flagging method';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.spwid := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.spwid.d := 'Spectral window numbers (1-based), or [\/] or F for all';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.spwid.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.spwid.a := 'Array of ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.field := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.field.d := 'Field names or numbers (1-based), or [\/] or F for all';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.field.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.field.a := 'Array of ints/strings';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.fq := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.fq.d := 'Range(s) of frequencies, or [\/] or F for all';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.fq.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.fq.a := '2N or (2,N) array of Strings w/units or floats';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.chan := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.chan.d := 'Range(s) of channels (1-based), or [\/] or F for all';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.chan.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.chan.a := '2N or (2,N) array of ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.corr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.corr.d := 'Correlations (by name, e.g. ``XX YY\' \' ), or [\/] or F for all';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.corr.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.corr.a := 'array of strings';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.ant := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.ant.d := 'Antennas (by name or number), or [\/] or F for all';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.ant.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.ant.a := 'array of strings/ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.baseline := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.baseline.d := 'Baselines, or [\/] or F for all';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.baseline.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.baseline.a := 'array of strings/ints';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.timerng := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.timerng.d := 'Time ranges, as MJDs or date strings, or [\/] or F for all';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.timerng.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.timerng.a := 'array of strings/floats';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.autocorr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.autocorr.d := 'Flag autocorrelations';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.autocorr.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.autocorr.a := 'Boolean';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.timeslot := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.timeslot.d := 'Flag specific time slots. Specifies center time as MJDs or date strings';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.timeslot.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.timeslot.a := 'array of strings/floats';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.dtime := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.dtime.d := 'Tolerance of timeslot parameter, in seconds';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.dtime.def := '10';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.dtime.a := 'numeric';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.clip := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.clip.d := 'Flag values outside a specific range';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.clip.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.clip.a := 'Record, see above';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.flagrange := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.flagrange.d := 'Flag values within a specific range';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.flagrange.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.flagrange.a := 'Record, see above';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.quack := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.quack.d := 'Flag VLA quacks -- scan interval and quack length, in seconds';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.quack.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.quack.a := '2-element numeric array';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.unflag := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.unflag.d := 'Clear flags instead of setting them';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.unflag.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.a.unflag.a := 'Boolean';
help::pkg.synthesis.autoflag.objs.autoflag.m.setselect.s := 'setselect(spwid, field, fq, chan, corr, ant, baseline, timerng, autocorr, timeslot, dtime, clip, flagrange, quack, unflag)';
help::pkg.synthesis.autoflag.objs.autoflag.m.attach := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.attach.d := 'Attaches tool to another measurement set';
help::pkg.synthesis.autoflag.objs.autoflag.m.attach.a.msname := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.attach.a.msname.d := 'Measurement set to be processed';
help::pkg.synthesis.autoflag.objs.autoflag.m.attach.a.msname.def := 'none';
help::pkg.synthesis.autoflag.objs.autoflag.m.attach.a.msname.a := 'Table name';
help::pkg.synthesis.autoflag.objs.autoflag.m.attach.s := 'attach(msname)';
help::pkg.synthesis.autoflag.objs.autoflag.m.run := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.run.d := 'Executes a flagging run';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.globparm := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.globparm.d := 'Record of global method parameters';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.globparm.def := 'empty';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.globparm.a := 'Record';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.plotscr := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.plotscr.d := 'Number of plots per window for on-screen flagging report, or default for no report';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.plotscr.def := 'No report';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.plotscr.a := '$\lbrack nx,ny\rbrack$';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.plotdev := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.plotdev.d := 'Number of plots per page in hardcopy flagging report,  or [\/] or F for no report';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.plotdev.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.plotdev.a := 'Boolean F or $\lbrack nx,ny\rbrack$';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.devfile := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.devfile.d := 'File or PGPlot device for hardcopy report';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.devfile.def := 'flagreport.ps/ps';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.devfile.a := 'String';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.reset := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.reset.d := 'Reset pre-existing flags before running';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.reset.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.reset.a := 'Boolean';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.trial := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.trial.d := 'Do a trial run only';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.trial.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.a.trial.a := 'Boolean';
help::pkg.synthesis.autoflag.objs.autoflag.m.run.s := 'run(globparm, plotscr, plotdev, devfile, reset, trial)';
help::pkg.synthesis.autoflag.objs.autoflag.m.summary := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.summary.d := 'Prints a summary of active methods';
help::pkg.synthesis.autoflag.objs.autoflag.m.summary.s := 'summary()';
help::pkg.synthesis.autoflag.objs.autoflag.m.help := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.help.d := 'Prints help on available flagging methods';
help::pkg.synthesis.autoflag.objs.autoflag.m.help.a.names := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.help.a.names.d := 'Names of methods (all methods, if omitted)';
help::pkg.synthesis.autoflag.objs.autoflag.m.help.a.names.def := 'F';
help::pkg.synthesis.autoflag.objs.autoflag.m.help.a.names.a := 'String';
help::pkg.synthesis.autoflag.objs.autoflag.m.help.s := 'help(names)';
help::pkg.synthesis.autoflag.objs.autoflag.m.reset := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.reset.d := 'Disables specific flagging methods';
help::pkg.synthesis.autoflag.objs.autoflag.m.reset.a.methods := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.reset.a.methods.d := 'Names or numbers of methods';
help::pkg.synthesis.autoflag.objs.autoflag.m.reset.a.methods.def := 'none';
help::pkg.synthesis.autoflag.objs.autoflag.m.reset.a.methods.a := 'String or int';
help::pkg.synthesis.autoflag.objs.autoflag.m.reset.s := 'reset(methods)';
help::pkg.synthesis.autoflag.objs.autoflag.m.resetall := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.resetall.d := 'Disables all flagging methods';
help::pkg.synthesis.autoflag.objs.autoflag.m.resetall.s := 'resetall()';
help::pkg.synthesis.autoflag.objs.autoflag.m.detach := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.detach.d := 'Detaches from measurement set';
help::pkg.synthesis.autoflag.objs.autoflag.m.detach.s := 'detach()';
help::pkg.synthesis.autoflag.objs.autoflag.m.done := [=];
help::pkg.synthesis.autoflag.objs.autoflag.m.done.d := 'Destroys the autoflag tool';
help::pkg.synthesis.autoflag.objs.autoflag.m.done.s := 'done()';

help::pkg.synthesis.calibrater := [=];
help::pkg.synthesis.calibrater.objs := [=];
help::pkg.synthesis.calibrater.funs := [=];
help::pkg.synthesis.calibrater.d := 'Module for synthesis calibration';
help::pkg.synthesis.calibrater.objs.calibrater := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m := [=];
help::pkg.synthesis.calibrater.objs.calibrater.c := [=];
help::pkg.synthesis.calibrater.objs.calibrater.d := 'Synthesis calibration (self- and cross-)';
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater := [=];
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.d := 'Construct a calibrater tool';
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.a.filename := [=];
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.a.filename.d := 'MeasurementSet file name.  No default';
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.a.filename.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.a.filename.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.a.compress := [=];
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.a.compress.d := 'Compress calibration columns?';
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.a.compress.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.a.compress.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.c.calibrater.s := 'calibrater(filename, compress)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.d := 'Set the data selection for subsequent processing';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mode := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mode.d := 'Type of data selection: channel or velocity';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mode.def := '\' none\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mode.a := 'String from \' none\' |\' channel\' |\' velocity\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.nchan := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.nchan.d := 'Number of channels to select (mode=\' channel\' )';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.nchan.def := '1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.nchan.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.start := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.start.d := 'Start channel (1-relative) (mode=\' channel\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.start.def := '1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.start.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.step := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.step.d := 'Step in channel number (mode=\' channel\' )';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.step.def := '1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.step.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mstart := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mstart.d := 'Start velocity (e.g. \' 20Km/s\' )';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mstart.def := '\' 0km/s\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mstart.a := 'Quantity';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mstep := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mstep.d := 'Step in velocity (e.g. \' 100m/s\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mstep.def := '\' 0km/s\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.mstep.a := 'Quantity';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.uvrange := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.uvrange.d := 'UV range (in klambda) (e.g. [0, 50]).  Default is no restriction.';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.uvrange.def := '0';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.uvrange.a := 'Vector of Doubles';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.msselect := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.msselect.d := 'TAQL selection string.  Default is no selection.';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.msselect.def := '\'  \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.a.msselect.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.setdata.s := 'setdata(mode, nchan, start, step, mstart, mstep, uvrange, msselect)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.d := 'Arrange to apply calibration';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.type := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.type.d := 'Component type';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.type.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.type.a := 'String from \' B\' ,\' BPOLY\' ,\' G\' ,\' GSPLINE\' ,\' D\' ,\' P\' ,\' T\' ,\' TOPAC\' ,\' GAINCURVE\' ,\' M\' ,\' MF\' ,\' K\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.t := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.t.d := 'Interpolation interval (seconds)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.t.def := '0.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.t.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.table := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.table.d := 'Calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.table.def := '\'  \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.table.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.interp := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.interp.d := 'Interpolation type (in time)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.interp.def := '\' nearest\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.interp.a := 'String from \' nearest\' , \' linear\' , \' aipslin\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.select := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.select.d := 'TAQL selection string. Default is no selection';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.select.def := '\'  \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.select.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.spwmap := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.spwmap.d := 'Spectral windows to apply';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.spwmap.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.spwmap.a := 'Vector of Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.unset := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.unset.d := 'If T, unset apply of this type';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.unset.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.unset.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.opacity := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.opacity.d := 'Array-wide zenith opacity (for type=\' TOPAC\' )';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.opacity.def := '0.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.opacity.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.rawspw := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.rawspw.d := 'Spectral window with data phases for application';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.rawspw.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.a.rawspw.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.setapply.s := 'setapply(type, t, table, interp, select, spwmap, unset, opacity, rawspw)';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.d := 'Produce a smooth and/or interpolated table';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.infile := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.infile.d := 'Input calibration table';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.infile.def := 'No default';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.infile.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.outfile := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.outfile.d := 'Output calibration table';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.outfile.def := 'No default';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.outfile.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.append := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.append.d := 'Append to an existing output table?';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.append.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.append.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.select := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.select.d := 'TAQL selection string';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.select.def := 'No selection';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.select.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.smoothtype := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.smoothtype.d := 'The smoothing filter to be used';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.smoothtype.def := '\' mean\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.smoothtype.a := 'String from \' mean\' , \' median\' , \' smean\'  (sliding mean), \' smedian\'  (sliding median) or \' none\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.smoothtime := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.smoothtime.d := 'Smoothing filter time constant (sec)';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.smoothtime.def := '0.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.smoothtime.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.interptype := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.interptype.d := 'The type of interpolation desired';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.interptype.def := '\' spline\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.interptype.a := 'String from \' nearest\' ,\' spline\' ,\' linear\' ,\' cubic\' ,or \' none\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.interptime := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.interptime.d := 'Sampling interval for interpolation (sec)';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.interptime.def := '0.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.a.interptime.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.smooth.s := 'smooth(infile, outfile, append, select, smoothtype, smoothtime, interptype, interptime)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.d := 'Arrange to solve for calibration';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.type := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.type.d := 'Component type';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.type.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.type.a := 'String from \' G\' ,\' T\' ,\' B\' ,\' D\' ,\' M\' ,\' MF\' ,\' K\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.t := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.t.d := 'Solution interval (in sec)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.t.def := '60.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.t.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.preavg := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.preavg.d := 'Pre-averaging interval (in sec)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.preavg.def := '60.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.preavg.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.phaseonly := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.phaseonly.d := 'Solve only for phase?';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.phaseonly.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.phaseonly.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.refant := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.refant.d := 'Reference antenna.  Default is none.';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.refant.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.refant.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.table := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.table.d := 'Output calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.table.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.table.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.append := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.append.d := 'Append to existing table?';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.append.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.append.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.unset := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.unset.d := 'If T, unset solve of this type';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.unset.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.a.unset.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolve.s := 'setsolve(type, t, preavg, phaseonly, refant, table, append, unset)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.d := 'Specialization of setsolve';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.table := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.table.d := 'Output calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.table.def := '\'  \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.table.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.append := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.append.d := 'Append to existing table?';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.append.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.append.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.mode := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.mode.d := 'Phase or Amplitude mode?';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.mode.def := '\' PHAS\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.mode.a := 'String from \' PHAS\' , \' AMP\' , or \' PHASAMP\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.degree := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.degree.d := 'Order of polynomial)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.degree.def := '3';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.degree.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.refant := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.refant.d := 'Reference antenna.  Default is none.';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.refant.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.refant.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.unset := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.unset.d := 'If T, unset solve of this type';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.unset.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.a.unset.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainpoly.s := 'setsolvegainpoly(table, append, mode, degree, refant, unset)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.d := 'Specialization of setsolve for cubic spline G (time-dependent gain) solving';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.table := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.table.d := 'Output calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.table.def := '\'  \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.table.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.append := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.append.d := 'Append to existing table?';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.append.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.append.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.mode := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.mode.d := 'Phase or Amplitude mode?';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.mode.def := '\' PHAS\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.mode.a := 'String from \' PHAS\' , \' AMP\' , or \' PHASAMP\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.preavg := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.preavg.d := 'Pre-averaging interval (in sec)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.preavg.def := '0.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.preavg.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.splinetime := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.splinetime.d := 'Spline timescale (sec)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.splinetime.def := '10800';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.splinetime.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.refant := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.refant.d := 'Reference antenna.  Default is none.';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.refant.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.refant.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.npointaver := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.npointaver.d := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.npointaver.def := '10';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.npointaver.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.phasewrap := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.phasewrap.d := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.phasewrap.def := '250';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.phasewrap.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.unset := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.unset.d := 'If T, unset solve of this type';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.unset.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.a.unset.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvegainspline.s := 'setsolvegainspline(table, append, mode, preavg, splinetime, refant, npointaver, phasewrap, unset)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.d := 'Specialization of setsolve for polynomial B (bandpass) solving';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.table := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.table.d := 'Output calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.table.def := '\'  \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.table.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.append := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.append.d := 'Append to existing table?';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.append.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.append.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.degamp := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.degamp.d := 'Polynomial degree for amplitude solution';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.degamp.def := '3';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.degamp.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.degphase := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.degphase.d := 'Polynomial degree for phase solution';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.degphase.def := '3';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.degphase.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.visnorm := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.visnorm.d := 'Normalize data prior to solution';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.visnorm.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.visnorm.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.bpnorm := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.bpnorm.d := 'Normalize result?';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.bpnorm.def := 'T';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.bpnorm.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.maskcenter := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.maskcenter.d := 'Number of channels to avoid in center of each band';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.maskcenter.def := '1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.maskcenter.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.masksedge := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.masksedge.d := 'Fraction of channels to avoid at each band edge (in \%)';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.masksedge.def := '5';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.masksedge.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.refant := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.refant.d := 'Reference antenna';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.refant.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.refant.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.unset := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.unset.d := 'If T, unset solve of this type';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.unset.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.a.unset.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.setsolvebandpoly.s := 'setsolvebandpoly(table, append, degamp, degphase, visnorm, bpnorm, maskcenter, masksedge, refant, unset)';
help::pkg.synthesis.calibrater.objs.calibrater.m.state := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.state.d := 'Request the apply/solve state of the calibrater tool';
help::pkg.synthesis.calibrater.objs.calibrater.m.state.s := 'state()';
help::pkg.synthesis.calibrater.objs.calibrater.m.reset := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.d := 'Reset the selected apply and/or solve components';
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.a.apply := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.a.apply.d := 'If T, unset all apply settings';
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.a.apply.def := 'T';
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.a.apply.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.a.solve := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.a.solve.d := 'If T, unset all solve settings';
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.a.solve.def := 'T';
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.a.solve.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.reset.s := 'reset(apply, solve)';
help::pkg.synthesis.calibrater.objs.calibrater.m.initcalset := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.initcalset.d := 'Re-initialize the calibration scratch columns';
help::pkg.synthesis.calibrater.objs.calibrater.m.initcalset.a.calset := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.initcalset.a.calset.d := 'Not yet used.';
help::pkg.synthesis.calibrater.objs.calibrater.m.initcalset.a.calset.def := '1';
help::pkg.synthesis.calibrater.objs.calibrater.m.initcalset.a.calset.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.initcalset.s := 'initcalset(calset)';
help::pkg.synthesis.calibrater.objs.calibrater.m.solve := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.solve.d := 'Solve for the selected calibration components';
help::pkg.synthesis.calibrater.objs.calibrater.m.solve.s := 'solve()';
help::pkg.synthesis.calibrater.objs.calibrater.m.correct := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.correct.d := 'Apply calibration information';
help::pkg.synthesis.calibrater.objs.calibrater.m.correct.s := 'correct()';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.d := 'Fit single-component source models to the uv-data';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.niter := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.niter.d := 'Number of fitting iterations to execute';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.niter.def := '0';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.niter.a := 'Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.type := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.type.d := 'The component type';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.type.def := '"P"';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.type.a := 'String: "P", "G", or "D"';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.par := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.par.d := 'Starting guess for component parameters';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.par.def := '[1,0,0]';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.par.a := 'Vector of Int';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.vary := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.vary.d := 'Control which parameters to let vary in fit';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.vary.def := '[]';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.vary.a := 'Vector of Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.file := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.file.d := 'Optional output component list table';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.file.def := '""';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.a.file.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.modelfit.s := 'modelfit(niter, type, par, vary, file)';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.d := 'Bootstrap the flux density scale from standard calibrators';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.tablein := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.tablein.d := 'Input calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.tablein.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.tablein.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.tableout := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.tableout.d := 'Output calibration table name.  Default is tablein.';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.tableout.def := '\' \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.tableout.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.reference := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.reference.d := 'Reference calibrator field names or indices';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.reference.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.reference.a := 'Vector of strings';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.transfer := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.transfer.d := 'Transfer source field names or indices.  Default is all other fields';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.transfer.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.transfer.a := 'Vector of strings';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.append := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.append.d := 'Append to existing table?';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.append.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.append.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.refspwmap := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.refspwmap.d := 'List of alternate spw for referencing';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.refspwmap.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.refspwmap.a := 'Vector of Ints';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.fluxd := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.fluxd.d := 'Array of output flux densities';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.fluxd.def := '[]';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.a.fluxd.a := 'Double';
help::pkg.synthesis.calibrater.objs.calibrater.m.fluxscale.s := 'fluxscale(tablein, tableout, reference, transfer, append, refspwmap, fluxd)';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.d := 'Accumulate incremental calibration solutions into a cumulative calibration table';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.tablein := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.tablein.d := 'Input cumulative calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.tablein.def := '""';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.tablein.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.incrtable := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.incrtable.d := 'Input incremental calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.incrtable.def := '""';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.incrtable.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.tableout := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.tableout.d := 'Output cumulative calibration table name.  Default is tablein.';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.tableout.def := '""';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.tableout.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.field := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.field.d := 'List of fields to update in input cumulative table.  Default is all.';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.field.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.field.a := 'Vector of strings';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.calfield := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.calfield.d := 'List of fields in incremental table to use.  Default is all.';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.calfield.def := '-1';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.calfield.a := 'Vector of strings';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.interp := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.interp.d := 'Interpolation mode to use on incremental solutions';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.interp.def := '\' linear\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.interp.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.t := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.t.d := 'Cumulative table timescale when creating from scratch';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.t.def := '-1.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.a.t.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.accumulate.s := 'accumulate(tablein, incrtable, tableout, field, calfield, interp, t)';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.d := 'Apply position angle calibration to an existing cal table';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.tablein := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.tablein.d := 'Input calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.tablein.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.tablein.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.tableout := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.tableout.d := 'Output calibration table name.  Default is input table';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.tableout.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.tableout.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.posangcor := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.posangcor.d := 'Position angle corrections (degrees)';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.posangcor.def := '[]';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.a.posangcor.a := 'Vector of Floats';
help::pkg.synthesis.calibrater.objs.calibrater.m.posangcal.s := 'posangcal(tablein, tableout, posangcor)';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.d := 'Average calibration solutions over fields, spectral windows, and/or time';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.tablein := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.tablein.d := 'Input calibration table name.  No default';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.tablein.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.tablein.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.tableout := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.tableout.d := 'Output calibration table name.  No default';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.tableout.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.tableout.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.fldsin := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.fldsin.d := 'Input field id(s).  No default';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.fldsin.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.fldsin.a := 'Vector of integers';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.spwsin := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.spwsin.d := 'Input spectral window id(s).  No default';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.spwsin.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.spwsin.a := 'Vector of integers';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.fldsout := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.fldsout.d := 'Output field id(s).  No default';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.fldsout.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.fldsout.a := 'Vector of integer';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.spwout := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.spwout.d := 'Output spectral window.  No default';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.spwout.def := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.spwout.a := 'Integer';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.t := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.t.d := 'Averaging time (s).  Default is to just copy solutions';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.t.def := '-1.0';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.t.a := 'Float';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.append := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.append.d := 'Append to existing table?';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.append.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.append.a := 'Boolean';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.mode := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.mode.d := '';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.mode.def := '\' RI\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.mode.a := 'String from RI or AP';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.verbose := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.verbose.d := 'Write extra information to logger about proceses';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.verbose.def := '\' T\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.a.verbose.a := 'T or F';
help::pkg.synthesis.calibrater.objs.calibrater.m.calave.s := 'calave(tablein, tableout, fldsin, spwsin, fldsout, spwout, t, append, mode, verbose)';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.d := 'Correct the gain table for linear polarization of the calibrator';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.tablein := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.tablein.d := 'Input calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.tablein.def := '\' \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.tablein.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.tableout := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.tableout.d := 'Output calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.tableout.def := '\' \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.tableout.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.fields := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.fields.d := 'Calibrator field names';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.fields.def := '""';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.a.fields.a := 'Vector of strings';
help::pkg.synthesis.calibrater.objs.calibrater.m.linpolcor.s := 'linpolcor(tablein, tableout, fields)';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.d := 'Plot a calibration table';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.plottype := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.plottype.d := 'Plot type';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.plottype.def := '\' AMP\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.plottype.a := 'String from \' AMP\' |\' 1/AMP\' |\' PHASE\' |\' RLPHASE\' |\' XYPHASE\' |\' RI\' |\' DAMP\' |\' DPHASE\' |\' DRI\' |\' FIT\' |\' FITWGT\' |\' TOTALFIT\' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.tablename := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.tablename.d := 'Calibration table name';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.tablename.def := '\' \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.tablename.a := 'String';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.antennas := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.antennas.d := 'Antennas to plot';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.antennas.def := '[]';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.antennas.a := 'Vector of Ints';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.fields := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.fields.d := 'Fields to plot';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.fields.def := '[]';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.fields.a := 'Vector of Ints';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.polarization := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.polarization.d := 'Polarization to plot';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.polarization.def := '1';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.polarization.a := 'Integer';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.spwids := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.spwids.d := 'Spectral windows id.\' s to plot';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.spwids.def := '[]';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.spwids.a := 'Vector of Ints';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.multiplot := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.multiplot.d := 'Turn on separate antenna plots';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.multiplot.def := 'F';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.multiplot.a := 'Bool';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.nx := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.nx.d := 'If multiplot=T, number of plots on horizontal axis';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.nx.def := '1';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.nx.a := 'Integer';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.ny := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.ny.d := 'If multiplot=T, number of plots on vertical axis';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.ny.def := '1';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.ny.a := 'Integer';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.psfile := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.psfile.d := 'name of output PostScript file. Empty string causes plot to be sent to the screen';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.psfile.def := '\' \' ';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.a.psfile.a := 'string';
help::pkg.synthesis.calibrater.objs.calibrater.m.plotcal.s := 'plotcal(plottype, tablename, antennas, fields, polarization, spwids, multiplot, nx, ny, psfile)';
help::pkg.synthesis.calibrater.objs.calibrater.m.close := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.close.d := 'Close the calibrater tool';
help::pkg.synthesis.calibrater.objs.calibrater.m.close.s := 'close()';
help::pkg.synthesis.calibrater.objs.calibrater.m.done := [=];
help::pkg.synthesis.calibrater.objs.calibrater.m.done.d := 'Destroy the calibrater tool';
help::pkg.synthesis.calibrater.objs.calibrater.m.done.s := 'done()';

help::pkg.synthesis.componentmodels := [=];
help::pkg.synthesis.componentmodels.objs := [=];
help::pkg.synthesis.componentmodels.funs := [=];
help::pkg.synthesis.componentmodels.d := 'A module for the manipulation of     model components';
help::pkg.synthesis.componentmodels.objs.componentlist := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.d := 'A tool for the manipulation of     groups of components';
help::pkg.synthesis.componentmodels.objs.componentlist.c.emptycomponentlist := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.emptycomponentlist.d := 'Construct an empty componentlist';
help::pkg.synthesis.componentmodels.objs.componentlist.c.emptycomponentlist.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.emptycomponentlist.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.c.emptycomponentlist.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.c.emptycomponentlist.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.c.emptycomponentlist.s := 'emptycomponentlist(log)';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.d := 'Construct an componentlist     from the data in an AIPS++\ table';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.filename := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.filename.d := 'The filename of the table';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.filename.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.filename.a := 'Any valid componentlist table';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.readonly := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.readonly.d := 'Should the table be opened read only';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.readonly.def := 'F';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.readonly.a := 'T or F';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.c.componentlist.s := 'componentlist(filename, readonly, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.d := 'Create a componentlist from an ascii file';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.filename := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.filename.d := 'Name of output component list table';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.filename.def := 'None';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.filename.a := 'String';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.asciifile := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.asciifile.d := 'Name of input ascii file';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.asciifile.def := 'None';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.asciifile.a := 'String';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.refer := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.refer.d := 'Input reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.refer.def := 'J2000';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.refer.a := 'Any valid direction reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.format := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.format.d := 'Name of format (only ST supported)';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.format.def := 'ST';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.format.a := 'String';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.direction := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.direction.d := 'Direction measure (for relative coordinates)';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.direction.def := 'None';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.direction.a := 'Direction measure';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.spectrum := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.spectrum.d := 'Default spectrum field';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.spectrum.def := '[type="Constant", frequency=[type="frequency" , refer="LSR" , m0=[unit="GHz" , value=1.0]]';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.spectrum.a := 'Any valid spectrum field';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.flux := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.flux.d := 'Default flux field';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.flux.def := '[value=[0.0, 0.0, 0.0, 0.0], unit=\' Jy\' , polarization="Stokes"]';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.flux.a := 'Any valid flux field';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.c.asciitocomponentlist.s := 'asciitocomponentlist(filename, asciifile, refer, format, direction, spectrum, flux, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.d := 'Append components from another componentlist.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.list := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.list.d := 'list to copy from';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.list.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.list.a := 'a componentlist tool';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.which.d := 'which components to copy';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.which.def := 'unset';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.which.a := 'a integer or integer vector';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.concatenate.s := 'concatenate(list, which, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.d := 'Remove a component from the list.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.a.which.d := 'indices of which component(s) to remove';
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.a.which.a := 'a vector containing unique integers between                           1 and the length of the list';
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.remove.s := 'remove(which, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.purge := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.purge.d := 'Permanently delete removed components.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.purge.s := 'purge()';
help::pkg.synthesis.componentmodels.objs.componentlist.m.recover := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.recover.d := 'Obtain removed components.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.recover.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.recover.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.recover.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.recover.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.recover.s := 'recover(log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.length := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.length.d := 'Find the number of components in the list.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.length.s := 'length()';
help::pkg.synthesis.componentmodels.objs.componentlist.m.indices := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.indices.d := 'Return a vector of indices.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.indices.s := 'indices()';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.d := 'Sort the components in a list';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.a.criteria := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.a.criteria.d := 'a string containg the criteria to use to sort the list';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.a.criteria.def := 'Flux';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.a.criteria.a := '\' Flux\' , \' Position\'  or \' Polarization\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sort.s := 'sort(criteria, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.is_physical := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.is_physical.d := 'Check if a component is physically plausible';
help::pkg.synthesis.componentmodels.objs.componentlist.m.is_physical.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.is_physical.a.which.d := 'A vector of indices';
help::pkg.synthesis.componentmodels.objs.componentlist.m.is_physical.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.is_physical.a.which.a := 'Indices must be between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.is_physical.s := 'is_physical(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.d := 'Sample the flux of the list in a specified direction.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.direction := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.direction.d := 'The direction to sample';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.direction.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.direction.a := 'any valid direction measure.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.pixellatsize := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.pixellatsize.d := 'the x-size of the in pixels to use when sampling';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.pixellatsize.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.pixellatsize.a := 'any quantity that has angular units.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.pixellongsize := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.pixellongsize.d := 'the y-size of the in pixels to use when sampling';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.pixellongsize.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.pixellongsize.a := 'any quantity that has angular units.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.frequency := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.frequency.d := 'The frequency to sample at';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.frequency.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.a.frequency.a := 'Any frequency measure';
help::pkg.synthesis.componentmodels.objs.componentlist.m.sample.s := 'sample(direction, pixellatsize, pixellongsize, frequency)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.d := 'Give the list a name so it can save itself.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.a.filename := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.a.filename.d := 'The filename of the table';
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.a.filename.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.a.filename.a := 'Any valid filename';
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.rename.s := 'rename(filename, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.d := 'Add some simulated components to the list';
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.a.howmany := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.a.howmany.d := 'How many components to simulate';
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.a.howmany.def := '1';
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.a.howmany.a := 'A positive integer';
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.simulate.s := 'simulate(howmany, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.d := 'Add a component to the list';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.flux := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.flux.d := 'The flux value';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.flux.def := '[1,0,0,0]';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.flux.a := 'A vector with four real or complex numbers';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.fluxunit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.fluxunit.d := 'The units of the flux';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.fluxunit.def := 'Jy';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.fluxunit.a := 'Any string with the same dimensions as the Jansky';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.polarization := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.polarization.d := 'The polarization of the value field';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.polarization.def := 'Stokes';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.polarization.a := '``Stokes\' \' , ``linear\' \'  or ``circular\' \' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.ra := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.ra.d := 'The RA of the new direction';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.ra.def := '00:00:00.00';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.ra.a := 'A formatted string or a number';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.raunit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.raunit.d := 'The units of the RA';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.raunit.def := '\' time\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.raunit.a := 'Any string containing an angular unit or \' angle\'  or \' time\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.dec := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.dec.d := 'The declination of the new direction';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.dec.def := '\' 90.00.00.00\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.dec.a := 'A formatted string or a number';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.decunit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.decunit.d := 'The units of the declination';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.decunit.def := '\' time\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.decunit.a := 'Any string containing an angular unit or \' angle\'  or \' time\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.dirframe := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.dirframe.d := 'The new reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.dirframe.def := 'j2000';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.dirframe.a := 'A string like \' B1950\' , \' J2000\'  or \' galactic\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.shape := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.shape.d := 'The new shape type';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.shape.def := 'point';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.shape.a := 'A string that is either \' point\' , \' Gaussian\'  or \' disk\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.majoraxis := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.majoraxis.d := 'The width of the larger axis';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.majoraxis.def := '2arcmin';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.majoraxis.a := 'A quantity with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.minoraxis := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.minoraxis.d := 'The width of the smaller axis';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.minoraxis.def := '1arcmin';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.minoraxis.a := 'A quantity with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.positionangle := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.positionangle.d := 'The rotation of the axes with respect to                              the reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.positionangle.def := '0deg';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.positionangle.a := 'A quantity with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.freq := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.freq.d := 'The reference frequency';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.freq.def := '1.415GHz';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.freq.a := 'A quantity with units equivalent to the \' Hz\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.freqframe := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.freqframe.d := 'The new reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.freqframe.def := 'LSR';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.freqframe.a := 'A string like \' LSR\' , \' GEO\'  or \' TOPO';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.spectrumtype := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.spectrumtype.d := 'The new spectrum type';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.spectrumtype.def := 'constant';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.spectrumtype.a := 'A string that is either \' constant\'  or \' spectral index\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.index := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.index.d := 'The spectral indices';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.index.def := '[1,0,0,0]';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.index.a := 'A 4-element vector or real numbers';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.label := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.label.d := 'The label for the component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.label.def := 'The default label';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.a.label.a := 'A string';
help::pkg.synthesis.componentmodels.objs.componentlist.m.addcomponent.s := 'addcomponent(flux, fluxunit, polarization, ra, raunit, dec, decunit, dirframe, shape, majoraxis, minoraxis, positionangle, freq, freqframe, spectrumtype, index, label)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.close := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.close.d := 'Save the componentlist to disk and reset its state.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.close.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.close.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.close.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.close.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.close.s := 'close(log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.d := 'Start up the component editor gui';
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.edit.s := 'edit(which, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.done := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.done.d := 'Delete the componentlist tool';
help::pkg.synthesis.componentmodels.objs.componentlist.m.done.s := 'done()';
help::pkg.synthesis.componentmodels.objs.componentlist.m.select := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.select.d := 'Mark components in the list';
help::pkg.synthesis.componentmodels.objs.componentlist.m.select.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.select.a.which.d := 'A vector of indices';
help::pkg.synthesis.componentmodels.objs.componentlist.m.select.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.select.a.which.a := 'Indices must be between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.select.s := 'select(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.deselect := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.deselect.d := 'Unmark components in the list';
help::pkg.synthesis.componentmodels.objs.componentlist.m.deselect.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.deselect.a.which.d := 'A vector of indices';
help::pkg.synthesis.componentmodels.objs.componentlist.m.deselect.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.deselect.a.which.a := 'Indices must be between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.deselect.s := 'deselect(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.selected := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.selected.d := 'Determine which components are selected';
help::pkg.synthesis.componentmodels.objs.componentlist.m.selected.s := 'selected()';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getlabel := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getlabel.d := 'Get the label of the specified component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getlabel.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getlabel.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getlabel.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getlabel.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getlabel.s := 'getlabel(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.d := 'Set the label of the specified components';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.value := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.value.d := 'The label for the specified components';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.value.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.value.a := 'A string';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setlabel.s := 'setlabel(which, value, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxvalue := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxvalue.d := 'Get the flux value of the specified component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxvalue.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxvalue.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxvalue.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxvalue.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxvalue.s := 'getfluxvalue(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxunit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxunit.d := 'Get the flux unit of the specified component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxunit.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxunit.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxunit.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxunit.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxunit.s := 'getfluxunit(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxpol := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxpol.d := 'Get the polarization representation for the flux of the specified component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxpol.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxpol.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxpol.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxpol.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxpol.s := 'getfluxpol(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxerror := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxerror.d := 'Get the error in the flux of the specified component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxerror.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxerror.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxerror.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxerror.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfluxerror.s := 'getfluxerror(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.d := 'Set the flux of the specified components';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.value := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.value.d := 'The flux values for the specified components';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.value.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.value.a := 'A vector with four real or complex numbers';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.unit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.unit.d := 'The units of the flux';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.unit.def := 'Jy';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.unit.a := 'Any string with the same dimensions as the Jansky';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.polarization := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.polarization.d := 'The polarization of the value field';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.polarization.def := 'Stokes';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.polarization.a := '``Stokes\' \' , ``linear\' \'  or ``circular\' \' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.error := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.error.d := 'The error in the value field';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.error.def := '[0,0,0,0]';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.error.a := 'A complex vector of length four.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setflux.s := 'setflux(which, value, unit, polarization, error, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.d := 'Change (convert) the flux units of the specified components';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.a.unit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.a.unit.d := 'The units of the flux';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.a.unit.def := 'Jy';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.a.unit.a := 'Any string with the same dimensions as the Jansky';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxunit.s := 'convertfluxunit(which, unit)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.d := 'Change (convert) the polarization representation of the specified components';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.a.polarization := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.a.polarization.d := 'The new polarization representation';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.a.polarization.def := 'Stokes';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.a.polarization.a := '``Stokes\' \' , ``linear\' \'  or ``circular\' \' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfluxpol.s := 'convertfluxpol(which, polarization)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdir := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdir.d := 'Return the reference direction';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdir.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdir.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdir.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdir.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdir.s := 'getrefdir(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.d := 'Get the RA of the reference direction.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.unit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.unit.d := 'The angular unit of the returned value.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.unit.def := 'deg';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.unit.a := 'Any string containing an angular unit or \' angle\'  or \' time\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.precision := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.precision.d := 'The number of digits in the returned string.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.precision.def := '6';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.a.precision.a := 'Numbers between 1 and 16 make the most sense';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirra.s := 'getrefdirra(which, unit, precision)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.d := 'Get the declination of the reference direction.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.unit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.unit.d := 'The angular unit of the returned value.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.unit.def := 'deg';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.unit.a := 'Any string containing an angular unit or \' angle\'  or \' time\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.precision := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.precision.d := 'The number of digits in the returned string.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.precision.def := '6';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.a.precision.a := 'Numbers between 1 and 16 make the most sense';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirdec.s := 'getrefdirdec(which, unit, precision)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirframe := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirframe.d := 'Get the reference frame of the reference direction.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirframe.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirframe.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirframe.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirframe.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getrefdirframe.s := 'getrefdirframe(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.d := 'Set the reference direction';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.ra := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.ra.d := 'The RA of the new direction';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.ra.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.ra.a := 'A formatted string or a number';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.raunit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.raunit.d := 'The units of the RA';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.raunit.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.raunit.a := 'Any string containing an angular unit or \' angle\'  or \' time\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.dec := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.dec.d := 'The declination of the new direction';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.dec.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.dec.a := 'A formatted string or a number';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.decunit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.decunit.d := 'The units of the declination';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.decunit.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.decunit.a := 'Any string containing an angular unit or \' angle\'  or \' time\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdir.s := 'setrefdir(which, ra, raunit, dec, decunit, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.d := 'Set the reference frame for the direction';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.frame := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.frame.d := 'The new reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.frame.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.frame.a := 'A string like \' B1950\' , \' J2000\'  or \' galactic\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setrefdirframe.s := 'setrefdirframe(which, frame, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.d := 'Convert the reference direction to a new frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.a.frame := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.a.frame.d := 'The new reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.a.frame.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.a.frame.a := 'A string like \' B1950\' , \' J2000\'  or \' galactic\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertrefdir.s := 'convertrefdir(which, frame)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.shapetype := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.shapetype.d := 'Returns the shape type of the component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.shapetype.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.shapetype.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.shapetype.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.shapetype.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.shapetype.s := 'shapetype(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getshape := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getshape.d := 'Return the shape parameters the component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getshape.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getshape.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getshape.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getshape.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getshape.s := 'getshape(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.d := 'Change the shape of the component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.type := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.type.d := 'The new shape type';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.type.def := 'Point';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.type.a := 'A string that is either \' point\' , \' Gaussian\'  or \' disk\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.majoraxis := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.majoraxis.d := 'The width of the larger axis';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.majoraxis.def := '1arcmin';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.majoraxis.a := 'A quantity with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.minoraxis := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.minoraxis.d := 'The width of the smaller axis';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.minoraxis.def := '1arcmin';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.minoraxis.a := 'A quantity with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.positionangle := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.positionangle.d := 'The rotation of the axes with respect to                              the reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.positionangle.def := '0deg';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.positionangle.a := 'A quantity with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setshape.s := 'setshape(which, type, majoraxis, minoraxis, positionangle, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.d := 'Change the units of the shape parameters';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.majoraxis := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.majoraxis.d := 'The units to use on the larger axis';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.majoraxis.def := 'arcmin';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.majoraxis.a := 'A string with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.minoraxis := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.minoraxis.d := 'The units to use on the smaller axis';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.minoraxis.def := 'arcmin';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.minoraxis.a := 'A string with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.positionangle := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.positionangle.d := 'The units to use for the rotation of                              these axes';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.positionangle.def := 'deg';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.a.positionangle.a := 'A string with angular units';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertshape.s := 'convertshape(which, majoraxis, minoraxis, positionangle)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.spectrumtype := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.spectrumtype.d := 'Returns the spectral shape of the component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.spectrumtype.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.spectrumtype.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.spectrumtype.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.spectrumtype.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.spectrumtype.s := 'spectrumtype(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getspectrum := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getspectrum.d := 'Return the spectral parameters the component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getspectrum.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getspectrum.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getspectrum.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getspectrum.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getspectrum.s := 'getspectrum(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.d := 'Change the spectrum of the component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.type := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.type.d := 'The new spectrum type';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.type.def := 'Constant';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.type.a := 'A string that is either  			\' constant or \' spectral index\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.index := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.index.d := 'The spectral indices';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.index.def := '[1,0,0,0]';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.index.a := 'A 4-element vector or real numbers';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setspectrum.s := 'setspectrum(which, type, index, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreq := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreq.d := 'Get the reference frequency';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreq.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreq.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreq.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreq.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreq.s := 'getfreq(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqvalue := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqvalue.d := 'Get the reference frequency value';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqvalue.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqvalue.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqvalue.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqvalue.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqvalue.s := 'getfreqvalue(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfrequnit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfrequnit.d := 'Get the reference frequency unit';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfrequnit.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfrequnit.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfrequnit.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfrequnit.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfrequnit.s := 'getfrequnit(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqframe := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqframe.d := 'Get the reference frequency frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqframe.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqframe.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqframe.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqframe.a.which.a := 'An integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.getfreqframe.s := 'getfreqframe(which)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.d := 'Set the reference frequency';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.value := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.value.d := 'The new frequency value';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.value.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.value.a := 'A number';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.unit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.unit.d := 'The units of the frequency';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.unit.def := '\' GHz\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.unit.a := 'Any string with the same dimensions as the \' Hz\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreq.s := 'setfreq(which, value, unit, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.d := 'Set the reference frame for the frequency';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.frame := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.frame.d := 'The new reference frame';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.frame.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.frame.a := 'A string like \' LSR\' , \' GEO\'  or \' TOPO';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.log := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.log.d := 'Send a message to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.log.def := 'T';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.a.log.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.setfreqframe.s := 'setfreqframe(which, frame, log)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.d := 'Convert the reference frequency to a new unit';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.a.which.d := 'A vector of indices specifying the components to modify';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.a.unit := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.a.unit.d := 'The new frequency unit';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.a.unit.def := '\' GHz\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.a.unit.a := 'Any string with the same dimensions as the \' Hz\' ';
help::pkg.synthesis.componentmodels.objs.componentlist.m.convertfrequnit.s := 'convertfrequnit(which, unit)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.component := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.d := 'Extract a component from the list.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.a.which.d := 'index of which component to extract';
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.a.which.a := 'integers between 1 and the length of the list';
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.a.iknow := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.a.iknow.d := 'Suppress the warning message';
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.a.iknow.def := 'F';
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.a.iknow.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.component.s := 'component(which, iknow)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.add := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.d := 'Add a component to the list.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.a.component := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.a.component.d := 'A record that represents a component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.a.component.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.a.component.a := 'any record that contains the required fields';
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.a.iknow := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.a.iknow.d := 'Suppress the warning message';
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.a.iknow.def := 'F';
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.a.iknow.a := 'Boolean';
help::pkg.synthesis.componentmodels.objs.componentlist.m.add.s := 'add(component, iknow)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.d := 'Replace components in the list.';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.which.d := 'A vector of indices specifying the components to replace';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.which.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.which.a := 'A vector with indices between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.list := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.list.d := 'The list containing the components to copy';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.list.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.list.a := 'A componentlist tool';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.whichones := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.whichones.d := 'A vector of indices specifying the components to copy';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.whichones.def := 'F';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.a.whichones.a := 'A vector with indices between 1 and the length of the  list in the second argument';
help::pkg.synthesis.componentmodels.objs.componentlist.m.replace.s := 'replace(which, list, whichones)';
help::pkg.synthesis.componentmodels.objs.componentlist.m.print := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.print.d := 'Summarize the specified component to the logger';
help::pkg.synthesis.componentmodels.objs.componentlist.m.print.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componentlist.m.print.a.which.d := 'An index specifying which component';
help::pkg.synthesis.componentmodels.objs.componentlist.m.print.a.which.def := 'All components';
help::pkg.synthesis.componentmodels.objs.componentlist.m.print.a.which.a := 'Unset or an integer between 1 and the list length';
help::pkg.synthesis.componentmodels.objs.componentlist.m.print.s := 'print(which)';
help::pkg.synthesis.componentmodels.funs.is_componentlist := [=];
help::pkg.synthesis.componentmodels.funs.is_componentlist.a := [=];
help::pkg.synthesis.componentmodels.funs.is_componentlist.d := 'Is the argument a componentlist tool?';
help::pkg.synthesis.componentmodels.funs.is_componentlist.a.tool := [=];
help::pkg.synthesis.componentmodels.funs.is_componentlist.a.tool.d := 'The variable that you wish to test';
help::pkg.synthesis.componentmodels.funs.is_componentlist.a.tool.def := 'no default';
help::pkg.synthesis.componentmodels.funs.is_componentlist.a.tool.a := 'Any glish variable';
help::pkg.synthesis.componentmodels.funs.is_componentlist.s := 'is_componentlist(tool)';
help::pkg.synthesis.componentmodels.objs.componenteditor := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.c := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.d := 'A graphical user interface for displaying \& editing a component.';
help::pkg.synthesis.componentmodels.objs.componenteditor.c.componenteditor := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.c.componenteditor.d := 'Create an componenteditor tool';
help::pkg.synthesis.componentmodels.objs.componenteditor.c.componenteditor.s := 'componenteditor()';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.d := 'Supply a component to be edited';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.a.component := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.a.component.d := 'The component to be viewed and/or edited';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.a.component.def := 'no default';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.a.component.a := 'Any Glish record with the appropriate fields';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.a.which := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.a.which.d := 'The index of the component in a parent table';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.a.which.def := '0';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.a.which.a := 'Any integer (see description)';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.use.s := 'use(component, which)';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.gui := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m.gui.d := 'Start up the GUI';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.gui.s := 'gui()';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.dismiss := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m.dismiss.d := 'Shut down the GUI';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.dismiss.s := 'dismiss()';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.get := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m.get.d := 'get the component currently being edited';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.get.s := 'get()';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.which := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m.which.d := 'return the index of this component';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.which.s := 'which()';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.done := [=];
help::pkg.synthesis.componentmodels.objs.componenteditor.m.done.d := 'Shut down the componenteditor tool';
help::pkg.synthesis.componentmodels.objs.componenteditor.m.done.s := 'done()';

help::pkg.synthesis.imager := [=];
help::pkg.synthesis.imager.objs := [=];
help::pkg.synthesis.imager.funs := [=];
help::pkg.synthesis.imager.d := 'Module for synthesis and single dish imaging';
help::pkg.synthesis.imager.objs.imager := [=];
help::pkg.synthesis.imager.objs.imager.m := [=];
help::pkg.synthesis.imager.objs.imager.c := [=];
help::pkg.synthesis.imager.objs.imager.d := 'tool for synthesis imaging';
help::pkg.synthesis.imager.objs.imager.c.imager := [=];
help::pkg.synthesis.imager.objs.imager.c.imager.d := 'Construct an imager tool';
help::pkg.synthesis.imager.objs.imager.c.imager.a.filename := [=];
help::pkg.synthesis.imager.objs.imager.c.imager.a.filename.d := 'MeasurementSet to be imaged';
help::pkg.synthesis.imager.objs.imager.c.imager.a.filename.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.c.imager.a.filename.a := 'Table name';
help::pkg.synthesis.imager.objs.imager.c.imager.a.compress := [=];
help::pkg.synthesis.imager.objs.imager.c.imager.a.compress.d := 'Compress calibration columns?';
help::pkg.synthesis.imager.objs.imager.c.imager.a.compress.def := 'F';
help::pkg.synthesis.imager.objs.imager.c.imager.a.compress.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.c.imager.a.host := [=];
help::pkg.synthesis.imager.objs.imager.c.imager.a.host.d := 'Host on which to run imager';
help::pkg.synthesis.imager.objs.imager.c.imager.a.host.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.c.imager.a.host.a := 'String: \' \'  means localhost';
help::pkg.synthesis.imager.objs.imager.c.imager.a.forcenewserver := [=];
help::pkg.synthesis.imager.objs.imager.c.imager.a.forcenewserver.d := 'Flag to force a new imager client';
help::pkg.synthesis.imager.objs.imager.c.imager.a.forcenewserver.def := 'T';
help::pkg.synthesis.imager.objs.imager.c.imager.a.forcenewserver.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.c.imager.s := 'imager(filename, compress, host, forcenewserver)';
help::pkg.synthesis.imager.objs.imager.m.advise := [=];
help::pkg.synthesis.imager.objs.imager.m.advise.d := 'Advise (and optionally use) parameter values';
help::pkg.synthesis.imager.objs.imager.m.advise.a.takeadvice := [=];
help::pkg.synthesis.imager.objs.imager.m.advise.a.takeadvice.d := 'Use the advised values?';
help::pkg.synthesis.imager.objs.imager.m.advise.a.takeadvice.def := 'T';
help::pkg.synthesis.imager.objs.imager.m.advise.a.takeadvice.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.advise.a.amplitudeloss := [=];
help::pkg.synthesis.imager.objs.imager.m.advise.a.amplitudeloss.d := 'Maximum fractional amplitude loss due to faceting';
help::pkg.synthesis.imager.objs.imager.m.advise.a.amplitudeloss.def := '0.05';
help::pkg.synthesis.imager.objs.imager.m.advise.a.amplitudeloss.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.advise.a.fieldofview := [=];
help::pkg.synthesis.imager.objs.imager.m.advise.a.fieldofview.d := 'Desired field of view';
help::pkg.synthesis.imager.objs.imager.m.advise.a.fieldofview.def := '\' 1deg\' ';
help::pkg.synthesis.imager.objs.imager.m.advise.a.fieldofview.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.advise.a.pixels := [=];
help::pkg.synthesis.imager.objs.imager.m.advise.a.pixels.d := 'Number of pixels on a side';
help::pkg.synthesis.imager.objs.imager.m.advise.a.pixels.def := '';
help::pkg.synthesis.imager.objs.imager.m.advise.a.pixels.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.advise.a.cell := [=];
help::pkg.synthesis.imager.objs.imager.m.advise.a.cell.d := 'Recommended maximum cellsize';
help::pkg.synthesis.imager.objs.imager.m.advise.a.cell.def := '';
help::pkg.synthesis.imager.objs.imager.m.advise.a.cell.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.advise.a.facets := [=];
help::pkg.synthesis.imager.objs.imager.m.advise.a.facets.d := 'Recommended number of facets on one axis';
help::pkg.synthesis.imager.objs.imager.m.advise.a.facets.def := '';
help::pkg.synthesis.imager.objs.imager.m.advise.a.facets.a := 'Integer';
help::pkg.synthesis.imager.objs.imager.m.advise.a.phasecenter := [=];
help::pkg.synthesis.imager.objs.imager.m.advise.a.phasecenter.d := 'Direction of phase center as a measure';
help::pkg.synthesis.imager.objs.imager.m.advise.a.phasecenter.def := '';
help::pkg.synthesis.imager.objs.imager.m.advise.a.phasecenter.a := 'MDirection';
help::pkg.synthesis.imager.objs.imager.m.advise.s := 'advise(takeadvice, amplitudeloss, fieldofview, pixels, cell, facets, phasecenter)';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf := [=];
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.d := 'Calculate approximate point spread functions';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.model.d := 'Names of input models';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.model.def := '';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.model.a := 'Vector of Strings';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.psf := [=];
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.psf.d := 'Names of output point spread functions';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.psf.def := '';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.psf.a := 'Vector of Strings';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.approximatepsf.s := 'approximatepsf(model, psf, async)';
help::pkg.synthesis.imager.objs.imager.m.boxmask := [=];
help::pkg.synthesis.imager.objs.imager.m.boxmask.d := 'Construct a mask image from blc, trc';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.mask := [=];
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.mask.d := 'name of mask image';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.mask.def := '';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.mask.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.blc := [=];
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.blc.d := 'Bottom left corner';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.blc.def := '[1,1,1,1]';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.blc.a := 'Vector';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.trc := [=];
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.trc.d := 'Top right corner';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.trc.def := 'image shape';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.trc.a := 'Vector';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.value := [=];
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.value.d := 'Value to fill in';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.value.def := '1.0';
help::pkg.synthesis.imager.objs.imager.m.boxmask.a.value.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.boxmask.s := 'boxmask(mask, blc, trc, value)';
help::pkg.synthesis.imager.objs.imager.m.clean := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.d := 'Calculate a deconvolved image with selected clean algorithm';
help::pkg.synthesis.imager.objs.imager.m.clean.a.algorithm := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.algorithm.d := 'Algorithm to use';
help::pkg.synthesis.imager.objs.imager.m.clean.a.algorithm.def := '\' clark\' ';
help::pkg.synthesis.imager.objs.imager.m.clean.a.algorithm.a := 'String:\' clark\' |\' hogbom\' |\' multiscale\' |\' mfclark\' |\' csclean\' |\' csfast\' | \' mfhogbom\' |\' mfmultiscale\' |\' wfclark\' |\' wfhogbom\' ';
help::pkg.synthesis.imager.objs.imager.m.clean.a.niter := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.niter.d := 'Number of Iterations, set to zero for no CLEANing';
help::pkg.synthesis.imager.objs.imager.m.clean.a.niter.def := '1000';
help::pkg.synthesis.imager.objs.imager.m.clean.a.niter.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.clean.a.gain := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.gain.d := 'Loop Gain for CLEANing';
help::pkg.synthesis.imager.objs.imager.m.clean.a.gain.def := '0.1';
help::pkg.synthesis.imager.objs.imager.m.clean.a.gain.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.clean.a.threshold := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.threshold.d := 'Flux level at which to stop CLEANing';
help::pkg.synthesis.imager.objs.imager.m.clean.a.threshold.def := '\' 0Jy\' ';
help::pkg.synthesis.imager.objs.imager.m.clean.a.threshold.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.clean.a.displayprogress := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.displayprogress.d := 'Display the progress of the cleaning?';
help::pkg.synthesis.imager.objs.imager.m.clean.a.displayprogress.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.clean.a.displayprogress.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.clean.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.model.d := 'Names of clean model images';
help::pkg.synthesis.imager.objs.imager.m.clean.a.model.def := 'None';
help::pkg.synthesis.imager.objs.imager.m.clean.a.model.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.clean.a.fixed := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.fixed.d := 'Keep one or more models fixed';
help::pkg.synthesis.imager.objs.imager.m.clean.a.fixed.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.clean.a.fixed.a := 'Vector of booleans';
help::pkg.synthesis.imager.objs.imager.m.clean.a.complist := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.complist.d := 'Name of component list';
help::pkg.synthesis.imager.objs.imager.m.clean.a.complist.def := '';
help::pkg.synthesis.imager.objs.imager.m.clean.a.complist.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.clean.a.mask := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.mask.d := 'Names of mask images used for CLEANing';
help::pkg.synthesis.imager.objs.imager.m.clean.a.mask.def := '';
help::pkg.synthesis.imager.objs.imager.m.clean.a.mask.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.clean.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.image.d := 'Names of restored images';
help::pkg.synthesis.imager.objs.imager.m.clean.a.image.def := 'model name concatenated   with \' .restored\' ';
help::pkg.synthesis.imager.objs.imager.m.clean.a.image.a := 'Vector of strings or unset';
help::pkg.synthesis.imager.objs.imager.m.clean.a.residual := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.residual.d := 'Names of residual images';
help::pkg.synthesis.imager.objs.imager.m.clean.a.residual.def := 'model name concatenated   with \' .residual\' ';
help::pkg.synthesis.imager.objs.imager.m.clean.a.residual.a := 'Vector of strings or unset';
help::pkg.synthesis.imager.objs.imager.m.clean.a.interactive := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.interactive.d := 'whether to stop clean and interactively mask';
help::pkg.synthesis.imager.objs.imager.m.clean.a.interactive.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.clean.a.interactive.a := 'Boolean';
help::pkg.synthesis.imager.objs.imager.m.clean.a.npercycle := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.npercycle.d := 'If interactive is \' T\' , then no of iter of clean  before stopping, usually a fraction of niter';
help::pkg.synthesis.imager.objs.imager.m.clean.a.npercycle.def := '100';
help::pkg.synthesis.imager.objs.imager.m.clean.a.npercycle.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.clean.a.masktemplate := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.masktemplate.d := 'If non empty then will use this image to make the mask the first time';
help::pkg.synthesis.imager.objs.imager.m.clean.a.masktemplate.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.m.clean.a.masktemplate.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.clean.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.clean.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.imager.objs.imager.m.clean.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.clean.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.clean.s := 'clean(algorithm, niter, gain, threshold, displayprogress, model, fixed, complist, mask, image, residual, interactive, npercycle, masktemplate, async)';
help::pkg.synthesis.imager.objs.imager.m.clipimage := [=];
help::pkg.synthesis.imager.objs.imager.m.clipimage.d := 'Zero all pixels where Stokes I is below a threshold';
help::pkg.synthesis.imager.objs.imager.m.clipimage.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.clipimage.a.image.d := 'name of image';
help::pkg.synthesis.imager.objs.imager.m.clipimage.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.clipimage.a.image.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.clipimage.a.threshold := [=];
help::pkg.synthesis.imager.objs.imager.m.clipimage.a.threshold.d := 'Threshold';
help::pkg.synthesis.imager.objs.imager.m.clipimage.a.threshold.def := '\' 0Jy\' ';
help::pkg.synthesis.imager.objs.imager.m.clipimage.a.threshold.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.clipimage.s := 'clipimage(image, threshold)';
help::pkg.synthesis.imager.objs.imager.m.clipvis := [=];
help::pkg.synthesis.imager.objs.imager.m.clipvis.d := 'Flag visibilities where residual exceeds a threshold';
help::pkg.synthesis.imager.objs.imager.m.clipvis.a.threshold := [=];
help::pkg.synthesis.imager.objs.imager.m.clipvis.a.threshold.d := 'Threshold';
help::pkg.synthesis.imager.objs.imager.m.clipvis.a.threshold.def := '\' 0Jy\' ';
help::pkg.synthesis.imager.objs.imager.m.clipvis.a.threshold.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.clipvis.s := 'clipvis(threshold)';
help::pkg.synthesis.imager.objs.imager.m.close := [=];
help::pkg.synthesis.imager.objs.imager.m.close.d := 'Close the imager tool, with data written on disk, keeping imager process running for future use';
help::pkg.synthesis.imager.objs.imager.m.close.s := 'close()';
help::pkg.synthesis.imager.objs.imager.m.correct := [=];
help::pkg.synthesis.imager.objs.imager.m.correct.d := 'Correct the MeasurementSet for correctable effects';
help::pkg.synthesis.imager.objs.imager.m.correct.a.doparallactic := [=];
help::pkg.synthesis.imager.objs.imager.m.correct.a.doparallactic.d := 'Do the correction for parallactic angle?';
help::pkg.synthesis.imager.objs.imager.m.correct.a.doparallactic.def := 'T';
help::pkg.synthesis.imager.objs.imager.m.correct.a.doparallactic.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.correct.a.timestep := [=];
help::pkg.synthesis.imager.objs.imager.m.correct.a.timestep.d := 'Time step for corrections';
help::pkg.synthesis.imager.objs.imager.m.correct.a.timestep.def := '\' 10s\' ';
help::pkg.synthesis.imager.objs.imager.m.correct.a.timestep.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.correct.s := 'correct(doparallactic, timestep)';
help::pkg.synthesis.imager.objs.imager.m.done := [=];
help::pkg.synthesis.imager.objs.imager.m.done.d := 'Terminate the imager process';
help::pkg.synthesis.imager.objs.imager.m.done.s := 'done()';
help::pkg.synthesis.imager.objs.imager.m.exprmask := [=];
help::pkg.synthesis.imager.objs.imager.m.exprmask.d := 'Construct a mask image from a LEL expression';
help::pkg.synthesis.imager.objs.imager.m.exprmask.a.mask := [=];
help::pkg.synthesis.imager.objs.imager.m.exprmask.a.mask.d := 'name of mask image';
help::pkg.synthesis.imager.objs.imager.m.exprmask.a.mask.def := '';
help::pkg.synthesis.imager.objs.imager.m.exprmask.a.mask.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.exprmask.a.expr := [=];
help::pkg.synthesis.imager.objs.imager.m.exprmask.a.expr.d := 'Value to set the mask to';
help::pkg.synthesis.imager.objs.imager.m.exprmask.a.expr.def := '1.0';
help::pkg.synthesis.imager.objs.imager.m.exprmask.a.expr.a := 'Any scalar or LEL expression';
help::pkg.synthesis.imager.objs.imager.m.exprmask.s := 'exprmask(mask, expr)';
help::pkg.synthesis.imager.objs.imager.m.feather := [=];
help::pkg.synthesis.imager.objs.imager.m.feather.d := 'Feather together an interferometer and a single dish image in the Fourier plane';
help::pkg.synthesis.imager.objs.imager.m.feather.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.feather.a.image.d := 'Name of output feathered image';
help::pkg.synthesis.imager.objs.imager.m.feather.a.image.def := '\' feathered.image\' ';
help::pkg.synthesis.imager.objs.imager.m.feather.a.image.a := 'Image';
help::pkg.synthesis.imager.objs.imager.m.feather.a.highres := [=];
help::pkg.synthesis.imager.objs.imager.m.feather.a.highres.d := 'Name of high resolution (interferometer) image';
help::pkg.synthesis.imager.objs.imager.m.feather.a.highres.def := '';
help::pkg.synthesis.imager.objs.imager.m.feather.a.highres.a := 'Image';
help::pkg.synthesis.imager.objs.imager.m.feather.a.lowres := [=];
help::pkg.synthesis.imager.objs.imager.m.feather.a.lowres.d := 'Name of low resolution (single dish) image';
help::pkg.synthesis.imager.objs.imager.m.feather.a.lowres.def := '';
help::pkg.synthesis.imager.objs.imager.m.feather.a.lowres.a := 'Image';
help::pkg.synthesis.imager.objs.imager.m.feather.a.lowpsf := [=];
help::pkg.synthesis.imager.objs.imager.m.feather.a.lowpsf.d := 'Name of optional low resolution point spread function';
help::pkg.synthesis.imager.objs.imager.m.feather.a.lowpsf.def := '';
help::pkg.synthesis.imager.objs.imager.m.feather.a.lowpsf.a := 'Image';
help::pkg.synthesis.imager.objs.imager.m.feather.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.feather.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.feather.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.feather.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.feather.s := 'feather(image, highres, lowres, lowpsf, async)';
help::pkg.synthesis.imager.objs.imager.m.filter := [=];
help::pkg.synthesis.imager.objs.imager.m.filter.d := 'Apply additional weighting by filtering (u-v taper)';
help::pkg.synthesis.imager.objs.imager.m.filter.a.type := [=];
help::pkg.synthesis.imager.objs.imager.m.filter.a.type.d := 'Type of filtering or u-v tapering';
help::pkg.synthesis.imager.objs.imager.m.filter.a.type.def := 'gaussian';
help::pkg.synthesis.imager.objs.imager.m.filter.a.type.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bmaj := [=];
help::pkg.synthesis.imager.objs.imager.m.filter.a.bmaj.d := 'Major axis of filter';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bmaj.def := '\' 0rad\' ';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bmaj.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bmin := [=];
help::pkg.synthesis.imager.objs.imager.m.filter.a.bmin.d := 'Minor axis of filter';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bmin.def := '\' 0rad\' ';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bmin.a := 'Quantiy';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bpa := [=];
help::pkg.synthesis.imager.objs.imager.m.filter.a.bpa.d := 'Position angle of filter';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bpa.def := '\' 0deg\' ';
help::pkg.synthesis.imager.objs.imager.m.filter.a.bpa.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.filter.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.filter.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.filter.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.filter.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.filter.s := 'filter(type, bmaj, bmin, bpa, async)';
help::pkg.synthesis.imager.objs.imager.m.fitpsf := [=];
help::pkg.synthesis.imager.objs.imager.m.fitpsf.d := 'Fit the point spread function, making psf image first if needed';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.psf := [=];
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.psf.d := 'Name of input psf';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.psf.def := '';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.psf.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bmaj := [=];
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bmaj.d := 'Major axis of beam';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bmaj.def := '';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bmaj.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bmin := [=];
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bmin.d := 'Minor axis of beam';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bmin.def := '';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bmin.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bpa := [=];
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bpa.d := 'Position angle of beam';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bpa.def := '';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.bpa.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.fitpsf.s := 'fitpsf(psf, bmaj, bmin, bpa, async)';
help::pkg.synthesis.imager.objs.imager.m.ft := [=];
help::pkg.synthesis.imager.objs.imager.m.ft.d := 'Fourier transform the specified model and componentlist';
help::pkg.synthesis.imager.objs.imager.m.ft.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.ft.a.model.d := 'Name of image';
help::pkg.synthesis.imager.objs.imager.m.ft.a.model.def := '';
help::pkg.synthesis.imager.objs.imager.m.ft.a.model.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.ft.a.complist := [=];
help::pkg.synthesis.imager.objs.imager.m.ft.a.complist.d := 'Name of component list';
help::pkg.synthesis.imager.objs.imager.m.ft.a.complist.def := '';
help::pkg.synthesis.imager.objs.imager.m.ft.a.complist.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.ft.a.incremental := [=];
help::pkg.synthesis.imager.objs.imager.m.ft.a.incremental.d := 'Add to the existing MODEL\_DATA column?';
help::pkg.synthesis.imager.objs.imager.m.ft.a.incremental.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.ft.a.incremental.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.ft.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.ft.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.imager.objs.imager.m.ft.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.ft.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.ft.s := 'ft(model, complist, incremental, async)';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic := [=];
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.d := 'Make a linear mosaic of several images';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.images := [=];
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.images.d := 'Input images to be mosaiced';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.images.def := '';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.images.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.mosaic := [=];
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.mosaic.d := 'Output mosaic image';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.mosaic.def := '';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.mosaic.a := 'Image';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.fluxscale := [=];
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.fluxscale.d := 'Fluxscale image';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.fluxscale.def := '';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.fluxscale.a := 'Image';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.sensitivity := [=];
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.sensitivity.d := 'Sensitivity image';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.sensitivity.def := '';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.sensitivity.a := 'Image';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.fieldids := [=];
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.fieldids.d := 'output component list after PB has been applied [optional]';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.fieldids.def := '';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.fieldids.a := 'Vector of Ints';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.linearmosaic.s := 'linearmosaic(images, mosaic, fluxscale, sensitivity, fieldids, async)';
help::pkg.synthesis.imager.objs.imager.m.make := [=];
help::pkg.synthesis.imager.objs.imager.m.make.d := 'Make an empty (i.e. blank) image';
help::pkg.synthesis.imager.objs.imager.m.make.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.make.a.image.d := 'name of output image';
help::pkg.synthesis.imager.objs.imager.m.make.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.make.a.image.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.make.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.make.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.make.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.make.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.make.s := 'make(image, async)';
help::pkg.synthesis.imager.objs.imager.m.makeimage := [=];
help::pkg.synthesis.imager.objs.imager.m.makeimage.d := 'Calculate images by gridding, etc.';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.type := [=];
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.type.d := 'Type of output image';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.type.def := '\' observed\' ';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.type.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.image.d := 'Name of output image';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.image.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.compleximage := [=];
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.compleximage.d := 'Name of output complex image';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.compleximage.def := '';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.compleximage.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.makeimage.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.makeimage.s := 'makeimage(type, image, compleximage, async)';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd := [=];
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.d := 'Make stating model image from a     Single Dish image';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.sdimage := [=];
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.sdimage.d := 'Single Dish image';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.sdimage.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.sdimage.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.modelimage := [=];
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.modelimage.d := 'Name of output image to be used as model';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.modelimage.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.modelimage.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.sdpsf := [=];
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.sdpsf.d := 'PSF of Single Dish if needed';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.sdpsf.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.sdpsf.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.maskimage := [=];
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.maskimage.d := 'mask image';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.maskimage.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.a.maskimage.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.makemodelfromsd.s := 'makemodelfromsd(sdimage, modelimage, sdpsf, maskimage)';
help::pkg.synthesis.imager.objs.imager.m.mask := [=];
help::pkg.synthesis.imager.objs.imager.m.mask.d := 'Construct a mask image by thresholding an image';
help::pkg.synthesis.imager.objs.imager.m.mask.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.mask.a.image.d := 'name of template image';
help::pkg.synthesis.imager.objs.imager.m.mask.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.mask.a.image.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.mask.a.mask := [=];
help::pkg.synthesis.imager.objs.imager.m.mask.a.mask.d := 'name of mask image';
help::pkg.synthesis.imager.objs.imager.m.mask.a.mask.def := '';
help::pkg.synthesis.imager.objs.imager.m.mask.a.mask.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.mask.a.threshold := [=];
help::pkg.synthesis.imager.objs.imager.m.mask.a.threshold.d := 'threshold for mask';
help::pkg.synthesis.imager.objs.imager.m.mask.a.threshold.def := '\' 0.0Jy\' ';
help::pkg.synthesis.imager.objs.imager.m.mask.a.threshold.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.mask.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.mask.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.mask.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.mask.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.mask.s := 'mask(image, mask, threshold, async)';
help::pkg.synthesis.imager.objs.imager.m.mem := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.d := 'Calculate a deconvolved image with selected mem (maximum entropy) algorithm';
help::pkg.synthesis.imager.objs.imager.m.mem.a.algorithm := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.algorithm.d := 'Algorithm to use';
help::pkg.synthesis.imager.objs.imager.m.mem.a.algorithm.def := '\' entropy\' ';
help::pkg.synthesis.imager.objs.imager.m.mem.a.algorithm.a := 'String:\' entropy\' |\' emptiness\' |\' mfentropy\' |\' mfemptiness\' ';
help::pkg.synthesis.imager.objs.imager.m.mem.a.niter := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.niter.d := 'Number of Iterations';
help::pkg.synthesis.imager.objs.imager.m.mem.a.niter.def := '20';
help::pkg.synthesis.imager.objs.imager.m.mem.a.niter.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.mem.a.sigma := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.sigma.d := 'Image sigma to try to achieve';
help::pkg.synthesis.imager.objs.imager.m.mem.a.sigma.def := '\' 0.001Jy\' ';
help::pkg.synthesis.imager.objs.imager.m.mem.a.sigma.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.mem.a.targetflux := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.targetflux.d := 'Target flux for final image';
help::pkg.synthesis.imager.objs.imager.m.mem.a.targetflux.def := '\' 1.0Jy\' ';
help::pkg.synthesis.imager.objs.imager.m.mem.a.targetflux.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.mem.a.constrainflux := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.constrainflux.d := 'Constrain image to match target flux? else targetflux used only to initialize model';
help::pkg.synthesis.imager.objs.imager.m.mem.a.constrainflux.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.mem.a.constrainflux.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.mem.a.displayprogress := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.displayprogress.d := 'Display the progress of the cleaning?';
help::pkg.synthesis.imager.objs.imager.m.mem.a.displayprogress.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.mem.a.displayprogress.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.mem.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.model.d := 'Names of model images';
help::pkg.synthesis.imager.objs.imager.m.mem.a.model.def := '';
help::pkg.synthesis.imager.objs.imager.m.mem.a.model.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.mem.a.fixed := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.fixed.d := 'Keep model fixed';
help::pkg.synthesis.imager.objs.imager.m.mem.a.fixed.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.mem.a.fixed.a := 'Vector of booleans';
help::pkg.synthesis.imager.objs.imager.m.mem.a.complist := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.complist.d := 'Name of component list';
help::pkg.synthesis.imager.objs.imager.m.mem.a.complist.def := '';
help::pkg.synthesis.imager.objs.imager.m.mem.a.complist.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.mem.a.prior := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.prior.d := 'Names of mem prior images';
help::pkg.synthesis.imager.objs.imager.m.mem.a.prior.def := '';
help::pkg.synthesis.imager.objs.imager.m.mem.a.prior.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.mem.a.mask := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.mask.d := 'Names of mask images (0=>no emission, 1=>emission permitted';
help::pkg.synthesis.imager.objs.imager.m.mem.a.mask.def := '';
help::pkg.synthesis.imager.objs.imager.m.mem.a.mask.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.mem.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.image.d := 'Names of restored images';
help::pkg.synthesis.imager.objs.imager.m.mem.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.mem.a.image.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.mem.a.residual := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.residual.d := 'Names of residual images';
help::pkg.synthesis.imager.objs.imager.m.mem.a.residual.def := '';
help::pkg.synthesis.imager.objs.imager.m.mem.a.residual.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.mem.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.mem.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.imager.objs.imager.m.mem.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.mem.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.mem.s := 'mem(algorithm, niter, sigma, targetflux, constrainflux, displayprogress, model, fixed, complist, prior, mask, image, residual, async)';
help::pkg.synthesis.imager.objs.imager.m.nnls := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.d := 'Calculate a deconvolved image using the  NNLS algorithm';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.model.d := 'Name of image';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.model.def := '';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.model.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.fixed := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.fixed.d := 'Keep model fixed';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.fixed.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.fixed.a := 'Vector of booleans';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.complist := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.complist.d := 'Name of component list';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.complist.def := '';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.complist.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.niter := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.niter.d := 'Number of Iterations, set to zero for no NNLS';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.niter.def := '0';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.niter.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.tolerance := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.tolerance.d := 'Tolerance for solution';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.tolerance.def := '1e-06';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.tolerance.a := 'Double';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.fluxmask := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.fluxmask.d := 'Name of mask for allowed flux';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.fluxmask.def := '';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.fluxmask.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.datamask := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.datamask.d := 'Name of mask for constraint pixels in dirty image';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.datamask.def := '';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.datamask.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.image.d := 'Names of restored images';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.image.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.residual := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.residual.d := 'Names of restored images';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.residual.def := '';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.residual.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.nnls.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.nnls.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.nnls.s := 'nnls(model, fixed, complist, niter, tolerance, fluxmask, datamask, image, residual, async)';
help::pkg.synthesis.imager.objs.imager.m.open := [=];
help::pkg.synthesis.imager.objs.imager.m.open.d := 'Open a new MeasurementSet, for processing, closing current MeasurementSet';
help::pkg.synthesis.imager.objs.imager.m.open.a.thems := [=];
help::pkg.synthesis.imager.objs.imager.m.open.a.thems.d := 'New MeasurementSet to be processed';
help::pkg.synthesis.imager.objs.imager.m.open.a.thems.def := '\' MS\' ';
help::pkg.synthesis.imager.objs.imager.m.open.a.thems.a := 'Table name';
help::pkg.synthesis.imager.objs.imager.m.open.a.compress := [=];
help::pkg.synthesis.imager.objs.imager.m.open.a.compress.d := 'Compress calibration columns?';
help::pkg.synthesis.imager.objs.imager.m.open.a.compress.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.open.a.compress.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.open.s := 'open(thems, compress)';
help::pkg.synthesis.imager.objs.imager.m.pb := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.d := 'Applies or corrects for a primary beam';
help::pkg.synthesis.imager.objs.imager.m.pb.a.inimage := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.inimage.d := 'Input image to apply beam to';
help::pkg.synthesis.imager.objs.imager.m.pb.a.inimage.def := 'None';
help::pkg.synthesis.imager.objs.imager.m.pb.a.inimage.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.pb.a.outimage := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.outimage.d := 'Output image after beam is applied';
help::pkg.synthesis.imager.objs.imager.m.pb.a.outimage.def := 'No output image';
help::pkg.synthesis.imager.objs.imager.m.pb.a.outimage.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.pb.a.incomps := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.incomps.d := 'Input Componentlist table name';
help::pkg.synthesis.imager.objs.imager.m.pb.a.incomps.def := 'None';
help::pkg.synthesis.imager.objs.imager.m.pb.a.incomps.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.pb.a.outcomps := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.outcomps.d := 'Output Componentlist table name';
help::pkg.synthesis.imager.objs.imager.m.pb.a.outcomps.def := 'No output Componentlist';
help::pkg.synthesis.imager.objs.imager.m.pb.a.outcomps.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.pb.a.operation := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.operation.d := 'Operation';
help::pkg.synthesis.imager.objs.imager.m.pb.a.operation.def := '\' apply\' ';
help::pkg.synthesis.imager.objs.imager.m.pb.a.operation.a := 'String from \' apply\'  or \' correct\' ';
help::pkg.synthesis.imager.objs.imager.m.pb.a.pointingcenter := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.pointingcenter.d := 'Pointing center for primary beam application';
help::pkg.synthesis.imager.objs.imager.m.pb.a.pointingcenter.def := 'F in CLI or the N. pole in the GUI';
help::pkg.synthesis.imager.objs.imager.m.pb.a.pointingcenter.a := 'F or Direction measure';
help::pkg.synthesis.imager.objs.imager.m.pb.a.parangle := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.parangle.d := 'Parallactic angle for calculation';
help::pkg.synthesis.imager.objs.imager.m.pb.a.parangle.def := '\' 0deg\' ';
help::pkg.synthesis.imager.objs.imager.m.pb.a.parangle.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.pb.a.pborvp := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.pborvp.d := 'Primary Beam or Voltage Pattern ';
help::pkg.synthesis.imager.objs.imager.m.pb.a.pborvp.def := '\' pb\' ';
help::pkg.synthesis.imager.objs.imager.m.pb.a.pborvp.a := 'String from \' pb\'  or \' vp\' ';
help::pkg.synthesis.imager.objs.imager.m.pb.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.pb.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.pb.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.pb.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.pb.s := 'pb(inimage, outimage, incomps, outcomps, operation, pointingcenter, parangle, pborvp, async)';
help::pkg.synthesis.imager.objs.imager.m.pixon := [=];
help::pkg.synthesis.imager.objs.imager.m.pixon.d := 'Calculate a deconvolved image with the pixon algorithm ({\em experimental})';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.algorithm := [=];
help::pkg.synthesis.imager.objs.imager.m.pixon.a.algorithm.d := 'Algorithm to use';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.algorithm.def := '\' singledish\' ';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.algorithm.a := 'String:\' singledish\' |\' synthesis\' |\' test\' ';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.sigma := [=];
help::pkg.synthesis.imager.objs.imager.m.pixon.a.sigma.d := 'Image sigma to try to achieve';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.sigma.def := '\' 0.001Jy\' ';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.sigma.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.pixon.a.model.d := 'Name of model image';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.model.def := '';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.model.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.pixon.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.pixon.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.pixon.s := 'pixon(algorithm, sigma, model, async)';
help::pkg.synthesis.imager.objs.imager.m.plotsummary := [=];
help::pkg.synthesis.imager.objs.imager.m.plotsummary.d := 'Plot a summary of field and spectral window  ids';
help::pkg.synthesis.imager.objs.imager.m.plotsummary.s := 'plotsummary()';
help::pkg.synthesis.imager.objs.imager.m.plotuv := [=];
help::pkg.synthesis.imager.objs.imager.m.plotuv.d := 'Plot the uv coverage';
help::pkg.synthesis.imager.objs.imager.m.plotuv.a.rotate := [=];
help::pkg.synthesis.imager.objs.imager.m.plotuv.a.rotate.d := 'Rotate uvw coordinates to specified phase center?';
help::pkg.synthesis.imager.objs.imager.m.plotuv.a.rotate.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.plotuv.a.rotate.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.plotuv.s := 'plotuv(rotate)';
help::pkg.synthesis.imager.objs.imager.m.plotvis := [=];
help::pkg.synthesis.imager.objs.imager.m.plotvis.d := 'Plot the visibility amplitudes as a function of u-v radius (also, see visplot tool';
help::pkg.synthesis.imager.objs.imager.m.plotvis.a.type := [=];
help::pkg.synthesis.imager.objs.imager.m.plotvis.a.type.d := 'Type of plot: can contain all, observed, corrected, model, residual';
help::pkg.synthesis.imager.objs.imager.m.plotvis.a.type.def := 'all';
help::pkg.synthesis.imager.objs.imager.m.plotvis.a.type.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.plotvis.a.increment := [=];
help::pkg.synthesis.imager.objs.imager.m.plotvis.a.increment.d := 'Increment in points to plot';
help::pkg.synthesis.imager.objs.imager.m.plotvis.a.increment.def := '1';
help::pkg.synthesis.imager.objs.imager.m.plotvis.a.increment.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.plotvis.s := 'plotvis(type, increment)';
help::pkg.synthesis.imager.objs.imager.m.plotweights := [=];
help::pkg.synthesis.imager.objs.imager.m.plotweights.d := 'Plot the visibility weights as a function of u-v radius';
help::pkg.synthesis.imager.objs.imager.m.plotweights.a.gridded := [=];
help::pkg.synthesis.imager.objs.imager.m.plotweights.a.gridded.d := 'Do gridded plot?';
help::pkg.synthesis.imager.objs.imager.m.plotweights.a.gridded.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.plotweights.a.gridded.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.plotweights.a.increment := [=];
help::pkg.synthesis.imager.objs.imager.m.plotweights.a.increment.d := 'Increment in points to plot';
help::pkg.synthesis.imager.objs.imager.m.plotweights.a.increment.def := '1';
help::pkg.synthesis.imager.objs.imager.m.plotweights.a.increment.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.plotweights.s := 'plotweights(gridded, increment)';
help::pkg.synthesis.imager.objs.imager.m.regionmask := [=];
help::pkg.synthesis.imager.objs.imager.m.regionmask.d := 'Construct a mask image from a region';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.mask := [=];
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.mask.d := 'name of mask image';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.mask.def := '';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.mask.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.region := [=];
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.region.d := 'Region';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.region.def := 'unset';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.region.a := 'Any valid region or a record of regions';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.value := [=];
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.value.d := 'Value to set the mask to';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.value.def := '1.0';
help::pkg.synthesis.imager.objs.imager.m.regionmask.a.value.a := 'Any scalar';
help::pkg.synthesis.imager.objs.imager.m.regionmask.s := 'regionmask(mask, region, value)';
help::pkg.synthesis.imager.objs.imager.m.residual := [=];
help::pkg.synthesis.imager.objs.imager.m.residual.d := 'Calculate the residual image with respect to current model and component list';
help::pkg.synthesis.imager.objs.imager.m.residual.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.residual.a.model.d := 'Names of input models';
help::pkg.synthesis.imager.objs.imager.m.residual.a.model.def := '';
help::pkg.synthesis.imager.objs.imager.m.residual.a.model.a := 'Vector of Strings';
help::pkg.synthesis.imager.objs.imager.m.residual.a.complist := [=];
help::pkg.synthesis.imager.objs.imager.m.residual.a.complist.d := 'Name of component list';
help::pkg.synthesis.imager.objs.imager.m.residual.a.complist.def := '';
help::pkg.synthesis.imager.objs.imager.m.residual.a.complist.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.residual.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.residual.a.image.d := 'Names of output residual images';
help::pkg.synthesis.imager.objs.imager.m.residual.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.residual.a.image.a := 'Vector of Strings';
help::pkg.synthesis.imager.objs.imager.m.residual.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.residual.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.residual.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.residual.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.residual.s := 'residual(model, complist, image, async)';
help::pkg.synthesis.imager.objs.imager.m.restore := [=];
help::pkg.synthesis.imager.objs.imager.m.restore.d := 'Calculate the restored image with restored model, component list, and  residuals';
help::pkg.synthesis.imager.objs.imager.m.restore.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.restore.a.model.d := 'Names of input model';
help::pkg.synthesis.imager.objs.imager.m.restore.a.model.def := '';
help::pkg.synthesis.imager.objs.imager.m.restore.a.model.a := 'Vector of Strings';
help::pkg.synthesis.imager.objs.imager.m.restore.a.complist := [=];
help::pkg.synthesis.imager.objs.imager.m.restore.a.complist.d := 'Name of component list';
help::pkg.synthesis.imager.objs.imager.m.restore.a.complist.def := '';
help::pkg.synthesis.imager.objs.imager.m.restore.a.complist.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.restore.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.restore.a.image.d := 'Names of output restored images';
help::pkg.synthesis.imager.objs.imager.m.restore.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.restore.a.image.a := 'Vector of Strings';
help::pkg.synthesis.imager.objs.imager.m.restore.a.residual := [=];
help::pkg.synthesis.imager.objs.imager.m.restore.a.residual.d := 'Names of residual images';
help::pkg.synthesis.imager.objs.imager.m.restore.a.residual.def := '';
help::pkg.synthesis.imager.objs.imager.m.restore.a.residual.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.restore.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.restore.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.restore.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.restore.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.restore.s := 'restore(model, complist, image, residual, async)';
help::pkg.synthesis.imager.objs.imager.m.sensitivity := [=];
help::pkg.synthesis.imager.objs.imager.m.sensitivity.d := 'Calculate rms  sensitivity';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.pointsource := [=];
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.pointsource.d := 'Calculated point source sensitivity (Jy/beam)';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.pointsource.def := '';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.pointsource.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.relative := [=];
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.relative.d := 'Calculated relative sensitivity';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.relative.def := '';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.relative.a := 'Double';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.sumweights := [=];
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.sumweights.d := 'Calculated sum of weights';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.sumweights.def := '';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.sumweights.a := 'Double';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.sensitivity.s := 'sensitivity(pointsource, relative, sumweights, async)';
help::pkg.synthesis.imager.objs.imager.m.setbeam := [=];
help::pkg.synthesis.imager.objs.imager.m.setbeam.d := 'Set the beam parameters for clean restoration';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bmaj := [=];
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bmaj.d := 'Major axis of beam';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bmaj.def := '';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bmaj.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bmin := [=];
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bmin.d := 'Minor axis of beam';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bmin.def := '';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bmin.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bpa := [=];
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bpa.d := 'Position angle of beam';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bpa.def := '';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.bpa.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.setbeam.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.setbeam.s := 'setbeam(bmaj, bmin, bpa, async)';
help::pkg.synthesis.imager.objs.imager.m.setdata := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.d := 'Set the data parameters selection for subsequent processing';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.msname := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.msname.d := 'ms to be used for this selection ONLY when no ms is   used at contruction';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.msname.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.msname.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mode := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mode.d := 'Type of processing: channel or velocity';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mode.def := '';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mode.a := '\' none\' | \' channel\' ';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.nchan := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.nchan.d := 'Number of channels to select';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.nchan.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.nchan.a := 'Vector of Ints';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.start := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.start.d := 'Start channels (1-relative)';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.start.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.start.a := ' Vector of Ints';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.step := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.step.d := 'Step in channel number';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.step.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.step.a := 'Vector of Int';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mstart := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mstart.d := 'Start velocity (e.g. \' 20Km/s\' )';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mstart.def := '\' 0km/s\' ';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mstart.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mstep := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mstep.d := 'Step in velocity (e.g. \' 100m/s\' ';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mstep.def := '\' 0km/s\' ';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.mstep.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.spwid := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.spwid.d := 'Spectral Window Ids (1 relative) to select';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.spwid.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.spwid.a := 'Vector of Ints';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.fieldid := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.fieldid.d := 'Field Ids (1 relative) to select';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.fieldid.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.fieldid.a := 'Vector of Ints';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.msselect := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.msselect.d := 'TQL select string applied as a logical "and" with the other selections';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.msselect.def := '';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.msselect.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.setdata.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.setdata.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.setdata.s := 'setdata(msname, mode, nchan, start, step, mstart, mstep, spwid, fieldid, msselect, async)';
help::pkg.synthesis.imager.objs.imager.m.setimage := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.d := 'Set the image parameters for subsequent processing';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.nx := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.nx.d := 'Total number of spatial pixels in x';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.nx.def := '128';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.nx.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.ny := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.ny.d := 'Total number of spatial pixels in y';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.ny.def := '128';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.ny.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.cellx := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.cellx.d := 'Cellsize in x (e.g. \' 1arcsec\' )';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.cellx.def := '\' 1arcsec\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.cellx.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.celly := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.celly.d := 'Cellsize in y (e.g. \' 1arcsec\' )';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.celly.def := '\' 1arcsec\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.celly.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.stokes := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.stokes.d := 'Stokes parameters to image (e.g. \' IQUV\' )';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.stokes.def := '\' I\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.stokes.a := '\' I\' |\' IV\' |\' IQU\' |\' IQUV\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.doshift := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.doshift.d := 'Use the specified phase center? T or F';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.doshift.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.doshift.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.phasecenter := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.phasecenter.d := 'Direction of phase center as a measure';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.phasecenter.def := '';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.phasecenter.a := 'MDirection';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.shiftx := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.shiftx.d := 'Shift in x (e.g. \' 23.7arcsec\' )';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.shiftx.def := '\' 0arcsec\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.shiftx.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.shifty := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.shifty.d := 'Shift in y (e.g. \' -54.2arcsec\' )';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.shifty.def := '\' 0arcsec\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.shifty.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mode := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mode.d := 'Type of processing';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mode.def := '\' mfs\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mode.a := '\' mfs\' |\' channel\' |\' velocity\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.nchan := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.nchan.d := 'Number of channels';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.nchan.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.nchan.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.start := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.start.d := 'Start channel (1-relative)';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.start.def := '';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.start.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.step := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.step.d := 'Step in channel';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.step.def := '';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.step.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mstart := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mstart.d := 'Start velocity';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mstart.def := '';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mstart.a := 'MRadialVelocity';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mstep := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mstep.d := 'Step in velocity';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mstep.def := '';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.mstep.a := 'MRadialVelocity';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.spwid := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.spwid.d := 'Spectral Window Ids (1 relative)';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.spwid.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.spwid.a := 'Vector of Ints';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.fieldid := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.fieldid.d := 'Field Id (1 relative)';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.fieldid.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.fieldid.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.facets := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.facets.d := 'Number of facets on each axis';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.facets.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.facets.a := 'Integer';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.distance := [=];
help::pkg.synthesis.imager.objs.imager.m.setimage.a.distance.d := 'Distance to object: usually ignore this! (m)';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.distance.def := '\' 0m\' ';
help::pkg.synthesis.imager.objs.imager.m.setimage.a.distance.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.setimage.s := 'setimage(nx, ny, cellx, celly, stokes, doshift, phasecenter, shiftx, shifty, mode, nchan, start, step, mstart, mstep, spwid, fieldid, facets, distance)';
help::pkg.synthesis.imager.objs.imager.m.setjy := [=];
help::pkg.synthesis.imager.objs.imager.m.setjy.d := 'Compute the model visibility for a specified source flux density';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.fieldid := [=];
help::pkg.synthesis.imager.objs.imager.m.setjy.a.fieldid.d := 'Field Id (1-relative)';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.fieldid.def := '-1';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.fieldid.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.spwid := [=];
help::pkg.synthesis.imager.objs.imager.m.setjy.a.spwid.d := 'Spectral Window Id. (1-relative)';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.spwid.def := '-1';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.spwid.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.fluxdensity := [=];
help::pkg.synthesis.imager.objs.imager.m.setjy.a.fluxdensity.d := 'Specified flux density (I,Q,U,V) in Jy';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.fluxdensity.def := '-1 (lookup the value; use 1.0 if not found)';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.fluxdensity.a := 'Vector of Doubles';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.standard := [=];
help::pkg.synthesis.imager.objs.imager.m.setjy.a.standard.d := 'Flux density standard';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.standard.def := '';
help::pkg.synthesis.imager.objs.imager.m.setjy.a.standard.a := 'String:\' Baars\' |\' Perley 90\' |\' Perley-Taylor 95\' |\' Perley-Taylor 99\' |\' SOURCE\' ';
help::pkg.synthesis.imager.objs.imager.m.setjy.s := 'setjy(fieldid, spwid, fluxdensity, standard)';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.d := 'Set various cycle control parameters for  multi-field and wide-field imageing.';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.cyclefactor := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.cyclefactor.d := 'Cycle threshold = this * max sidelobe * max resid';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.cyclefactor.def := '1.5';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.cyclefactor.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.cyclespeedup := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.cyclespeedup.d := 'Cycle threshold doubles in this number of iterations';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.cyclespeedup.def := '-1';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.cyclespeedup.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.stoplargenegatives := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.stoplargenegatives.d := 'Stop the multiscale cycle for the first n cycles when a negative comp is found on the largest scale';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.stoplargenegatives.def := '2';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.stoplargenegatives.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.stoppointmode := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.stoppointmode.d := 'Stop multiscale altogether if the smallest   scale recieves this many consecutive components';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.stoppointmode.def := '-1';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.stoppointmode.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.minpb := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.minpb.d := 'Minimum PB level to use';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.minpb.def := '0.1';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.minpb.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.scaletype := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.scaletype.d := 'Image plane flux scale type';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.scaletype.def := '\' NONE\' ';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.scaletype.a := 'String:\' NONE\' |\' SAULT\' ';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.constpb := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.constpb.d := 'In Sault weighting the flux scale is constant above this PB level';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.constpb.def := '0.4';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.constpb.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.fluxscale := [=];
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.fluxscale.d := 'Names of flux scale images for mosaicing';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.fluxscale.def := '';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.a.fluxscale.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.imager.m.setmfcontrol.s := 'setmfcontrol(cyclefactor, cyclespeedup, stoplargenegatives, stoppointmode, minpb, scaletype, constpb, fluxscale)';
help::pkg.synthesis.imager.objs.imager.m.setoptions := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.d := 'Set some general options for subsequent processing';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.ftmachine := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.ftmachine.d := 'Fourier transform   machine';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.ftmachine.def := '\' ft\' ';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.ftmachine.a := 'String:\' ft\' |\' sd\' |\' both\'  | \' wfmemoryft\' | \' wproject\'  |\' mosaic\' ';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.cache := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.cache.d := 'Size of gridding cache in complex pixels';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.cache.def := '4194304';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.cache.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.tile := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.tile.d := 'Size of a gridding tile in pixels (in 1 dimension)';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.tile.def := '16';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.tile.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.gridfunction := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.gridfunction.d := 'Gridding function';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.gridfunction.def := '\' SF\' ';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.gridfunction.a := 'String: \' SF\' |\' BOX\' |\' PB\' ';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.location := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.location.d := 'Location used in phase rotations';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.location.def := '';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.location.a := 'position measure';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.padding := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.padding.d := 'Padding factor in image plane (>=1.0)';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.padding.def := '1.0';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.padding.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.usemodelcol := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.usemodelcol.d := 'use MODEL\_DATA column or not';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.usemodelcol.def := 'T';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.usemodelcol.a := 'boolean';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.wprojplanes := [=];
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.wprojplanes.d := 'No of gridding convolution functions used in   wproject-ft machine';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.wprojplanes.def := '1';
help::pkg.synthesis.imager.objs.imager.m.setoptions.a.wprojplanes.a := 'Integer';
help::pkg.synthesis.imager.objs.imager.m.setoptions.s := 'setoptions(ftmachine, cache, tile, gridfunction, location, padding, usemodelcol, wprojplanes)';
help::pkg.synthesis.imager.objs.imager.m.setscales := [=];
help::pkg.synthesis.imager.objs.imager.m.setscales.d := 'Set the scale sizes for MultiScale Clean';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.scalemethod := [=];
help::pkg.synthesis.imager.objs.imager.m.setscales.a.scalemethod.d := 'Method by which scales are set';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.scalemethod.def := 'nscales';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.scalemethod.a := 'String: \' nscales\' |\' uservector\' ';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.nscales := [=];
help::pkg.synthesis.imager.objs.imager.m.setscales.a.nscales.d := 'Number of scales';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.nscales.def := '5';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.nscales.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.uservector := [=];
help::pkg.synthesis.imager.objs.imager.m.setscales.a.uservector.d := 'Vector of scale sizes in pixels to use';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.uservector.def := '[0, 3, 10]';
help::pkg.synthesis.imager.objs.imager.m.setscales.a.uservector.a := 'Vector of Doubles';
help::pkg.synthesis.imager.objs.imager.m.setscales.s := 'setscales(scalemethod, nscales, uservector)';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions := [=];
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.d := 'Set some options for single dish processing';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.scale := [=];
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.scale.d := 'Scaling applied to single dish data';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.scale.def := '1.0';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.scale.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.weight := [=];
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.weight.d := 'Weights applied to single dish data';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.weight.def := '1.0';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.weight.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.convsupport := [=];
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.convsupport.d := 'number of pixel for convolution support';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.convsupport.def := '-1';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.a.convsupport.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.setsdoptions.s := 'setsdoptions(scale, weight, convsupport)';
help::pkg.synthesis.imager.objs.imager.m.setvp := [=];
help::pkg.synthesis.imager.objs.imager.m.setvp.d := 'Set the voltage pattern model for subsequent processing';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.dovp := [=];
help::pkg.synthesis.imager.objs.imager.m.setvp.a.dovp.d := 'Do voltage pattern (ie, primary beam) correction';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.dovp.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.dovp.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.usedefaultvp := [=];
help::pkg.synthesis.imager.objs.imager.m.setvp.a.usedefaultvp.d := 'Look up the default VP for this telescope and frequency?';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.usedefaultvp.def := 'T';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.usedefaultvp.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.vptable := [=];
help::pkg.synthesis.imager.objs.imager.m.setvp.a.vptable.d := 'If usedefaultvp is false, provide a VP Table made with vpmanager';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.vptable.def := '';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.vptable.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.dosquint := [=];
help::pkg.synthesis.imager.objs.imager.m.setvp.a.dosquint.d := 'Activate the beam squint in the VP model';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.dosquint.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.dosquint.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.parangleinc := [=];
help::pkg.synthesis.imager.objs.imager.m.setvp.a.parangleinc.d := 'Parallactice angle increment for squint   application';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.parangleinc.def := '360deg';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.parangleinc.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.telescope := [=];
help::pkg.synthesis.imager.objs.imager.m.setvp.a.telescope.d := 'Which default telescope to use; if empty use the   one in encoded in MS ';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.telescope.def := '\' \' ';
help::pkg.synthesis.imager.objs.imager.m.setvp.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.imager.m.setvp.s := 'setvp(dovp, usedefaultvp, vptable, dosquint, parangleinc, telescope)';
help::pkg.synthesis.imager.objs.imager.m.smooth := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.d := 'Calculate an image smoothed with a Gaussian beam';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.model := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.a.model.d := 'Name of input model';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.model.def := '';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.model.a := 'Vector of Strings';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.image := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.a.image.d := 'Name of output smoothed images';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.image.def := '';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.image.a := 'Vector of Strings';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.usefit := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.a.usefit.d := 'Use the fitted value (rather than that specified';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.usefit.def := 'T';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.usefit.a := 'Boolean';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bmaj := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bmaj.d := 'Major axis of beam';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bmaj.def := '';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bmaj.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bmin := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bmin.d := 'Minor axis of beam';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bmin.def := '';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bmin.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bpa := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bpa.d := 'Position angle of beam';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bpa.def := '';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.bpa.a := 'Quantity record';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.normalize := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.a.normalize.d := 'Normalize volume of psf to unity';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.normalize.def := 'T';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.normalize.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.smooth.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.smooth.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.smooth.s := 'smooth(model, image, usefit, bmaj, bmin, bpa, normalize, async)';
help::pkg.synthesis.imager.objs.imager.m.stop := [=];
help::pkg.synthesis.imager.objs.imager.m.stop.d := 'stop the currently executing function asap';
help::pkg.synthesis.imager.objs.imager.m.stop.s := 'stop()';
help::pkg.synthesis.imager.objs.imager.m.summary := [=];
help::pkg.synthesis.imager.objs.imager.m.summary.d := 'Summarize the current state of the imager tool';
help::pkg.synthesis.imager.objs.imager.m.summary.s := 'summary()';
help::pkg.synthesis.imager.objs.imager.m.uvrange := [=];
help::pkg.synthesis.imager.objs.imager.m.uvrange.d := 'Select data within the limit of a given range';
help::pkg.synthesis.imager.objs.imager.m.uvrange.a.uvmin := [=];
help::pkg.synthesis.imager.objs.imager.m.uvrange.a.uvmin.d := 'Minimum uv distance allowed (wavelengths)';
help::pkg.synthesis.imager.objs.imager.m.uvrange.a.uvmin.def := '0.0';
help::pkg.synthesis.imager.objs.imager.m.uvrange.a.uvmin.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.uvrange.a.uvmax := [=];
help::pkg.synthesis.imager.objs.imager.m.uvrange.a.uvmax.d := 'Maximum uv distance allowed (wavelengths)';
help::pkg.synthesis.imager.objs.imager.m.uvrange.a.uvmax.def := '0.0';
help::pkg.synthesis.imager.objs.imager.m.uvrange.a.uvmax.a := 'Float';
help::pkg.synthesis.imager.objs.imager.m.uvrange.s := 'uvrange(uvmin, uvmax)';
help::pkg.synthesis.imager.objs.imager.m.weight := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.d := 'Apply additional weighting to the visibility weights';
help::pkg.synthesis.imager.objs.imager.m.weight.a.type := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.a.type.d := 'Type of weighting';
help::pkg.synthesis.imager.objs.imager.m.weight.a.type.def := 'uniform';
help::pkg.synthesis.imager.objs.imager.m.weight.a.type.a := 'String: \' uniform\' |\' superuniform\' |\' natural\' |\' briggs\' |\' radial\' ';
help::pkg.synthesis.imager.objs.imager.m.weight.a.rmode := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.a.rmode.d := 'Mode of briggs weighting';
help::pkg.synthesis.imager.objs.imager.m.weight.a.rmode.def := 'none';
help::pkg.synthesis.imager.objs.imager.m.weight.a.rmode.a := 'String: \' norm\' |\' abs\' |\' none\' ';
help::pkg.synthesis.imager.objs.imager.m.weight.a.noise := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.a.noise.d := 'Noise used in absolute briggs weighting';
help::pkg.synthesis.imager.objs.imager.m.weight.a.noise.def := '\' 0.0Jy\' ';
help::pkg.synthesis.imager.objs.imager.m.weight.a.noise.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.weight.a.robust := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.a.robust.d := 'Parameter in briggs weighting';
help::pkg.synthesis.imager.objs.imager.m.weight.a.robust.def := '0.0';
help::pkg.synthesis.imager.objs.imager.m.weight.a.robust.a := 'Double: range -2.0 to 2.0';
help::pkg.synthesis.imager.objs.imager.m.weight.a.fieldofview := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.a.fieldofview.d := 'Field of view for uniform weighting';
help::pkg.synthesis.imager.objs.imager.m.weight.a.fieldofview.def := '\' 0arcsec\' ';
help::pkg.synthesis.imager.objs.imager.m.weight.a.fieldofview.a := 'Quantity';
help::pkg.synthesis.imager.objs.imager.m.weight.a.npixels := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.a.npixels.d := 'Number of pixels in the u and v directions';
help::pkg.synthesis.imager.objs.imager.m.weight.a.npixels.def := '0';
help::pkg.synthesis.imager.objs.imager.m.weight.a.npixels.a := 'Int';
help::pkg.synthesis.imager.objs.imager.m.weight.a.mosaic := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.a.mosaic.d := 'Individually weight the fields of a mosaic';
help::pkg.synthesis.imager.objs.imager.m.weight.a.mosaic.def := 'F';
help::pkg.synthesis.imager.objs.imager.m.weight.a.mosaic.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.weight.a.async := [=];
help::pkg.synthesis.imager.objs.imager.m.weight.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.imager.m.weight.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.imager.m.weight.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.imager.m.weight.s := 'weight(type, rmode, noise, robust, fieldofview, npixels, mosaic, async)';
help::pkg.synthesis.imager.funs.imagermaketestms := [=];
help::pkg.synthesis.imager.funs.imagermaketestms.a := [=];
help::pkg.synthesis.imager.funs.imagermaketestms.d := 'Make a standard MeasurementSet that can be used for experimentation';
help::pkg.synthesis.imager.funs.imagermaketestms.a.msfile := [=];
help::pkg.synthesis.imager.funs.imagermaketestms.a.msfile.d := 'Name of output ms';
help::pkg.synthesis.imager.funs.imagermaketestms.a.msfile.def := '\' 3C273XC1.ms\' ';
help::pkg.synthesis.imager.funs.imagermaketestms.a.msfile.a := 'String';
help::pkg.synthesis.imager.funs.imagermaketestms.s := 'imagermaketestms(msfile)';
help::pkg.synthesis.imager.funs.imagermaketestsdms := [=];
help::pkg.synthesis.imager.funs.imagermaketestsdms.a := [=];
help::pkg.synthesis.imager.funs.imagermaketestsdms.d := 'Make a standard single dish MeasurementSet that can be used for experimentation';
help::pkg.synthesis.imager.funs.imagermaketestsdms.a.msfile := [=];
help::pkg.synthesis.imager.funs.imagermaketestsdms.a.msfile.d := 'Name of output ms';
help::pkg.synthesis.imager.funs.imagermaketestsdms.a.msfile.def := '\' gbt\_cygnus\_800MHz.ms\' ';
help::pkg.synthesis.imager.funs.imagermaketestsdms.a.msfile.a := 'String';
help::pkg.synthesis.imager.funs.imagermaketestsdms.s := 'imagermaketestsdms(msfile)';
help::pkg.synthesis.imager.funs.imagermaketestmfms := [=];
help::pkg.synthesis.imager.funs.imagermaketestmfms.a := [=];
help::pkg.synthesis.imager.funs.imagermaketestmfms.d := 'Make a standard multifield MeasurementSet that can be used for experimentation';
help::pkg.synthesis.imager.funs.imagermaketestmfms.a.msfile := [=];
help::pkg.synthesis.imager.funs.imagermaketestmfms.a.msfile.d := 'Name of output ms';
help::pkg.synthesis.imager.funs.imagermaketestmfms.a.msfile.def := '\' XCAS.ms\' ';
help::pkg.synthesis.imager.funs.imagermaketestmfms.a.msfile.a := 'String';
help::pkg.synthesis.imager.funs.imagermaketestmfms.s := 'imagermaketestmfms(msfile)';
help::pkg.synthesis.imager.funs.imagermaketestcl := [=];
help::pkg.synthesis.imager.funs.imagermaketestcl.a := [=];
help::pkg.synthesis.imager.funs.imagermaketestcl.d := 'Make a standard componentlist for a standard MeasurementSet';
help::pkg.synthesis.imager.funs.imagermaketestcl.a.clfile := [=];
help::pkg.synthesis.imager.funs.imagermaketestcl.a.clfile.d := 'Name of output cl';
help::pkg.synthesis.imager.funs.imagermaketestcl.a.clfile.def := '\' 3C273XC1.cl\' ';
help::pkg.synthesis.imager.funs.imagermaketestcl.a.clfile.a := 'String';
help::pkg.synthesis.imager.funs.imagermaketestcl.a.refer := [=];
help::pkg.synthesis.imager.funs.imagermaketestcl.a.refer.d := 'Reference';
help::pkg.synthesis.imager.funs.imagermaketestcl.a.refer.def := '\' gal\' ';
help::pkg.synthesis.imager.funs.imagermaketestcl.a.refer.a := 'String';
help::pkg.synthesis.imager.funs.imagermaketestcl.s := 'imagermaketestcl(clfile, refer)';
help::pkg.synthesis.imager.funs.imagertest := [=];
help::pkg.synthesis.imager.funs.imagertest.a := [=];
help::pkg.synthesis.imager.funs.imagertest.d := 'Perform a test of imaging from a standard MeasurementSet';
help::pkg.synthesis.imager.funs.imagertest.a.size := [=];
help::pkg.synthesis.imager.funs.imagertest.a.size.d := 'Number of pixels on a side';
help::pkg.synthesis.imager.funs.imagertest.a.size.def := '128';
help::pkg.synthesis.imager.funs.imagertest.a.size.a := 'Int';
help::pkg.synthesis.imager.funs.imagertest.a.cleanniter := [=];
help::pkg.synthesis.imager.funs.imagertest.a.cleanniter.d := 'Number of clean iterations';
help::pkg.synthesis.imager.funs.imagertest.a.cleanniter.def := '1000';
help::pkg.synthesis.imager.funs.imagertest.a.cleanniter.a := 'Int';
help::pkg.synthesis.imager.funs.imagertest.a.cleangain := [=];
help::pkg.synthesis.imager.funs.imagertest.a.cleangain.d := 'Clean loop gain';
help::pkg.synthesis.imager.funs.imagertest.a.cleangain.def := '0.1';
help::pkg.synthesis.imager.funs.imagertest.a.cleangain.a := 'Float';
help::pkg.synthesis.imager.funs.imagertest.a.doshift := [=];
help::pkg.synthesis.imager.funs.imagertest.a.doshift.d := 'Shift the phase center';
help::pkg.synthesis.imager.funs.imagertest.a.doshift.def := 'T';
help::pkg.synthesis.imager.funs.imagertest.a.doshift.a := 'Bool';
help::pkg.synthesis.imager.funs.imagertest.a.doplot := [=];
help::pkg.synthesis.imager.funs.imagertest.a.doplot.d := 'Plot?';
help::pkg.synthesis.imager.funs.imagertest.a.doplot.def := 'T';
help::pkg.synthesis.imager.funs.imagertest.a.doplot.a := 'Bool';
help::pkg.synthesis.imager.funs.imagertest.s := 'imagertest(size, cleanniter, cleangain, doshift, doplot)';
help::pkg.synthesis.imager.funs.imagerlongtest := [=];
help::pkg.synthesis.imager.funs.imagerlongtest.a := [=];
help::pkg.synthesis.imager.funs.imagerlongtest.d := 'Perform a long test of imaging from a standard MeasurementSet';
help::pkg.synthesis.imager.funs.imagerlongtest.s := 'imagerlongtest()';
help::pkg.synthesis.imager.funs.imagermftest := [=];
help::pkg.synthesis.imager.funs.imagermftest.a := [=];
help::pkg.synthesis.imager.funs.imagermftest.d := 'Perform a test of multi-field processing using a standard MeasurementSet';
help::pkg.synthesis.imager.funs.imagermftest.a.doplot := [=];
help::pkg.synthesis.imager.funs.imagermftest.a.doplot.d := 'Plot?';
help::pkg.synthesis.imager.funs.imagermftest.a.doplot.def := 'T';
help::pkg.synthesis.imager.funs.imagermftest.a.doplot.a := 'Bool';
help::pkg.synthesis.imager.funs.imagermftest.s := 'imagermftest(doplot)';
help::pkg.synthesis.imager.funs.imagerspectraltest := [=];
help::pkg.synthesis.imager.funs.imagerspectraltest.a := [=];
help::pkg.synthesis.imager.funs.imagerspectraltest.d := 'Perform a test of spectral processing using a standard spectral line MeasurementSet';
help::pkg.synthesis.imager.funs.imagerspectraltest.s := 'imagerspectraltest()';
help::pkg.synthesis.imager.funs.imagerpbtest := [=];
help::pkg.synthesis.imager.funs.imagerpbtest.a := [=];
help::pkg.synthesis.imager.funs.imagerpbtest.d := 'Perform a test of primary beam processing using a standard MeasurementSet';
help::pkg.synthesis.imager.funs.imagerpbtest.s := 'imagerpbtest()';
help::pkg.synthesis.imager.funs.imagercomponenttest := [=];
help::pkg.synthesis.imager.funs.imagercomponenttest.a := [=];
help::pkg.synthesis.imager.funs.imagercomponenttest.d := 'Perform a test of component model processing using a standard MeasurementSet';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.size := [=];
help::pkg.synthesis.imager.funs.imagercomponenttest.a.size.d := 'Number of pixels on a side';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.size.def := '128';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.size.a := 'Int';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.doshift := [=];
help::pkg.synthesis.imager.funs.imagercomponenttest.a.doshift.d := 'Shift the phase center';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.doshift.def := 'T';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.doshift.a := 'Bool';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.doplot := [=];
help::pkg.synthesis.imager.funs.imagercomponenttest.a.doplot.d := 'Plot?';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.doplot.def := 'T';
help::pkg.synthesis.imager.funs.imagercomponenttest.a.doplot.a := 'Bool';
help::pkg.synthesis.imager.funs.imagercomponenttest.s := 'imagercomponenttest(size, doshift, doplot)';
help::pkg.synthesis.imager.funs.imagersdtest := [=];
help::pkg.synthesis.imager.funs.imagersdtest.a := [=];
help::pkg.synthesis.imager.funs.imagersdtest.d := 'Perform a test of single dish imaging from a standard MeasurementSet';
help::pkg.synthesis.imager.funs.imagersdtest.s := 'imagersdtest()';
help::pkg.synthesis.imager.funs.imageralltests := [=];
help::pkg.synthesis.imager.funs.imageralltests.a := [=];
help::pkg.synthesis.imager.funs.imageralltests.d := 'Perform all imager tests using standard MeasurementSets';
help::pkg.synthesis.imager.funs.imageralltests.s := 'imageralltests()';
help::pkg.synthesis.imager.funs.imagermultiscale := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.d := 'Makes multi-resolution multiscale images.';
help::pkg.synthesis.imager.funs.imagermultiscale.a.msname := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.msname.d := 'Name of input ms';
help::pkg.synthesis.imager.funs.imagermultiscale.a.msname.def := '\' \' ';
help::pkg.synthesis.imager.funs.imagermultiscale.a.msname.a := 'String';
help::pkg.synthesis.imager.funs.imagermultiscale.a.imsizes := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.imsizes.d := 'Image sizes for each round (should be monatonically increasing)';
help::pkg.synthesis.imager.funs.imagermultiscale.a.imsizes.def := '[128, 256]';
help::pkg.synthesis.imager.funs.imagermultiscale.a.imsizes.a := 'Vector of Ints';
help::pkg.synthesis.imager.funs.imagermultiscale.a.cellsizes := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.cellsizes.d := 'Cell sizes [in arcsec] for each round (should be monatonically decreasing)';
help::pkg.synthesis.imager.funs.imagermultiscale.a.cellsizes.def := '[2, 1]';
help::pkg.synthesis.imager.funs.imagermultiscale.a.cellsizes.a := 'Vector of Floats';
help::pkg.synthesis.imager.funs.imagermultiscale.a.scales := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.scales.d := 'Name of input ms';
help::pkg.synthesis.imager.funs.imagermultiscale.a.scales.def := '[0, 5, 15]';
help::pkg.synthesis.imager.funs.imagermultiscale.a.scales.a := 'Vector of Ints';
help::pkg.synthesis.imager.funs.imagermultiscale.a.nitermult := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.nitermult.d := 'Multiplier parameter used to adjust niter with imsizes';
help::pkg.synthesis.imager.funs.imagermultiscale.a.nitermult.def := '0.15';
help::pkg.synthesis.imager.funs.imagermultiscale.a.nitermult.a := 'Float';
help::pkg.synthesis.imager.funs.imagermultiscale.a.niterpower := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.niterpower.d := 'Exponent of imsizes used to adjust niter with imsizes';
help::pkg.synthesis.imager.funs.imagermultiscale.a.niterpower.def := '1.2';
help::pkg.synthesis.imager.funs.imagermultiscale.a.niterpower.a := 'Float';
help::pkg.synthesis.imager.funs.imagermultiscale.a.fields := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.fields.d := 'Vector of field ids to image';
help::pkg.synthesis.imager.funs.imagermultiscale.a.fields.def := '[1]';
help::pkg.synthesis.imager.funs.imagermultiscale.a.fields.a := 'Vector of Ints';
help::pkg.synthesis.imager.funs.imagermultiscale.a.spwid := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.spwid.d := 'Spectral window to image';
help::pkg.synthesis.imager.funs.imagermultiscale.a.spwid.def := '1';
help::pkg.synthesis.imager.funs.imagermultiscale.a.spwid.a := 'Int';
help::pkg.synthesis.imager.funs.imagermultiscale.a.centerfield := [=];
help::pkg.synthesis.imager.funs.imagermultiscale.a.centerfield.d := 'Field id for central pointing';
help::pkg.synthesis.imager.funs.imagermultiscale.a.centerfield.def := '1';
help::pkg.synthesis.imager.funs.imagermultiscale.a.centerfield.a := 'Int';
help::pkg.synthesis.imager.funs.imagermultiscale.s := 'imagermultiscale(msname, imsizes, cellsizes, scales, nitermult, niterpower, fields, spwid, centerfield)';
help::pkg.synthesis.imager.objs.dragon := [=];
help::pkg.synthesis.imager.objs.dragon.m := [=];
help::pkg.synthesis.imager.objs.dragon.c := [=];
help::pkg.synthesis.imager.objs.dragon.d := 'Tool for wide-field synthesis imaging';
help::pkg.synthesis.imager.objs.dragon.c.dragon := [=];
help::pkg.synthesis.imager.objs.dragon.c.dragon.d := 'Construct an dragon tool';
help::pkg.synthesis.imager.objs.dragon.c.dragon.a.ms := [=];
help::pkg.synthesis.imager.objs.dragon.c.dragon.a.ms.d := 'MeasurementSet to be processed';
help::pkg.synthesis.imager.objs.dragon.c.dragon.a.ms.def := '';
help::pkg.synthesis.imager.objs.dragon.c.dragon.a.ms.a := 'Table name';
help::pkg.synthesis.imager.objs.dragon.c.dragon.s := 'dragon(ms)';
help::pkg.synthesis.imager.objs.dragon.m.setimage := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.d := 'Set the image parameters for subsequent processing';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.name := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.name.d := 'Name of output image';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.name.def := 'dragon';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.name.a := 'String';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.nx := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.nx.d := 'Number of spatial pixels in x';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.nx.def := '128';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.nx.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.ny := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.ny.d := 'Number of spatial pixels in y';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.ny.def := '128';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.ny.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.cellx := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.cellx.d := 'Cellsize in x (e.g. \' 1arcsec\' )';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.cellx.def := '\' 1arcsec\' ';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.cellx.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.celly := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.celly.d := 'Cellsize in y (e.g. \' 1arcsec\' )';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.celly.def := '\' 1arcsec\' ';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.celly.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.stokes := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.stokes.d := 'Stokes parameters to image (e.g. \' IQUV\' )';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.stokes.def := '\' I\' ';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.stokes.a := '\' I\' |\' IV\' |\' IQU\' |\' IQUV\' ';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.doshift := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.doshift.d := 'Use the specified phase center? T or F';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.doshift.def := 'T';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.doshift.a := 'Bool';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.phasecenter := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.phasecenter.d := 'Direction of phase center as a measure';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.phasecenter.def := '';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.phasecenter.a := 'MDirection';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.shiftx := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.shiftx.d := 'Shift in x (e.g. \' 23.7arcsec\' )';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.shiftx.def := '\' 0arcsec\' ';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.shiftx.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.shifty := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.shifty.d := 'Shift in y (e.g. \' -54.2arcsec\' )';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.shifty.def := '\' 0arcsec\' ';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.shifty.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.mode := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.mode.d := 'Type of processing';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.mode.def := '\' mfs\' ';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.mode.a := '\' mfs\' |\' channel\' |\' velocity\' ';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.nchan := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.nchan.d := 'Number of channels';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.nchan.def := '1';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.nchan.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.start := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.start.d := 'Start channel (1-relative)';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.start.def := '';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.start.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.step := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.step.d := 'Step in channel';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.step.def := '';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.step.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.spwid := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.spwid.d := 'Spectral Window Ids (1 relative)';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.spwid.def := '1';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.spwid.a := 'Vector of Ints';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.fieldid := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.fieldid.d := 'Field Id (1 relative)';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.fieldid.def := '1';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.fieldid.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.facets := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.facets.d := 'Number of facets';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.facets.def := '1';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.facets.a := 'Integer';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.name := [=];
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.name.d := 'Name of output image';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.name.def := 'dragon';
help::pkg.synthesis.imager.objs.dragon.m.setimage.a.name.a := 'String';
help::pkg.synthesis.imager.objs.dragon.m.setimage.s := 'setimage(name, nx, ny, cellx, celly, stokes, doshift, phasecenter, shiftx, shifty, mode, nchan, start, step, spwid, fieldid, facets, name)';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.d := 'Set the image parameters for an outlier  field';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.name := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.name.d := 'Name of output image';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.name.def := 'dragon.outlier.n';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.name.a := 'String';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.nx := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.nx.d := 'Number of spatial pixels in x';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.nx.def := '128';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.nx.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.ny := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.ny.d := 'Number of spatial pixels in y';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.ny.def := '128';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.ny.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.cellx := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.cellx.d := 'Cellsize in x (e.g. \' 1arcsec\' )';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.cellx.def := '\' 1arcsec\' ';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.cellx.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.celly := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.celly.d := 'Cellsize in y (e.g. \' 1arcsec\' )';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.celly.def := '\' 1arcsec\' ';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.celly.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.stokes := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.stokes.d := 'Stokes parameters to image (e.g. \' IQUV\' )';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.stokes.def := '\' I\' ';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.stokes.a := '\' I\' |\' IV\' |\' IQU\' |\' IQUV\' ';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.doshift := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.doshift.d := 'Use the specified phase center? T or F';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.doshift.def := 'T';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.doshift.a := 'Bool';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.phasecenter := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.phasecenter.d := 'Direction of phase center as a measure';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.phasecenter.def := '';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.phasecenter.a := 'MDirection';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.mode := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.mode.d := 'Type of processing';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.mode.def := '\' mfs\' ';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.mode.a := '\' mfs\' |\' channel\' |\' velocity\' ';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.nchan := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.nchan.d := 'Number of channels';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.nchan.def := '1';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.nchan.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.start := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.start.d := 'Start channel (1-relative)';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.start.def := '';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.start.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.step := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.step.d := 'Step in channel';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.step.def := '';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.step.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.spwid := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.spwid.d := 'Spectral Window Ids (1 relative)';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.spwid.def := '1';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.spwid.a := 'Vector of Ints';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.fieldid := [=];
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.fieldid.d := 'Field Id (1 relative)';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.fieldid.def := '1';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.a.fieldid.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.setoutlier.s := 'setoutlier(name, nx, ny, cellx, celly, stokes, doshift, phasecenter, mode, nchan, start, step, spwid, fieldid)';
help::pkg.synthesis.imager.objs.dragon.m.advise := [=];
help::pkg.synthesis.imager.objs.dragon.m.advise.d := 'Advise (and optionally use) parameter values';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.amplitudeloss := [=];
help::pkg.synthesis.imager.objs.dragon.m.advise.a.amplitudeloss.d := 'Maximum fractional amplitude loss due to faceting';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.amplitudeloss.def := '0.05';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.amplitudeloss.a := 'Float';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.fieldofview := [=];
help::pkg.synthesis.imager.objs.dragon.m.advise.a.fieldofview.d := 'Desired field of view';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.fieldofview.def := '\' 1deg\' ';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.fieldofview.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.cell := [=];
help::pkg.synthesis.imager.objs.dragon.m.advise.a.cell.d := 'Recommended maximum cellsize';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.cell.def := '';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.cell.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.facets := [=];
help::pkg.synthesis.imager.objs.dragon.m.advise.a.facets.d := 'Recommended number of facets on one axis';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.facets.def := '1';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.facets.a := 'Integer';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.phasecenter := [=];
help::pkg.synthesis.imager.objs.dragon.m.advise.a.phasecenter.d := 'Direction of phase center as a measure';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.phasecenter.def := '';
help::pkg.synthesis.imager.objs.dragon.m.advise.a.phasecenter.a := 'MDirection';
help::pkg.synthesis.imager.objs.dragon.m.advise.s := 'advise(amplitudeloss, fieldofview, cell, facets, phasecenter)';
help::pkg.synthesis.imager.objs.dragon.m.weight := [=];
help::pkg.synthesis.imager.objs.dragon.m.weight.d := 'Apply weighting to the visibility weights';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.type := [=];
help::pkg.synthesis.imager.objs.dragon.m.weight.a.type.d := 'Type of weighting';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.type.def := 'uniform';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.type.a := 'String: \' uniform\'  | \' natural\'  | \' briggs\'  | \' radial\' ';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.rmode := [=];
help::pkg.synthesis.imager.objs.dragon.m.weight.a.rmode.d := 'Mode of briggs weighting';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.rmode.def := 'none';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.rmode.a := 'String: \' norm\'  | \' abs\'  | \' none\'  ';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.noise := [=];
help::pkg.synthesis.imager.objs.dragon.m.weight.a.noise.d := 'Noise used in absolute briggs weighting';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.noise.def := '\' 0.0Jy\' ';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.noise.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.robust := [=];
help::pkg.synthesis.imager.objs.dragon.m.weight.a.robust.d := 'Parameter in briggs weighting';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.robust.def := '0.0';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.robust.a := 'Double';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.fieldofview := [=];
help::pkg.synthesis.imager.objs.dragon.m.weight.a.fieldofview.d := 'Field of view for uniform weighting';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.fieldofview.def := '\' 0arcsec\' ';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.fieldofview.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.npixels := [=];
help::pkg.synthesis.imager.objs.dragon.m.weight.a.npixels.d := 'Number of pixels in the u and v directions';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.npixels.def := '0';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.npixels.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.async := [=];
help::pkg.synthesis.imager.objs.dragon.m.weight.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.dragon.m.weight.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.dragon.m.weight.s := 'weight(type, rmode, noise, robust, fieldofview, npixels, async)';
help::pkg.synthesis.imager.objs.dragon.m.filter := [=];
help::pkg.synthesis.imager.objs.dragon.m.filter.d := 'Apply filtering';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bmaj := [=];
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bmaj.d := 'Major axis of filter';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bmaj.def := '\' 0rad\' ';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bmaj.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bmin := [=];
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bmin.d := 'Minor axis of filter';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bmin.def := '\' 0rad\' ';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bmin.a := 'Quantiy';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bpa := [=];
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bpa.d := 'Position angle of filter';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bpa.def := '\' 0deg\' ';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.bpa.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.async := [=];
help::pkg.synthesis.imager.objs.dragon.m.filter.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.async.def := '!dowait';
help::pkg.synthesis.imager.objs.dragon.m.filter.a.async.a := 'Bool';
help::pkg.synthesis.imager.objs.dragon.m.filter.s := 'filter(bmaj, bmin, bpa, async)';
help::pkg.synthesis.imager.objs.dragon.m.uvrange := [=];
help::pkg.synthesis.imager.objs.dragon.m.uvrange.d := 'Apply uvrange to the visibility weights';
help::pkg.synthesis.imager.objs.dragon.m.uvrange.a.uvmin := [=];
help::pkg.synthesis.imager.objs.dragon.m.uvrange.a.uvmin.d := 'Minimum uv distance allowed (wavelengths)';
help::pkg.synthesis.imager.objs.dragon.m.uvrange.a.uvmin.def := '0.0';
help::pkg.synthesis.imager.objs.dragon.m.uvrange.a.uvmin.a := 'Float';
help::pkg.synthesis.imager.objs.dragon.m.uvrange.a.uvmax := [=];
help::pkg.synthesis.imager.objs.dragon.m.uvrange.a.uvmax.d := 'Maximum uv distance allowed (wavelengths)';
help::pkg.synthesis.imager.objs.dragon.m.uvrange.a.uvmax.def := '0.0';
help::pkg.synthesis.imager.objs.dragon.m.uvrange.a.uvmax.a := 'Float';
help::pkg.synthesis.imager.objs.dragon.m.uvrange.s := 'uvrange(uvmin, uvmax)';
help::pkg.synthesis.imager.objs.dragon.m.image := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.d := 'Clean and self-calibrate';
help::pkg.synthesis.imager.objs.dragon.m.image.a.levels := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.levels.d := 'Flux levels at which to self-calibrate e.g. 0.3Jy 0.1Jy 0.03Jy';
help::pkg.synthesis.imager.objs.dragon.m.image.a.levels.def := '\' 0Jy\' ';
help::pkg.synthesis.imager.objs.dragon.m.image.a.levels.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.dragon.m.image.a.amplitudelevels := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.amplitudelevels.d := 'Flux level below which amplitude self-calibration is used';
help::pkg.synthesis.imager.objs.dragon.m.image.a.amplitudelevels.def := '\' 0Jy\' ';
help::pkg.synthesis.imager.objs.dragon.m.image.a.amplitudelevels.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.image.a.timescales := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.timescales.d := 'Time scales for the self-calibrations e.g (60s 10s 10s)';
help::pkg.synthesis.imager.objs.dragon.m.image.a.timescales.def := '\' 10s\' ';
help::pkg.synthesis.imager.objs.dragon.m.image.a.timescales.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.dragon.m.image.a.niter := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.niter.d := 'Number of Iterations, set to zero for no CLEANing';
help::pkg.synthesis.imager.objs.dragon.m.image.a.niter.def := '1000';
help::pkg.synthesis.imager.objs.dragon.m.image.a.niter.a := 'Int';
help::pkg.synthesis.imager.objs.dragon.m.image.a.gain := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.gain.d := 'Loop Gain for CLEANing';
help::pkg.synthesis.imager.objs.dragon.m.image.a.gain.def := '0.1';
help::pkg.synthesis.imager.objs.dragon.m.image.a.gain.a := 'Double';
help::pkg.synthesis.imager.objs.dragon.m.image.a.threshold := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.threshold.d := 'Flux level below which cleaning will stop';
help::pkg.synthesis.imager.objs.dragon.m.image.a.threshold.def := '\' 0Jy\' ';
help::pkg.synthesis.imager.objs.dragon.m.image.a.threshold.a := 'Quantity';
help::pkg.synthesis.imager.objs.dragon.m.image.a.model := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.model.d := 'Name of images';
help::pkg.synthesis.imager.objs.dragon.m.image.a.model.def := '';
help::pkg.synthesis.imager.objs.dragon.m.image.a.model.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.dragon.m.image.a.complist := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.complist.d := 'Name of component list';
help::pkg.synthesis.imager.objs.dragon.m.image.a.complist.def := '';
help::pkg.synthesis.imager.objs.dragon.m.image.a.complist.a := 'String';
help::pkg.synthesis.imager.objs.dragon.m.image.a.image := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.image.d := 'Names of restored images';
help::pkg.synthesis.imager.objs.dragon.m.image.a.image.def := '';
help::pkg.synthesis.imager.objs.dragon.m.image.a.image.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.dragon.m.image.a.residual := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.residual.d := 'Names of restored images';
help::pkg.synthesis.imager.objs.dragon.m.image.a.residual.def := '';
help::pkg.synthesis.imager.objs.dragon.m.image.a.residual.a := 'Vector of strings';
help::pkg.synthesis.imager.objs.dragon.m.image.a.statsregion := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.statsregion.d := 'Region in which to calculate statistics';
help::pkg.synthesis.imager.objs.dragon.m.image.a.statsregion.def := 'unset';
help::pkg.synthesis.imager.objs.dragon.m.image.a.statsregion.a := 'Any valid region';
help::pkg.synthesis.imager.objs.dragon.m.image.a.statsout := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.statsout.d := 'Statistics record';
help::pkg.synthesis.imager.objs.dragon.m.image.a.statsout.def := '[=]';
help::pkg.synthesis.imager.objs.dragon.m.image.a.statsout.a := 'Record';
help::pkg.synthesis.imager.objs.dragon.m.image.a.algorithm := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.algorithm.d := 'deconvolving algorithm';
help::pkg.synthesis.imager.objs.dragon.m.image.a.algorithm.def := '\' wfclark\' ';
help::pkg.synthesis.imager.objs.dragon.m.image.a.algorithm.a := 'String';
help::pkg.synthesis.imager.objs.dragon.m.image.a.maskmodification := [=];
help::pkg.synthesis.imager.objs.dragon.m.image.a.maskmodification.d := 'Masking update at every cal cycle from \' none\' , \' auto\' , \' interactive\' ';
help::pkg.synthesis.imager.objs.dragon.m.image.a.maskmodification.def := '\' none\' ';
help::pkg.synthesis.imager.objs.dragon.m.image.a.maskmodification.a := 'String';
help::pkg.synthesis.imager.objs.dragon.m.image.s := 'image(levels, amplitudelevels, timescales, niter, gain, threshold, model, complist, image, residual, statsregion, statsout, algorithm, maskmodification)';
help::pkg.synthesis.imager.objs.dragon.m.done := [=];
help::pkg.synthesis.imager.objs.dragon.m.done.d := 'Terminate the dragon process';
help::pkg.synthesis.imager.objs.dragon.m.done.s := 'done()';
help::pkg.synthesis.imager.funs.dragontest := [=];
help::pkg.synthesis.imager.funs.dragontest.a := [=];
help::pkg.synthesis.imager.funs.dragontest.d := 'Test dragon using a VLA 74 MHz data set';
help::pkg.synthesis.imager.funs.dragontest.a.fitsfile := [=];
help::pkg.synthesis.imager.funs.dragontest.a.fitsfile.d := 'Name of standard FITS file';
help::pkg.synthesis.imager.funs.dragontest.a.fitsfile.def := '3DDAT';
help::pkg.synthesis.imager.funs.dragontest.a.fitsfile.a := 'String';
help::pkg.synthesis.imager.funs.dragontest.a.doimage := [=];
help::pkg.synthesis.imager.funs.dragontest.a.doimage.d := 'Do the imaging as well as the simulation?';
help::pkg.synthesis.imager.funs.dragontest.a.doimage.def := 'T';
help::pkg.synthesis.imager.funs.dragontest.a.doimage.a := 'Boolean';
help::pkg.synthesis.imager.funs.dragontest.a.dofind := [=];
help::pkg.synthesis.imager.funs.dragontest.a.dofind.d := 'Do the source finding as well as the imaging and simulation?';
help::pkg.synthesis.imager.funs.dragontest.a.dofind.def := 'T';
help::pkg.synthesis.imager.funs.dragontest.a.dofind.a := 'Boolean';
help::pkg.synthesis.imager.funs.dragontest.s := 'dragontest(fitsfile, doimage, dofind)';
help::pkg.synthesis.imager.funs.imagerwizard := [=];
help::pkg.synthesis.imager.funs.imagerwizard.a := [=];
help::pkg.synthesis.imager.funs.imagerwizard.d := 'Wizard for synthesis imaging';
help::pkg.synthesis.imager.funs.imagerwizard.s := 'imagerwizard()';
help::pkg.synthesis.imager.funs.mosaicwizard := [=];
help::pkg.synthesis.imager.funs.mosaicwizard.a := [=];
help::pkg.synthesis.imager.funs.mosaicwizard.d := 'Wizard for multi-field synthesis imaging';
help::pkg.synthesis.imager.funs.mosaicwizard.s := 'mosaicwizard()';
help::pkg.synthesis.imager.objs.vpmanager := [=];
help::pkg.synthesis.imager.objs.vpmanager.m := [=];
help::pkg.synthesis.imager.objs.vpmanager.c := [=];
help::pkg.synthesis.imager.objs.vpmanager.d := 'Tool for specifying voltage patterns and primary beams';
help::pkg.synthesis.imager.objs.vpmanager.c.vpmanager := [=];
help::pkg.synthesis.imager.objs.vpmanager.c.vpmanager.d := 'Construct a vpmanager tool';
help::pkg.synthesis.imager.objs.vpmanager.c.vpmanager.s := 'vpmanager()';
help::pkg.synthesis.imager.objs.vpmanager.m.saveastable := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.saveastable.d := 'Save the vp or pb descriptions as a table';
help::pkg.synthesis.imager.objs.vpmanager.m.saveastable.a.tablename := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.saveastable.a.tablename.d := 'Name of table to save vp descriptions in';
help::pkg.synthesis.imager.objs.vpmanager.m.saveastable.a.tablename.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.saveastable.a.tablename.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.saveastable.s := 'saveastable(tablename)';
help::pkg.synthesis.imager.objs.vpmanager.m.summarizevps := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.summarizevps.d := 'Summarize the currently accumulated VP descriptions';
help::pkg.synthesis.imager.objs.vpmanager.m.summarizevps.a.verbose := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.summarizevps.a.verbose.d := 'Print out full record?  Otherwise, print summary.';
help::pkg.synthesis.imager.objs.vpmanager.m.summarizevps.a.verbose.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.summarizevps.a.verbose.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.summarizevps.s := 'summarizevps(verbose)';
help::pkg.synthesis.imager.objs.vpmanager.m.done := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.done.d := 'Terminate the vpmanager';
help::pkg.synthesis.imager.objs.vpmanager.m.done.s := 'done()';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.d := 'Select a vp/pb from our library of common pb models';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.telescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.telescope.d := 'Which telescope in the MS will use this vp/pb?';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.telescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.othertelescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.othertelescope.d := 'If telescope=="OTHER", specify name here';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.othertelescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.othertelescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.dopb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.dopb.d := 'Should we apply the vp/pb to this telescope\' s data?';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.dopb.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.dopb.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.commonpb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.commonpb.d := 'List of common vp/pb models: DEFAULT code figures it out';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.commonpb.def := 'DEFAULT';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.commonpb.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.dosquint := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.dosquint.d := 'Enable the natural beam squint found in the common vp model';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.dosquint.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.dosquint.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.paincrement := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.paincrement.d := 'Increment in Parallactic Angle for asymmetric (ie, squinted) vp application';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.paincrement.def := '360deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.paincrement.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.usesymmetricbeam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.usesymmetricbeam.d := 'Not currently used';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.usesymmetricbeam.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.a.usesymmetricbeam.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setcannedpb.s := 'setcannedpb(telescope, othertelescope, dopb, commonpb, dosquint, paincrement, usesymmetricbeam)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.d := 'Make an airy disk vp';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.telescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.telescope.d := 'Which telescope in the MS will use this vp/pb?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.telescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.othertelescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.othertelescope.d := 'If telescope=="OTHER", specify name here';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.othertelescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.othertelescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dopb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dopb.d := 'Should we apply the vp/pb to this telescope\' s data?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dopb.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dopb.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dishdiam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dishdiam.d := 'Effective diameter of dish';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dishdiam.def := '25m';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dishdiam.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.blockagediam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.blockagediam.d := 'Effective diameter of subreflector blockage';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.blockagediam.def := '2.5m';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.blockagediam.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.maxrad := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.maxrad.d := 'Maximum radial extent of the vp/pb (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.maxrad.def := '0.8deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.maxrad.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.reffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.reffreq.d := 'Frequency at which maxrad is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.reffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.reffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.squintdir := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.squintdir.d := 'Offset of RR beam from pointing center, azel frame (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.squintdir.def := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.squintdir.a := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.squintreffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.squintreffreq.d := 'Frequency at which the squint is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.squintreffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.squintreffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dosquint := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dosquint.d := 'Enable the natural beam squint found in the common vp model';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dosquint.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.dosquint.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.paincrement := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.paincrement.d := 'Increment in Parallactic Angle for asymmetric (ie, squinted) vp application';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.paincrement.def := '360deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.paincrement.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.usesymmetricbeam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.usesymmetricbeam.d := 'Not currently used';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.usesymmetricbeam.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.a.usesymmetricbeam.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbairy.s := 'setpbairy(telescope, othertelescope, dopb, dishdiam, blockagediam, maxrad, reffreq, squintdir, squintreffreq, dosquint, paincrement, usesymmetricbeam)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.d := 'Make a vp/pb from a polynomial of scaled cosines';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.telescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.telescope.d := 'Which telescope in the MS will use this vp/pb?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.telescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.othertelescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.othertelescope.d := 'If telescope=="OTHER", specify name here';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.othertelescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.othertelescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.dopb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.dopb.d := 'Should we apply the vp/pb to this telescope\' s data?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.dopb.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.dopb.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.coeff := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.coeff.d := 'Vector of coefficients of cosines';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.coeff.def := '0';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.coeff.a := 'Vector of Double';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.scale := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.scale.d := 'Vector of scale factors of cosines';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.scale.def := '0';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.scale.a := 'Vector od Doubles';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.maxrad := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.maxrad.d := 'Maximum radial extent of the vp/pb (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.maxrad.def := '0.8deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.maxrad.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.reffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.reffreq.d := 'Frequency at which maxrad is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.reffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.reffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.isthispb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.isthispb.d := 'Do these parameters describe a PB or a VP?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.isthispb.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.isthispb.a := 'String: \' PB\' |\' VP\' ';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.squintdir := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.squintdir.d := 'Offset of RR beam from pointing center, azel frame (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.squintdir.def := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.squintdir.a := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.squintreffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.squintreffreq.d := 'Frequency at which the squint is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.squintreffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.squintreffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.dosquint := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.dosquint.d := 'Enable the natural beam squint found in the common vp model';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.dosquint.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.dosquint.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.paincrement := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.paincrement.d := 'Increment in Parallactic Angle for asymmetric (ie, squinted) vp application';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.paincrement.def := '360deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.paincrement.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.usesymmetricbeam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.usesymmetricbeam.d := 'Not currently used';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.usesymmetricbeam.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.a.usesymmetricbeam.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbcospoly.s := 'setpbcospoly(telescope, othertelescope, dopb, coeff, scale, maxrad, reffreq, isthispb, squintdir, squintreffreq, dosquint, paincrement, usesymmetricbeam)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.d := 'Make a Gaussian vp/pb';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.telescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.telescope.d := 'Which telescope in the MS will use this vp/pb?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.telescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.othertelescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.othertelescope.d := 'If telescope=="OTHER", specify name here';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.othertelescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.othertelescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.dopb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.dopb.d := 'Should we apply the vp/pb to this telescope\' s data?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.dopb.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.dopb.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.halfwidth := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.halfwidth.d := 'Half power half width of the Gaussian at the reffreq';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.halfwidth.def := '0.5deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.halfwidth.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.maxrad := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.maxrad.d := 'Maximum radial extent of the vp/pb (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.maxrad.def := '0.8deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.maxrad.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.reffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.reffreq.d := 'Frequency at which maxrad is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.reffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.reffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.isthispb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.isthispb.d := 'Do these parameters describe a PB or a VP?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.isthispb.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.isthispb.a := 'String: \' PB\' |\' VP\' ';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.squintdir := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.squintdir.d := 'Offset of RR beam from pointing center, azel frame (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.squintdir.def := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.squintdir.a := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.squintreffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.squintreffreq.d := 'Frequency at which the squint is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.squintreffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.squintreffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.dosquint := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.dosquint.d := 'Enable the natural beam squint found in the common vp model';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.dosquint.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.dosquint.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.paincrement := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.paincrement.d := 'Increment in Parallactic Angle for asymmetric (ie, squinted) vp application';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.paincrement.def := '360deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.paincrement.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.usesymmetricbeam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.usesymmetricbeam.d := 'Not currently used';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.usesymmetricbeam.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.a.usesymmetricbeam.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbgauss.s := 'setpbgauss(telescope, othertelescope, dopb, halfwidth, maxrad, reffreq, isthispb, squintdir, squintreffreq, dosquint, paincrement, usesymmetricbeam)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.d := 'Make a vp/pb as an inverse polynomial';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.telescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.telescope.d := 'Which telescope in the MS will use this vp/pb?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.telescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.othertelescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.othertelescope.d := 'If telescope=="OTHER", specify name here';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.othertelescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.othertelescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.dopb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.dopb.d := 'Should we apply the vp/pb to this telescope\' s data?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.dopb.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.dopb.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.coeff := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.coeff.d := 'Coefficients of even powered terms';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.coeff.def := '[0]';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.coeff.a := 'Vector of Doubles';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.maxrad := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.maxrad.d := 'Maximum radial extent of the vp/pb (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.maxrad.def := '0.8deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.maxrad.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.reffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.reffreq.d := 'Frequency at which maxrad is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.reffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.reffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.isthispb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.isthispb.d := 'Do these parameters describe a PB or a VP?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.isthispb.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.isthispb.a := 'String: \' PB\' |\' VP\' ';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.squintdir := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.squintdir.d := 'Offset of RR beam from pointing center, azel frame (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.squintdir.def := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.squintdir.a := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.squintreffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.squintreffreq.d := 'Frequency at which the squint is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.squintreffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.squintreffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.dosquint := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.dosquint.d := 'Enable the natural beam squint found in the common vp model';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.dosquint.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.dosquint.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.paincrement := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.paincrement.d := 'Increment in Parallactic Angle for asymmetric (ie, squinted) vp application';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.paincrement.def := '360deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.paincrement.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.usesymmetricbeam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.usesymmetricbeam.d := 'Not currently used';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.usesymmetricbeam.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.a.usesymmetricbeam.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbinvpoly.s := 'setpbinvpoly(telescope, othertelescope, dopb, coeff, maxrad, reffreq, isthispb, squintdir, squintreffreq, dosquint, paincrement, usesymmetricbeam)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.d := 'Make a vp/pb from a user-supplied vector';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.telescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.telescope.d := 'Which telescope in the MS will use this vp/pb?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.telescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.othertelescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.othertelescope.d := 'If telescope=="OTHER", specify name here';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.othertelescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.othertelescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.dopb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.dopb.d := 'Should we apply the vp/pb to this telescope\' s data?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.dopb.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.dopb.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.vect := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.vect.d := 'Vector of vp/pb samples uniformly spaced from 0 to maxrad';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.vect.def := '0';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.vect.a := 'Vector of Doubles';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.maxrad := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.maxrad.d := 'Maximum radial extent of the vp/pb (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.maxrad.def := '0.8deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.maxrad.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.reffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.reffreq.d := 'Frequency at which maxrad is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.reffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.reffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.isthispb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.isthispb.d := 'Do these parameters describe a PB or a VP?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.isthispb.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.isthispb.a := 'String: \' PB\' |\' VP\' ';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.squintdir := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.squintdir.d := 'Offset of RR beam from pointing center, azel frame (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.squintdir.def := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.squintdir.a := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.squintreffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.squintreffreq.d := 'Frequency at which the squint is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.squintreffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.squintreffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.dosquint := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.dosquint.d := 'Enable the natural beam squint found in the common vp model';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.dosquint.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.dosquint.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.paincrement := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.paincrement.d := 'Increment in Parallactic Angle for asymmetric (ie, squinted) vp application';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.paincrement.def := '360deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.paincrement.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.usesymmetricbeam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.usesymmetricbeam.d := 'Not currently used';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.usesymmetricbeam.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.a.usesymmetricbeam.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbnumeric.s := 'setpbnumeric(telescope, othertelescope, dopb, vect, maxrad, reffreq, isthispb, squintdir, squintreffreq, dosquint, paincrement, usesymmetricbeam)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.d := 'Make a vp/pb from a user-supplied image';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.telescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.telescope.d := 'Which telescope in the MS will use this vp/pb?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.telescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.othertelescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.othertelescope.d := 'If telescope=="OTHER", specify name here';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.othertelescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.othertelescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.dopb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.dopb.d := 'Should we apply the vp/pb to this telescope\' s data?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.dopb.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.dopb.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.realimage := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.realimage.d := 'Real part of vp as an image';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.realimage.def := '``\' \' ';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.realimage.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.imagimage := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.imagimage.d := 'Imaginary part of vp as an image';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.imagimage.def := '``\' \' ';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.a.imagimage.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbimage.s := 'setpbimage(telescope, othertelescope, dopb, realimage, imagimage)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.d := 'Make a vp/pb from a polynomial';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.telescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.telescope.d := 'Which telescope in the MS will use this vp/pb?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.telescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.telescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.othertelescope := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.othertelescope.d := 'If telescope=="OTHER", specify name here';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.othertelescope.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.othertelescope.a := 'String';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.dopb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.dopb.d := 'Should we apply the vp/pb to this telescope\' s data?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.dopb.def := 'T';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.dopb.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.coeff := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.coeff.d := 'Coefficients of even powered terms';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.coeff.def := '0';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.coeff.a := 'Vector of Doubles';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.maxrad := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.maxrad.d := 'Maximum radial extent of the vp/pb (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.maxrad.def := '0.8deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.maxrad.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.reffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.reffreq.d := 'Frequency at which maxrad is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.reffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.reffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.isthispb := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.isthispb.d := 'Do these parameters describe a PB or a VP?';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.isthispb.def := '';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.isthispb.a := 'String: \' PB\' |\' VP\' ';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.squintdir := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.squintdir.d := 'Offset of RR beam from pointing center, azel frame (scales with 1/freq)';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.squintdir.def := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.squintdir.a := 'Measure';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.squintreffreq := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.squintreffreq.d := 'Frequency at which the squint is specified';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.squintreffreq.def := '1GHz';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.squintreffreq.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.dosquint := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.dosquint.d := 'Enable the natural beam squint found in the common vp model';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.dosquint.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.dosquint.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.paincrement := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.paincrement.d := 'Increment in Parallactic Angle for asymmetric (ie, squinted) vp application';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.paincrement.def := '360deg';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.paincrement.a := 'Quantity';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.usesymmetricbeam := [=];
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.usesymmetricbeam.d := 'Not currently used';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.usesymmetricbeam.def := 'F';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.a.usesymmetricbeam.a := 'Bool';
help::pkg.synthesis.imager.objs.vpmanager.m.setpbpoly.s := 'setpbpoly(telescope, othertelescope, dopb, coeff, maxrad, reffreq, isthispb, squintdir, squintreffreq, dosquint, paincrement, usesymmetricbeam)';

help::pkg.synthesis.qimager := [=];
help::pkg.synthesis.qimager.objs := [=];
help::pkg.synthesis.qimager.funs := [=];
help::pkg.synthesis.qimager.d := 'Module for synthesis and single dish imaging';
help::pkg.synthesis.qimager.objs.qimager := [=];
help::pkg.synthesis.qimager.objs.qimager.m := [=];
help::pkg.synthesis.qimager.objs.qimager.c := [=];
help::pkg.synthesis.qimager.objs.qimager.d := 'tool for synthesis imaging';
help::pkg.synthesis.qimager.objs.qimager.c.qimager := [=];
help::pkg.synthesis.qimager.objs.qimager.c.qimager.d := 'Construct an qimager tool';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.filename := [=];
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.filename.d := 'MeasurementSet to be imaged';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.filename.def := '\' \' ';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.filename.a := 'Table name';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.compress := [=];
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.compress.d := 'Compress calibration columns?';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.compress.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.compress.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.host := [=];
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.host.d := 'Host on which to run qimager';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.host.def := '\' \' ';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.host.a := 'String: \' \'  means localhost';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.forcenewserver := [=];
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.forcenewserver.d := 'Flag to force a new qimager client';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.forcenewserver.def := 'T';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.a.forcenewserver.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.c.qimager.s := 'qimager(filename, compress, host, forcenewserver)';
help::pkg.synthesis.qimager.objs.qimager.m.open := [=];
help::pkg.synthesis.qimager.objs.qimager.m.open.d := 'Open a new MeasurementSet, for processing, closing current MeasurementSet';
help::pkg.synthesis.qimager.objs.qimager.m.open.a.thems := [=];
help::pkg.synthesis.qimager.objs.qimager.m.open.a.thems.d := 'New MeasurementSet to be processed';
help::pkg.synthesis.qimager.objs.qimager.m.open.a.thems.def := '\' MS\' ';
help::pkg.synthesis.qimager.objs.qimager.m.open.a.thems.a := 'Table name';
help::pkg.synthesis.qimager.objs.qimager.m.open.a.compress := [=];
help::pkg.synthesis.qimager.objs.qimager.m.open.a.compress.d := 'Compress calibration columns?';
help::pkg.synthesis.qimager.objs.qimager.m.open.a.compress.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.open.a.compress.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.open.s := 'open(thems, compress)';
help::pkg.synthesis.qimager.objs.qimager.m.close := [=];
help::pkg.synthesis.qimager.objs.qimager.m.close.d := 'Close the qimager tool, with data written on disk, keeping qimager process running for future use';
help::pkg.synthesis.qimager.objs.qimager.m.close.s := 'close()';
help::pkg.synthesis.qimager.objs.qimager.m.stop := [=];
help::pkg.synthesis.qimager.objs.qimager.m.stop.d := 'stop the currently executing function asap';
help::pkg.synthesis.qimager.objs.qimager.m.stop.s := 'stop()';
help::pkg.synthesis.qimager.objs.qimager.m.done := [=];
help::pkg.synthesis.qimager.objs.qimager.m.done.d := 'Terminate the qimager process';
help::pkg.synthesis.qimager.objs.qimager.m.done.s := 'done()';
help::pkg.synthesis.qimager.objs.qimager.m.summary := [=];
help::pkg.synthesis.qimager.objs.qimager.m.summary.d := 'Summarize the current state of the qimager tool';
help::pkg.synthesis.qimager.objs.qimager.m.summary.s := 'summary()';
help::pkg.synthesis.qimager.objs.qimager.m.setdata := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.d := 'Set the data parameters selection for subsequent processing';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mode := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mode.d := 'Type of processing: channel or velocity';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mode.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mode.a := '\' channel\' |\' velocity\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.nchan := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.nchan.d := 'Number of channels to select';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.nchan.def := '1';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.nchan.a := 'Vector of Ints';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.start := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.start.d := 'Start channels (1-relative)';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.start.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.start.a := ' Vector of Ints';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.step := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.step.d := 'Step in channel number';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.step.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.step.a := 'Vector of Int';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mstart := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mstart.d := 'Start velocity (e.g. \' 20Km/s\' )';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mstart.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mstart.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mstep := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mstep.d := 'Step in velocity (e.g. \' 100m/s\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mstep.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.mstep.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.spwid := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.spwid.d := 'Spectral Window Ids (1 relative) to select';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.spwid.def := '1';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.spwid.a := 'Vector of Ints';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.fieldid := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.fieldid.d := 'Field Ids (1 relative) to select';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.fieldid.def := '1';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.fieldid.a := 'Vector of Ints';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.msselect := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.msselect.d := 'TQL select string applied as a logical "and" with the other selections';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.msselect.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.msselect.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.setdata.s := 'setdata(mode, nchan, start, step, mstart, mstep, spwid, fieldid, msselect, async)';
help::pkg.synthesis.qimager.objs.qimager.m.setimage := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.d := 'Set the image parameters for subsequent processing';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.nx := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.nx.d := 'Total number of spatial pixels in x';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.nx.def := '128';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.nx.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.ny := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.ny.d := 'Total number of spatial pixels in y';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.ny.def := '128';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.ny.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.cellx := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.cellx.d := 'Cellsize in x (e.g. \' 1arcsec\' )';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.cellx.def := '\' 1arcsec\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.cellx.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.celly := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.celly.d := 'Cellsize in y (e.g. \' 1arcsec\' )';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.celly.def := '\' 1arcsec\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.celly.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.stokes := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.stokes.d := 'Stokes parameters to image (e.g. \' IQUV\' )';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.stokes.def := '\' I\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.stokes.a := '\' I\' |\' IV\' |\' IQU\' |\' IQUV\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.doshift := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.doshift.d := 'Use the specified phase center? T or F';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.doshift.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.doshift.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.phasecenter := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.phasecenter.d := 'Direction of phase center as a measure';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.phasecenter.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.phasecenter.a := 'MDirection';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.shiftx := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.shiftx.d := 'Shift in x (e.g. \' 23.7arcsec\' )';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.shiftx.def := '\' 0arcsec\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.shiftx.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.shifty := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.shifty.d := 'Shift in y (e.g. \' -54.2arcsec\' )';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.shifty.def := '\' 0arcsec\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.shifty.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mode := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mode.d := 'Type of processing';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mode.def := '\' mfs\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mode.a := '\' mfs\' |\' channel\' |\' velocity\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.nchan := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.nchan.d := 'Number of channels';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.nchan.def := '1';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.nchan.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.start := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.start.d := 'Start channel (1-relative)';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.start.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.start.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.step := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.step.d := 'Step in channel';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.step.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.step.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mstart := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mstart.d := 'Start velocity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mstart.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mstart.a := 'MRadialVelocity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mstep := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mstep.d := 'Step in velocity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mstep.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.mstep.a := 'MRadialVelocity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.spwid := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.spwid.d := 'Spectral Window Ids (1 relative)';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.spwid.def := '1';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.spwid.a := 'Vector of Ints';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.fieldid := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.fieldid.d := 'Field Id (1 relative)';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.fieldid.def := '1';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.fieldid.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.facets := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.facets.d := 'Number of facets on each axis';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.facets.def := '1';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.facets.a := 'Integer';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.distance := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.distance.d := 'Distance to object: usually ignore this! (m)';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.distance.def := '\' 0m\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.a.distance.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.setimage.s := 'setimage(nx, ny, cellx, celly, stokes, doshift, phasecenter, shiftx, shifty, mode, nchan, start, step, mstart, mstep, spwid, fieldid, facets, distance)';
help::pkg.synthesis.qimager.objs.qimager.m.advise := [=];
help::pkg.synthesis.qimager.objs.qimager.m.advise.d := 'Advise (and optionally use) parameter values';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.takeadvice := [=];
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.takeadvice.d := 'Use the advised values?';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.takeadvice.def := 'T';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.takeadvice.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.amplitudeloss := [=];
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.amplitudeloss.d := 'Maximum fractional amplitude loss due to faceting';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.amplitudeloss.def := '0.05';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.amplitudeloss.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.fieldofview := [=];
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.fieldofview.d := 'Desired field of view';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.fieldofview.def := '\' 1deg\' ';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.fieldofview.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.pixels := [=];
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.pixels.d := 'Number of pixels on a side';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.pixels.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.pixels.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.cell := [=];
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.cell.d := 'Recommended maximum cellsize';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.cell.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.cell.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.facets := [=];
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.facets.d := 'Recommended number of facets on one axis';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.facets.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.facets.a := 'Integer';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.phasecenter := [=];
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.phasecenter.d := 'Direction of phase center as a measure';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.phasecenter.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.advise.a.phasecenter.a := 'MDirection';
help::pkg.synthesis.qimager.objs.qimager.m.advise.s := 'advise(takeadvice, amplitudeloss, fieldofview, pixels, cell, facets, phasecenter)';
help::pkg.synthesis.qimager.objs.qimager.m.make := [=];
help::pkg.synthesis.qimager.objs.qimager.m.make.d := 'Make an empty (i.e. blank) image';
help::pkg.synthesis.qimager.objs.qimager.m.make.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.make.a.image.d := 'name of output image';
help::pkg.synthesis.qimager.objs.qimager.m.make.a.image.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.make.a.image.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.make.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.make.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.make.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.make.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.make.s := 'make(image, async)';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask := [=];
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.d := 'Construct a mask image from a region';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.mask := [=];
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.mask.d := 'name of mask image';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.mask.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.mask.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.region := [=];
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.region.d := 'Region';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.region.def := 'unset';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.region.a := 'Any valid region or a record of regions';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.value := [=];
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.value.d := 'Value to set the mask to';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.value.def := '1.0';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.a.value.a := 'Any scalar';
help::pkg.synthesis.qimager.objs.qimager.m.regionmask.s := 'regionmask(mask, region, value)';
help::pkg.synthesis.qimager.objs.qimager.m.exprmask := [=];
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.d := 'Construct a mask image from a LEL expression';
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.a.mask := [=];
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.a.mask.d := 'name of mask image';
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.a.mask.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.a.mask.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.a.expr := [=];
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.a.expr.d := 'Value to set the mask to';
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.a.expr.def := '1.0';
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.a.expr.a := 'Any scalar or LEL expression';
help::pkg.synthesis.qimager.objs.qimager.m.exprmask.s := 'exprmask(mask, expr)';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage := [=];
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.d := 'Calculate images by gridding, etc.';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.type := [=];
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.type.d := 'Type of output image';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.type.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.type.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.image.d := 'Name of output image';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.image.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.image.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.compleximage := [=];
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.compleximage.d := 'Name of output complex image';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.compleximage.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.compleximage.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.makeimage.s := 'makeimage(type, image, compleximage, async)';
help::pkg.synthesis.qimager.objs.qimager.m.weight := [=];
help::pkg.synthesis.qimager.objs.qimager.m.weight.d := 'Apply additional weighting to the visibility weights';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.type := [=];
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.type.d := 'Type of weighting';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.type.def := 'uniform';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.type.a := 'String: \' uniform\' |\' natural\' |\' briggs\' |\' radial\' ';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.rmode := [=];
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.rmode.d := 'Mode of briggs weighting';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.rmode.def := 'none';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.rmode.a := 'String: \' norm\' |\' abs\' |\' none\' ';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.noise := [=];
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.noise.d := 'Noise used in absolute briggs weighting';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.noise.def := '\' 0.0Jy\' ';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.noise.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.robust := [=];
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.robust.d := 'Parameter in briggs weighting';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.robust.def := '0.0';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.robust.a := 'Double: range -2.0 to 2.0';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.fieldofview := [=];
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.fieldofview.d := 'Field of view for uniform weighting';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.fieldofview.def := '\' 0arcsec\' ';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.fieldofview.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.npixels := [=];
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.npixels.d := 'Number of pixels in the u and v directions';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.npixels.def := '0';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.npixels.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.weight.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.weight.s := 'weight(type, rmode, noise, robust, fieldofview, npixels, async)';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity := [=];
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.d := 'Calculate rms  sensitivity';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.pointsource := [=];
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.pointsource.d := 'Calculated point source sensitivity (Jy/beam)';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.pointsource.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.pointsource.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.relative := [=];
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.relative.d := 'Calculated relative sensitivity';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.relative.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.relative.a := 'Double';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.sumweights := [=];
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.sumweights.d := 'Calculated sum of weights';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.sumweights.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.sumweights.a := 'Double';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.sensitivity.s := 'sensitivity(pointsource, relative, sumweights, async)';
help::pkg.synthesis.qimager.objs.qimager.m.filter := [=];
help::pkg.synthesis.qimager.objs.qimager.m.filter.d := 'Apply additional weighting by filtering (u-v taper)';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.type := [=];
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.type.d := 'Type of filtering or u-v tapering';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.type.def := 'gaussian';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.type.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bmaj := [=];
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bmaj.d := 'Major axis of filter';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bmaj.def := '\' 0rad\' ';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bmaj.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bmin := [=];
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bmin.d := 'Minor axis of filter';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bmin.def := '\' 0rad\' ';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bmin.a := 'Quantiy';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bpa := [=];
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bpa.d := 'Position angle of filter';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bpa.def := '\' 0deg\' ';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.bpa.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.filter.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.filter.s := 'filter(type, bmaj, bmin, bpa, async)';
help::pkg.synthesis.qimager.objs.qimager.m.uvrange := [=];
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.d := 'Select data within the limit of a given range';
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.a.uvmin := [=];
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.a.uvmin.d := 'Minimum uv distance allowed (wavelengths)';
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.a.uvmin.def := '0.0';
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.a.uvmin.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.a.uvmax := [=];
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.a.uvmax.d := 'Maximum uv distance allowed (wavelengths)';
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.a.uvmax.def := '0.0';
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.a.uvmax.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.uvrange.s := 'uvrange(uvmin, uvmax)';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf := [=];
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.d := 'Fit the point spread function, making psf image first if needed';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.psf := [=];
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.psf.d := 'Name of input psf';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.psf.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.psf.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bmaj := [=];
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bmaj.d := 'Major axis of beam';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bmaj.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bmaj.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bmin := [=];
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bmin.d := 'Minor axis of beam';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bmin.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bmin.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bpa := [=];
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bpa.d := 'Position angle of beam';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bpa.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.bpa.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.fitpsf.s := 'fitpsf(psf, bmaj, bmin, bpa, async)';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.d := 'Set the beam parameters for clean restoration';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bmaj := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bmaj.d := 'Major axis of beam';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bmaj.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bmaj.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bmin := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bmin.d := 'Minor axis of beam';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bmin.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bmin.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bpa := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bpa.d := 'Position angle of beam';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bpa.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.bpa.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.setbeam.s := 'setbeam(bmaj, bmin, bpa, async)';
help::pkg.synthesis.qimager.objs.qimager.m.clean := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.d := 'Calculate a deconvolved image with selected clean algorithm';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.algorithm := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.algorithm.d := 'Algorithm to use';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.algorithm.def := '\' clark\' ';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.algorithm.a := 'String:\' clark\' |\' hogbom\' |\' multiscale\' |\' mfclark\' |\' csclean\' |\' csfast\' | \' mfhogbom\' |\' mfmultiscale\' |\' wfclark\' |\' wfhogbom\' ';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.niter := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.niter.d := 'Number of Iterations, set to zero for no CLEANing';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.niter.def := '1000';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.niter.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.gain := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.gain.d := 'Loop Gain for CLEANing';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.gain.def := '0.1';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.gain.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.threshold := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.threshold.d := 'Flux level at which to stop CLEANing';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.threshold.def := '\' 0Jy\' ';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.threshold.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.displayprogress := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.displayprogress.d := 'Display the progress of the cleaning?';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.displayprogress.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.displayprogress.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.model.d := 'Names of clean model images';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.model.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.fixed := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.fixed.d := 'Keep one or more models fixed';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.fixed.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.fixed.a := 'Vector of booleans';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.complist := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.complist.d := 'Name of component list';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.complist.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.complist.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.mask := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.mask.d := 'Names of mask images used for CLEANing';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.mask.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.mask.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.image.d := 'Names of restored images';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.image.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.image.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.residual := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.residual.d := 'Names of residual images';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.residual.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.residual.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.interactive := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.interactive.d := 'whether to stop clean and interactively mask';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.interactive.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.interactive.a := 'Boolean';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.npercycle := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.npercycle.d := 'If interactive is \' T\' , then no of iter of clean  before stopping, usually a fraction of niter';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.npercycle.def := '100';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.npercycle.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.masktemplate := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.masktemplate.d := 'If non empty then will use this image to make the mask the first time';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.masktemplate.def := '\' \' ';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.masktemplate.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.clean.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.clean.s := 'clean(algorithm, niter, gain, threshold, displayprogress, model, fixed, complist, mask, image, residual, interactive, npercycle, masktemplate, async)';
help::pkg.synthesis.qimager.objs.qimager.m.mem := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.d := 'Calculate a deconvolved image with selected mem (maximum entropy) algorithm';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.algorithm := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.algorithm.d := 'Algorithm to use';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.algorithm.def := '\' entropy\' ';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.algorithm.a := 'String:\' entropy\' |\' emptiness\' |\' mfentropy\' |\' mfemptiness\' ';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.niter := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.niter.d := 'Number of Iterations';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.niter.def := '20';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.niter.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.sigma := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.sigma.d := 'Image sigma to try to achieve';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.sigma.def := '\' 0.001Jy\' ';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.sigma.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.gain := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.gain.d := 'Gain for step';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.gain.def := '0.3';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.gain.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.targetflux := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.targetflux.d := 'Target flux for final image';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.targetflux.def := '\' 1.0Jy\' ';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.targetflux.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.constrainflux := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.constrainflux.d := 'Constrain image to match target flux? else targetflux used only to initialize model';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.constrainflux.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.constrainflux.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.displayprogress := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.displayprogress.d := 'Display the progress of the cleaning?';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.displayprogress.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.displayprogress.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.model.d := 'Names of model images';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.model.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.fixed := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.fixed.d := 'Keep model fixed';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.fixed.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.fixed.a := 'Vector of booleans';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.complist := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.complist.d := 'Name of component list';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.complist.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.complist.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.prior := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.prior.d := 'Names of mem prior images';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.prior.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.prior.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.mask := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.mask.d := 'Names of mask images (0=>no emission, 1=>emission permitted';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.mask.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.mask.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.image.d := 'Names of restored images';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.image.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.image.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.residual := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.residual.d := 'Names of residual images';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.residual.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.residual.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.mem.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.mem.s := 'mem(algorithm, niter, sigma, gain, targetflux, constrainflux, displayprogress, model, fixed, complist, prior, mask, image, residual, async)';
help::pkg.synthesis.qimager.objs.qimager.m.nnls := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.d := 'Calculate a deconvolved image using the  NNLS algorithm';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.model.d := 'Name of image';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.model.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.fixed := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.fixed.d := 'Keep model fixed';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.fixed.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.fixed.a := 'Vector of booleans';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.complist := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.complist.d := 'Name of component list';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.complist.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.complist.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.niter := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.niter.d := 'Number of Iterations, set to zero for no NNLS';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.niter.def := '0';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.niter.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.tolerance := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.tolerance.d := 'Tolerance for solution';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.tolerance.def := '1e-06';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.tolerance.a := 'Double';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.fluxmask := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.fluxmask.d := 'Name of mask for allowed flux';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.fluxmask.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.fluxmask.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.datamask := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.datamask.d := 'Name of mask for constraint pixels in dirty image';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.datamask.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.datamask.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.image.d := 'Names of restored images';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.image.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.image.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.residual := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.residual.d := 'Names of restored images';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.residual.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.residual.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.nnls.s := 'nnls(model, fixed, complist, niter, tolerance, fluxmask, datamask, image, residual, async)';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.d := 'Set various cycle control parameters for  multi-field and wide-field imageing.';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.cyclefactor := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.cyclefactor.d := 'Cycle threshold = this * max sidelobe * max resid';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.cyclefactor.def := '1.5';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.cyclefactor.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.cyclespeedup := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.cyclespeedup.d := 'Cycle threshold doubles in this number of iterations';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.cyclespeedup.def := '-1';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.cyclespeedup.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.stoplargenegatives := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.stoplargenegatives.d := 'Stop the multiscale cycle for the first n cycles when a negative comp is found on the largest scale';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.stoplargenegatives.def := '2';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.stoplargenegatives.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.stoppointmode := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.stoppointmode.d := 'Stop multiscale altogether if the smallest scale recieves this many consecutive components';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.stoppointmode.def := '-1';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.a.stoppointmode.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setmfcontrol.s := 'setmfcontrol(cyclefactor, cyclespeedup, stoplargenegatives, stoppointmode)';
help::pkg.synthesis.qimager.objs.qimager.m.feather := [=];
help::pkg.synthesis.qimager.objs.qimager.m.feather.d := 'Feather together an interferometer and a single dish image in the Fourier plane';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.image.d := 'Name of output feathered image';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.image.def := '\' feathered.image\' ';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.image.a := 'Image';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.highres := [=];
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.highres.d := 'Name of high resolution (interferometer) image';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.highres.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.highres.a := 'Image';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.lowres := [=];
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.lowres.d := 'Name of low resolution (single dish) image';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.lowres.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.lowres.a := 'Image';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.lowpsf := [=];
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.lowpsf.d := 'Name of optional low resolution point spread function';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.lowpsf.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.lowpsf.a := 'Image';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.usedefaultvp := [=];
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.usedefaultvp.d := 'Use the default vp type?';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.usedefaultvp.def := 'T';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.usedefaultvp.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.vptable := [=];
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.vptable.d := 'Voltage pattern table from the vpmanager for detailed specification';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.vptable.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.vptable.a := 'Table';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.feather.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.feather.s := 'feather(image, highres, lowres, lowpsf, usedefaultvp, vptable, async)';
help::pkg.synthesis.qimager.objs.qimager.m.pb := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.d := 'Applies or corrects for a primary beam';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.inimage := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.inimage.d := 'Input image to apply beam to';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.inimage.def := 'None';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.inimage.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.outimage := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.outimage.d := 'Output image after beam is applied';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.outimage.def := 'No output image';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.outimage.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.incomps := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.incomps.d := 'Input Componentlist table name';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.incomps.def := 'None';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.incomps.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.outcomps := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.outcomps.d := 'Output Componentlist table name';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.outcomps.def := 'No output Componentlist';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.outcomps.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.operation := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.operation.d := 'Operation';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.operation.def := '\' apply\' ';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.operation.a := 'String from \' apply\'  or \' correct\' ';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.pointingcenter := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.pointingcenter.d := 'Pointing center for primary beam application';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.pointingcenter.def := 'F in CLI or the N. pole in the GUI';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.pointingcenter.a := 'F or Direction measure';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.parangle := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.parangle.d := 'Parallactic angle for calculation';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.parangle.def := '\' 0deg\' ';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.parangle.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.pborvp := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.pborvp.d := 'Primary Beam or Voltage Pattern ';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.pborvp.def := '\' pb\' ';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.pborvp.a := 'String from \' pb\'  or \' vp\' ';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.pb.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.pb.s := 'pb(inimage, outimage, incomps, outcomps, operation, pointingcenter, parangle, pborvp, async)';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.d := 'Make a linear mosaic of several images';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.images := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.images.d := 'Input images to be mosaiced';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.images.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.images.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.mosaic := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.mosaic.d := 'Output mosaic image';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.mosaic.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.mosaic.a := 'Image';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.fluxscale := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.fluxscale.d := 'Fluxscale image';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.fluxscale.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.fluxscale.a := 'Image';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.sensitivity := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.sensitivity.d := 'Sensitivity image';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.sensitivity.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.sensitivity.a := 'Image';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.fieldids := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.fieldids.d := 'output component list after PB has been applied [optional]';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.fieldids.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.fieldids.a := 'Vector of Ints';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.usedefaultvp := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.usedefaultvp.d := 'Use the default vp type?';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.usedefaultvp.def := 'T';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.usedefaultvp.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.vptable := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.vptable.d := 'Voltage pattern table from the vpmanager for detailed specification';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.vptable.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.vptable.a := 'Table';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.linearmosaic.s := 'linearmosaic(images, mosaic, fluxscale, sensitivity, fieldids, usedefaultvp, vptable, async)';
help::pkg.synthesis.qimager.objs.qimager.m.predict := [=];
help::pkg.synthesis.qimager.objs.qimager.m.predict.d := 'Predict the data from the specified model and componentlist';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.model.d := 'Name of image';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.model.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.complist := [=];
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.complist.d := 'Name of component list';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.complist.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.complist.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.incremental := [=];
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.incremental.d := 'Add to the existing MODEL\_DATA column?';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.incremental.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.incremental.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.predict.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.predict.s := 'predict(model, complist, incremental, async)';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf := [=];
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.d := 'Calculate approximate point spread functions';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.model.d := 'Names of input models';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.model.a := 'Vector of Strings';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.psf := [=];
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.psf.d := 'Names of output point spread functions';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.psf.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.psf.a := 'Vector of Strings';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.approximatepsf.s := 'approximatepsf(model, psf, async)';
help::pkg.synthesis.qimager.objs.qimager.m.restore := [=];
help::pkg.synthesis.qimager.objs.qimager.m.restore.d := 'Calculate the restored image with restored model, component list, and  residuals';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.model.d := 'Names of input model';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.model.a := 'Vector of Strings';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.complist := [=];
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.complist.d := 'Name of component list';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.complist.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.complist.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.image.d := 'Names of output restored images';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.image.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.image.a := 'Vector of Strings';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.residual := [=];
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.residual.d := 'Names of residual images';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.residual.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.residual.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.restore.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.restore.s := 'restore(model, complist, image, residual, async)';
help::pkg.synthesis.qimager.objs.qimager.m.residual := [=];
help::pkg.synthesis.qimager.objs.qimager.m.residual.d := 'Calculate the residual image with respect to current model and component list';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.model.d := 'Names of input models';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.model.a := 'Vector of Strings';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.complist := [=];
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.complist.d := 'Name of component list';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.complist.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.complist.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.image.d := 'Names of output residual images';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.image.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.image.a := 'Vector of Strings';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.residual.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.residual.s := 'residual(model, complist, image, async)';
help::pkg.synthesis.qimager.objs.qimager.m.smooth := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.d := 'Calculate an image smoothed with a Gaussian beam';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.model.d := 'Name of input model';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.model.a := 'Vector of Strings';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.image := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.image.d := 'Name of output smoothed images';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.image.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.image.a := 'Vector of Strings';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.usefit := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.usefit.d := 'Use the fitted value (rather than that specified';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.usefit.def := 'T';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.usefit.a := 'Boolean';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bmaj := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bmaj.d := 'Major axis of beam';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bmaj.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bmaj.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bmin := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bmin.d := 'Minor axis of beam';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bmin.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bmin.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bpa := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bpa.d := 'Position angle of beam';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bpa.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.bpa.a := 'Quantity record';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.normalize := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.normalize.d := 'Normalize volume of psf to unity';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.normalize.def := 'T';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.normalize.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.async := [=];
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.async.d := 'Run asynchronously in the background';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.async.def := '!dowait';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.a.async.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.smooth.s := 'smooth(model, image, usefit, bmaj, bmin, bpa, normalize, async)';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.d := 'Set some general options for subsequent processing';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.ftmachine := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.ftmachine.d := 'Fourier transform machine';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.ftmachine.def := '\' ft\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.ftmachine.a := 'String:\' ft\' |\' sd\' |\' both\'  | \' wfmemoryft\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.cache := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.cache.d := 'Size of gridding cache in complex pixels';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.cache.def := '4194304';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.cache.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.tile := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.tile.d := 'Size of a gridding tile in pixels (in 1 dimension)';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.tile.def := '16';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.tile.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.gridfunction := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.gridfunction.d := 'Gridding function';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.gridfunction.def := '\' SF\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.gridfunction.a := 'String: \' SF\' |\' BOX\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.padding := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.padding.d := 'Padding factor in image plane (>=1.0)';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.padding.def := '1.0';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.a.padding.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.setoptions.s := 'setoptions(ftmachine, cache, tile, gridfunction, padding)';
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.d := 'Set some options for single dish processing';
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.a.scale := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.a.scale.d := 'Scaling applied to single dish data';
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.a.scale.def := '1.0';
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.a.scale.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.a.weight := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.a.weight.d := 'Weights applied to single dish data';
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.a.weight.def := '1.0';
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.a.weight.a := 'Float';
help::pkg.synthesis.qimager.objs.qimager.m.setsdoptions.s := 'setsdoptions(scale, weight)';
help::pkg.synthesis.qimager.objs.qimager.m.setvp := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setvp.d := 'Set the voltage pattern model for subsequent processing';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.dovp := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.dovp.d := 'Do voltage pattern (ie, primary beam) correction';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.dovp.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.dovp.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.usedefaultvp := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.usedefaultvp.d := 'Look up the default VP for this telescope and frequency?';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.usedefaultvp.def := 'T';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.usedefaultvp.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.vptable := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.vptable.d := 'If usedefaultvp is false, provide a VP Table made with vpmanager';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.vptable.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.vptable.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.dosquint := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.dosquint.d := 'Activate the beam squint in the VP model';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.dosquint.def := 'F';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.dosquint.a := 'Bool';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.parangleinc := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.parangleinc.d := 'Parallactice angle increment for squint application';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.parangleinc.def := '360deg';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.a.parangleinc.a := 'Quantity';
help::pkg.synthesis.qimager.objs.qimager.m.setvp.s := 'setvp(dovp, usedefaultvp, vptable, dosquint, parangleinc)';
help::pkg.synthesis.qimager.objs.qimager.m.setscales := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setscales.d := 'Set the scale sizes for MultiScale Clean';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.scalemethod := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.scalemethod.d := 'Method by which scales are set';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.scalemethod.def := 'nscales';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.scalemethod.a := 'String: \' nscales\' |\' uservector\' ';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.nscales := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.nscales.d := 'Number of scales';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.nscales.def := '5';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.nscales.a := 'Int';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.uservector := [=];
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.uservector.d := 'Vector of scale sizes to use';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.uservector.def := '[0, 3, 10]';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.a.uservector.a := 'Vector of Doubles';
help::pkg.synthesis.qimager.objs.qimager.m.setscales.s := 'setscales(scalemethod, nscales, uservector)';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal := [=];
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.d := 'Self-calibrate the MeasurementSet using a calibrater tool and model+component list';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.caltool := [=];
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.caltool.d := 'Glish name of calibrater tool';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.caltool.def := 'NONE!';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.caltool.a := 'Any valid calibrater tool';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.model := [=];
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.model.d := 'Name of images';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.model.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.model.a := 'Vector of strings';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.complist := [=];
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.complist.d := 'Name of component list';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.complist.def := '';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.a.complist.a := 'String';
help::pkg.synthesis.qimager.objs.qimager.m.selfcal.s := 'selfcal(caltool, model, complist)';
help::pkg.synthesis.qimager.funs.qimagermaketestms := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestms.a := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestms.d := 'Make a standard MeasurementSet that can be used for experimentation';
help::pkg.synthesis.qimager.funs.qimagermaketestms.a.msfile := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestms.a.msfile.d := 'Name of output ms';
help::pkg.synthesis.qimager.funs.qimagermaketestms.a.msfile.def := '\' 3C273XC1.ms\' ';
help::pkg.synthesis.qimager.funs.qimagermaketestms.a.msfile.a := 'String';
help::pkg.synthesis.qimager.funs.qimagermaketestms.s := 'qimagermaketestms(msfile)';
help::pkg.synthesis.qimager.funs.qimagermaketestsdms := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestsdms.a := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestsdms.d := 'Make a standard single dish MeasurementSet that can be used for experimentation';
help::pkg.synthesis.qimager.funs.qimagermaketestsdms.a.msfile := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestsdms.a.msfile.d := 'Name of output ms';
help::pkg.synthesis.qimager.funs.qimagermaketestsdms.a.msfile.def := '\' gbt\_cygnus\_800MHz.ms\' ';
help::pkg.synthesis.qimager.funs.qimagermaketestsdms.a.msfile.a := 'String';
help::pkg.synthesis.qimager.funs.qimagermaketestsdms.s := 'qimagermaketestsdms(msfile)';
help::pkg.synthesis.qimager.funs.qimagermaketestmfms := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestmfms.a := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestmfms.d := 'Make a standard multifield MeasurementSet that can be used for experimentation';
help::pkg.synthesis.qimager.funs.qimagermaketestmfms.a.msfile := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestmfms.a.msfile.d := 'Name of output ms';
help::pkg.synthesis.qimager.funs.qimagermaketestmfms.a.msfile.def := '\' XCAS.ms\' ';
help::pkg.synthesis.qimager.funs.qimagermaketestmfms.a.msfile.a := 'String';
help::pkg.synthesis.qimager.funs.qimagermaketestmfms.s := 'qimagermaketestmfms(msfile)';
help::pkg.synthesis.qimager.funs.qimagermaketestcl := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestcl.d := 'Make a standard componentlist for a standard MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a.clfile := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a.clfile.d := 'Name of output cl';
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a.clfile.def := '\' 3C273XC1.cl\' ';
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a.clfile.a := 'String';
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a.refer := [=];
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a.refer.d := 'Reference';
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a.refer.def := '\' gal\' ';
help::pkg.synthesis.qimager.funs.qimagermaketestcl.a.refer.a := 'String';
help::pkg.synthesis.qimager.funs.qimagermaketestcl.s := 'qimagermaketestcl(clfile, refer)';
help::pkg.synthesis.qimager.funs.qimagertest := [=];
help::pkg.synthesis.qimager.funs.qimagertest.a := [=];
help::pkg.synthesis.qimager.funs.qimagertest.d := 'Perform a test of imaging from a standard MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagertest.a.size := [=];
help::pkg.synthesis.qimager.funs.qimagertest.a.size.d := 'Number of pixels on a side';
help::pkg.synthesis.qimager.funs.qimagertest.a.size.def := '128';
help::pkg.synthesis.qimager.funs.qimagertest.a.size.a := 'Int';
help::pkg.synthesis.qimager.funs.qimagertest.a.cleanniter := [=];
help::pkg.synthesis.qimager.funs.qimagertest.a.cleanniter.d := 'Number of clean iterations';
help::pkg.synthesis.qimager.funs.qimagertest.a.cleanniter.def := '1000';
help::pkg.synthesis.qimager.funs.qimagertest.a.cleanniter.a := 'Int';
help::pkg.synthesis.qimager.funs.qimagertest.a.cleangain := [=];
help::pkg.synthesis.qimager.funs.qimagertest.a.cleangain.d := 'Clean loop gain';
help::pkg.synthesis.qimager.funs.qimagertest.a.cleangain.def := '0.1';
help::pkg.synthesis.qimager.funs.qimagertest.a.cleangain.a := 'Float';
help::pkg.synthesis.qimager.funs.qimagertest.a.doshift := [=];
help::pkg.synthesis.qimager.funs.qimagertest.a.doshift.d := 'Shift the phase center';
help::pkg.synthesis.qimager.funs.qimagertest.a.doshift.def := 'T';
help::pkg.synthesis.qimager.funs.qimagertest.a.doshift.a := 'Bool';
help::pkg.synthesis.qimager.funs.qimagertest.a.doplot := [=];
help::pkg.synthesis.qimager.funs.qimagertest.a.doplot.d := 'Plot?';
help::pkg.synthesis.qimager.funs.qimagertest.a.doplot.def := 'T';
help::pkg.synthesis.qimager.funs.qimagertest.a.doplot.a := 'Bool';
help::pkg.synthesis.qimager.funs.qimagertest.s := 'qimagertest(size, cleanniter, cleangain, doshift, doplot)';
help::pkg.synthesis.qimager.funs.qimagerlongtest := [=];
help::pkg.synthesis.qimager.funs.qimagerlongtest.a := [=];
help::pkg.synthesis.qimager.funs.qimagerlongtest.d := 'Perform a long test of imaging from a standard MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagerlongtest.s := 'qimagerlongtest()';
help::pkg.synthesis.qimager.funs.qimagermftest := [=];
help::pkg.synthesis.qimager.funs.qimagermftest.a := [=];
help::pkg.synthesis.qimager.funs.qimagermftest.d := 'Perform a test of multi-field processing using a standard MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagermftest.a.doplot := [=];
help::pkg.synthesis.qimager.funs.qimagermftest.a.doplot.d := 'Plot?';
help::pkg.synthesis.qimager.funs.qimagermftest.a.doplot.def := 'T';
help::pkg.synthesis.qimager.funs.qimagermftest.a.doplot.a := 'Bool';
help::pkg.synthesis.qimager.funs.qimagermftest.s := 'qimagermftest(doplot)';
help::pkg.synthesis.qimager.funs.qimagerspectraltest := [=];
help::pkg.synthesis.qimager.funs.qimagerspectraltest.a := [=];
help::pkg.synthesis.qimager.funs.qimagerspectraltest.d := 'Perform a test of spectral processing using a standard spectral line MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagerspectraltest.s := 'qimagerspectraltest()';
help::pkg.synthesis.qimager.funs.qimagerpbtest := [=];
help::pkg.synthesis.qimager.funs.qimagerpbtest.a := [=];
help::pkg.synthesis.qimager.funs.qimagerpbtest.d := 'Perform a test of primary beam processing using a standard MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagerpbtest.s := 'qimagerpbtest()';
help::pkg.synthesis.qimager.funs.qimagercomponenttest := [=];
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a := [=];
help::pkg.synthesis.qimager.funs.qimagercomponenttest.d := 'Perform a test of component model processing using a standard MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.size := [=];
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.size.d := 'Number of pixels on a side';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.size.def := '128';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.size.a := 'Int';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.doshift := [=];
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.doshift.d := 'Shift the phase center';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.doshift.def := 'T';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.doshift.a := 'Bool';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.doplot := [=];
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.doplot.d := 'Plot?';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.doplot.def := 'T';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.a.doplot.a := 'Bool';
help::pkg.synthesis.qimager.funs.qimagercomponenttest.s := 'qimagercomponenttest(size, doshift, doplot)';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest := [=];
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a := [=];
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.d := 'Perform a test of selfcal processing using a standard MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.size := [=];
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.size.d := 'Number of pixels on a side';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.size.def := '128';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.size.a := 'Int';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.doshift := [=];
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.doshift.d := 'Shift the phase center';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.doshift.def := 'T';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.doshift.a := 'Bool';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.doplot := [=];
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.doplot.d := 'Plot?';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.doplot.def := 'T';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.a.doplot.a := 'Bool';
help::pkg.synthesis.qimager.funs.qimagerselfcaltest.s := 'qimagerselfcaltest(size, doshift, doplot)';
help::pkg.synthesis.qimager.funs.qimagersdtest := [=];
help::pkg.synthesis.qimager.funs.qimagersdtest.a := [=];
help::pkg.synthesis.qimager.funs.qimagersdtest.d := 'Perform a test of single dish imaging from a standard MeasurementSet';
help::pkg.synthesis.qimager.funs.qimagersdtest.s := 'qimagersdtest()';
help::pkg.synthesis.qimager.funs.qimageralltests := [=];
help::pkg.synthesis.qimager.funs.qimageralltests.a := [=];
help::pkg.synthesis.qimager.funs.qimageralltests.d := 'Perform all qimager tests using standard MeasurementSets';
help::pkg.synthesis.qimager.funs.qimageralltests.s := 'qimageralltests()';
help::pkg.synthesis.qimager.funs.qimagermultiscale := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.d := 'Makes multi-resolution multiscale images.';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.msname := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.msname.d := 'Name of input ms';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.msname.def := '\' \' ';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.msname.a := 'String';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.imsizes := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.imsizes.d := 'Image sizes for each round (should be monatonically increasing)';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.imsizes.def := '[128, 256]';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.imsizes.a := 'Vector of Ints';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.cellsizes := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.cellsizes.d := 'Cell sizes [in arcsec] for each round (should be monatonically decreasing)';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.cellsizes.def := '[2, 1]';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.cellsizes.a := 'Vector of Floats';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.scales := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.scales.d := 'Name of input ms';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.scales.def := '[0, 5, 15]';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.scales.a := 'Vector of Ints';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.nitermult := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.nitermult.d := 'Multiplier parameter used to adjust niter with imsizes';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.nitermult.def := '0.15';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.nitermult.a := 'Float';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.niterpower := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.niterpower.d := 'Exponent of imsizes used to adjust niter with imsizes';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.niterpower.def := '1.2';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.niterpower.a := 'Float';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.fields := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.fields.d := 'Vector of field ids to image';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.fields.def := '[1]';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.fields.a := 'Vector of Ints';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.spwid := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.spwid.d := 'Spectral window to image';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.spwid.def := '1';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.spwid.a := 'Int';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.centerfield := [=];
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.centerfield.d := 'Field id for central pointing';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.centerfield.def := '1';
help::pkg.synthesis.qimager.funs.qimagermultiscale.a.centerfield.a := 'Int';
help::pkg.synthesis.qimager.funs.qimagermultiscale.s := 'qimagermultiscale(msname, imsizes, cellsizes, scales, nitermult, niterpower, fields, spwid, centerfield)';

help::pkg.synthesis.map := [=];
help::pkg.synthesis.map.objs := [=];
help::pkg.synthesis.map.funs := [=];
help::pkg.synthesis.map.d := 'Combined synthesis calibration and imaging';
help::pkg.synthesis.map.objs.map := [=];
help::pkg.synthesis.map.objs.map.m := [=];
help::pkg.synthesis.map.objs.map.c := [=];
help::pkg.synthesis.map.objs.map.d := 'Combined synthesis calibration and imaging';
help::pkg.synthesis.map.objs.map.c.map := [=];
help::pkg.synthesis.map.objs.map.c.map.d := 'Create a map tool from an AIPS++\ Measurement Set';
help::pkg.synthesis.map.objs.map.c.map.a.msfile := [=];
help::pkg.synthesis.map.objs.map.c.map.a.msfile.d := 'Input Measurement Set name';
help::pkg.synthesis.map.objs.map.c.map.a.msfile.def := '';
help::pkg.synthesis.map.objs.map.c.map.a.msfile.a := 'Table name';
help::pkg.synthesis.map.objs.map.c.map.s := 'map(msfile)';
help::pkg.synthesis.map.objs.map.m.solvecal := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.d := 'Solve for calibration components';
help::pkg.synthesis.map.objs.map.m.solvecal.a.sourcemodels := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.a.sourcemodels.d := 'List of source models';
help::pkg.synthesis.map.objs.map.m.solvecal.a.sourcemodels.def := 'unset';
help::pkg.synthesis.map.objs.map.m.solvecal.a.sourcemodels.a := 'Modellist';
help::pkg.synthesis.map.objs.map.m.solvecal.a.selection := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.a.selection.d := 'MS data selection';
help::pkg.synthesis.map.objs.map.m.solvecal.a.selection.def := 'unset';
help::pkg.synthesis.map.objs.map.m.solvecal.a.selection.a := 'Selection';
help::pkg.synthesis.map.objs.map.m.solvecal.a.calibration := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.a.calibration.d := 'List of applied calibration';
help::pkg.synthesis.map.objs.map.m.solvecal.a.calibration.def := 'unset';
help::pkg.synthesis.map.objs.map.m.solvecal.a.calibration.a := 'Calibrationlist';
help::pkg.synthesis.map.objs.map.m.solvecal.a.solvers := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.a.solvers.d := 'List of calibration solvers';
help::pkg.synthesis.map.objs.map.m.solvecal.a.solvers.def := 'unset';
help::pkg.synthesis.map.objs.map.m.solvecal.a.solvers.a := 'Solverlist';
help::pkg.synthesis.map.objs.map.m.solvecal.s := 'solvecal(sourcemodels, selection, calibration, solvers)';
help::pkg.synthesis.map.objs.map.m.applycal := [=];
help::pkg.synthesis.map.objs.map.m.applycal.d := 'Apply existing calibration to a Measurement Set';
help::pkg.synthesis.map.objs.map.m.applycal.a.selection := [=];
help::pkg.synthesis.map.objs.map.m.applycal.a.selection.d := 'MS data selection';
help::pkg.synthesis.map.objs.map.m.applycal.a.selection.def := 'unset';
help::pkg.synthesis.map.objs.map.m.applycal.a.selection.a := 'Selection';
help::pkg.synthesis.map.objs.map.m.applycal.a.calibration := [=];
help::pkg.synthesis.map.objs.map.m.applycal.a.calibration.d := 'List of calibration to apply';
help::pkg.synthesis.map.objs.map.m.applycal.a.calibration.def := 'unset';
help::pkg.synthesis.map.objs.map.m.applycal.a.calibration.a := 'Calibrationlist';
help::pkg.synthesis.map.objs.map.m.applycal.s := 'applycal(selection, calibration)';
help::pkg.synthesis.map.objs.map.m.solvecal := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.d := 'Solve for calibration components';
help::pkg.synthesis.map.objs.map.m.solvecal.a.sourcemodels := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.a.sourcemodels.d := 'List of source models';
help::pkg.synthesis.map.objs.map.m.solvecal.a.sourcemodels.def := 'unset';
help::pkg.synthesis.map.objs.map.m.solvecal.a.sourcemodels.a := 'Modellist';
help::pkg.synthesis.map.objs.map.m.solvecal.a.selection := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.a.selection.d := 'MS data selection';
help::pkg.synthesis.map.objs.map.m.solvecal.a.selection.def := 'unset';
help::pkg.synthesis.map.objs.map.m.solvecal.a.selection.a := 'Selection';
help::pkg.synthesis.map.objs.map.m.solvecal.a.calibration := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.a.calibration.d := 'List of applied calibration';
help::pkg.synthesis.map.objs.map.m.solvecal.a.calibration.def := 'unset';
help::pkg.synthesis.map.objs.map.m.solvecal.a.calibration.a := 'Calibrationlist';
help::pkg.synthesis.map.objs.map.m.solvecal.a.solvers := [=];
help::pkg.synthesis.map.objs.map.m.solvecal.a.solvers.d := 'List of calibration solvers';
help::pkg.synthesis.map.objs.map.m.solvecal.a.solvers.def := 'unset';
help::pkg.synthesis.map.objs.map.m.solvecal.a.solvers.a := 'Solverlist';
help::pkg.synthesis.map.objs.map.m.solvecal.s := 'solvecal(sourcemodels, selection, calibration, solvers)';
help::pkg.synthesis.map.objs.map.m.makemap := [=];
help::pkg.synthesis.map.objs.map.m.makemap.d := 'Apply calibration and form an image';
help::pkg.synthesis.map.objs.map.m.makemap.a.selection := [=];
help::pkg.synthesis.map.objs.map.m.makemap.a.selection.d := 'MS data selection';
help::pkg.synthesis.map.objs.map.m.makemap.a.selection.def := 'unset';
help::pkg.synthesis.map.objs.map.m.makemap.a.selection.a := 'Selection';
help::pkg.synthesis.map.objs.map.m.makemap.a.calibration := [=];
help::pkg.synthesis.map.objs.map.m.makemap.a.calibration.d := 'List of calibration to apply';
help::pkg.synthesis.map.objs.map.m.makemap.a.calibration.def := 'unset';
help::pkg.synthesis.map.objs.map.m.makemap.a.calibration.a := 'Calibrationlist';
help::pkg.synthesis.map.objs.map.m.makemap.a.ftmachine := [=];
help::pkg.synthesis.map.objs.map.m.makemap.a.ftmachine.d := 'Fourier transform machine';
help::pkg.synthesis.map.objs.map.m.makemap.a.ftmachine.def := 'unset';
help::pkg.synthesis.map.objs.map.m.makemap.a.ftmachine.a := 'Transform';
help::pkg.synthesis.map.objs.map.m.makemap.a.imagingfields := [=];
help::pkg.synthesis.map.objs.map.m.makemap.a.imagingfields.d := 'Imaging fields';
help::pkg.synthesis.map.objs.map.m.makemap.a.imagingfields.def := 'unset';
help::pkg.synthesis.map.objs.map.m.makemap.a.imagingfields.a := 'Imagingfieldlist';
help::pkg.synthesis.map.objs.map.m.makemap.a.complist := [=];
help::pkg.synthesis.map.objs.map.m.makemap.a.complist.d := 'Name of component list';
help::pkg.synthesis.map.objs.map.m.makemap.a.complist.def := '';
help::pkg.synthesis.map.objs.map.m.makemap.a.complist.a := 'String';
help::pkg.synthesis.map.objs.map.m.makemap.a.weighting := [=];
help::pkg.synthesis.map.objs.map.m.makemap.a.weighting.d := 'Gridding weighting';
help::pkg.synthesis.map.objs.map.m.makemap.a.weighting.def := 'unset';
help::pkg.synthesis.map.objs.map.m.makemap.a.weighting.a := 'Imagingweight';
help::pkg.synthesis.map.objs.map.m.makemap.a.restoringbeam := [=];
help::pkg.synthesis.map.objs.map.m.makemap.a.restoringbeam.d := 'Restoring beam';
help::pkg.synthesis.map.objs.map.m.makemap.a.restoringbeam.def := 'unset';
help::pkg.synthesis.map.objs.map.m.makemap.a.restoringbeam.a := 'Restoringbeam';
help::pkg.synthesis.map.objs.map.m.makemap.s := 'makemap(selection, calibration, ftmachine, imagingfields, complist, weighting, restoringbeam)';
help::pkg.synthesis.map.objs.map.m.view := [=];
help::pkg.synthesis.map.objs.map.m.view.d := 'View associated images';
help::pkg.synthesis.map.objs.map.m.view.a.modelentry := [=];
help::pkg.synthesis.map.objs.map.m.view.a.modelentry.d := 'Imaging field name';
help::pkg.synthesis.map.objs.map.m.view.a.modelentry.def := '';
help::pkg.synthesis.map.objs.map.m.view.a.modelentry.a := 'String';
help::pkg.synthesis.map.objs.map.m.view.a.type := [=];
help::pkg.synthesis.map.objs.map.m.view.a.type.d := 'Image type';
help::pkg.synthesis.map.objs.map.m.view.a.type.def := '\' restored\' ';
help::pkg.synthesis.map.objs.map.m.view.a.type.a := '\' model\' |\' mask\' |\' restored\' |\' residual\' ';
help::pkg.synthesis.map.objs.map.m.view.s := 'view(modelentry, type)';
help::pkg.synthesis.map.objs.map.m.plotuv := [=];
help::pkg.synthesis.map.objs.map.m.plotuv.d := 'Plot uv coverage';
help::pkg.synthesis.map.objs.map.m.plotuv.s := 'plotuv()';
help::pkg.synthesis.map.objs.map.m.plotvis := [=];
help::pkg.synthesis.map.objs.map.m.plotvis.d := 'Plot uv data';
help::pkg.synthesis.map.objs.map.m.plotvis.s := 'plotvis()';
help::pkg.synthesis.map.objs.map.m.plotweights := [=];
help::pkg.synthesis.map.objs.map.m.plotweights.d := 'Plot weights';
help::pkg.synthesis.map.objs.map.m.plotweights.s := 'plotweights()';
help::pkg.synthesis.map.objs.map.m.summary := [=];
help::pkg.synthesis.map.objs.map.m.summary.d := 'Print an MS summary';
help::pkg.synthesis.map.objs.map.m.summary.s := 'summary()';
help::pkg.synthesis.map.objs.map.m.sensitivity := [=];
help::pkg.synthesis.map.objs.map.m.sensitivity.d := 'Compute imaging sensitivity';
help::pkg.synthesis.map.objs.map.m.sensitivity.s := 'sensitivity()';
help::pkg.synthesis.map.objs.map.m.plotcal := [=];
help::pkg.synthesis.map.objs.map.m.plotcal.d := 'Plot a calibration table';
help::pkg.synthesis.map.objs.map.m.plotcal.s := 'plotcal()';
help::pkg.synthesis.map.objs.freqselmanager := [=];
help::pkg.synthesis.map.objs.freqselmanager.m := [=];
help::pkg.synthesis.map.objs.freqselmanager.c := [=];
help::pkg.synthesis.map.objs.freqselmanager.d := 'Data manager for freqsel data items';
help::pkg.synthesis.map.objs.freqselmanager.c.freqselmanager := [=];
help::pkg.synthesis.map.objs.freqselmanager.c.freqselmanager.d := 'Create a freqsel data manager';
help::pkg.synthesis.map.objs.freqselmanager.c.freqselmanager.s := 'freqselmanager()';
help::pkg.synthesis.map.objs.freqselmanager.m.channel := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.channel.d := 'Create a freqsel data item representing frequency channel selection';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.nchan := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.nchan.d := 'No. of channels';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.nchan.def := '1';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.nchan.a := 'Int';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.start := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.start.d := 'Start channel';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.start.def := '1';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.start.a := 'Int';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.step := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.step.d := 'No. of channels to step';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.step.def := '1';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.a.step.a := 'Int';
help::pkg.synthesis.map.objs.freqselmanager.m.channel.s := 'channel(nchan, start, step)';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.d := 'Create a freqsel data item representing velocity selection';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.frame := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.frame.d := 'Reference frame';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.frame.def := 'LSR';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.frame.a := 'String';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.nchan := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.nchan.d := 'No. of velocity channels';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.nchan.def := '1';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.nchan.a := 'Int';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.mstart := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.mstart.d := 'Start velocity (e.g. \' 20km/s\' )';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.mstart.def := '\' 0km/s\' ';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.mstart.a := 'Quantity';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.mstep := [=];
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.mstep.d := 'Step velocity (e.g. \' 20km/s\' )';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.mstep.def := '\' 0km/s\' ';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.a.mstep.a := 'Quantity';
help::pkg.synthesis.map.objs.freqselmanager.m.velocity.s := 'velocity(frame, nchan, mstart, mstep)';
help::pkg.synthesis.map.objs.selectionmanager := [=];
help::pkg.synthesis.map.objs.selectionmanager.m := [=];
help::pkg.synthesis.map.objs.selectionmanager.c := [=];
help::pkg.synthesis.map.objs.selectionmanager.d := 'Data manager for MS selection data items';
help::pkg.synthesis.map.objs.selectionmanager.c.selectionmanager := [=];
help::pkg.synthesis.map.objs.selectionmanager.c.selectionmanager.d := 'Create a selection data manager';
help::pkg.synthesis.map.objs.selectionmanager.c.selectionmanager.s := 'selectionmanager()';
help::pkg.synthesis.map.objs.selectionmanager.m.selection := [=];
help::pkg.synthesis.map.objs.selectionmanager.m.selection.d := 'Create a selection data item';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.freqsel := [=];
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.freqsel.d := 'Frequency/velocity selection';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.freqsel.def := 'unset';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.freqsel.a := 'Freqsel';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.fieldnames := [=];
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.fieldnames.d := 'Selected field names';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.fieldnames.def := 'unset';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.fieldnames.a := 'Vector of Strings';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.spwids := [=];
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.spwids.d := 'Selected spectral window id.\' s';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.spwids.def := 'unset';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.spwids.a := 'Vector of Ints';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.uvrange := [=];
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.uvrange.d := 'UV range (in klambda) (e.g. [0, 50])';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.uvrange.def := '0';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.uvrange.a := 'Vector of Doubles';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.msselect := [=];
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.msselect.d := 'General MS selection';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.msselect.def := 'unset';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.a.msselect.a := 'String';
help::pkg.synthesis.map.objs.selectionmanager.m.selection.s := 'selection(freqsel, fieldnames, spwids, uvrange, msselect)';
help::pkg.synthesis.map.objs.modelmanager := [=];
help::pkg.synthesis.map.objs.modelmanager.m := [=];
help::pkg.synthesis.map.objs.modelmanager.c := [=];
help::pkg.synthesis.map.objs.modelmanager.d := 'Data manager for model data items';
help::pkg.synthesis.map.objs.modelmanager.c.modelmanager := [=];
help::pkg.synthesis.map.objs.modelmanager.c.modelmanager.d := 'Create a model data manager';
help::pkg.synthesis.map.objs.modelmanager.c.modelmanager.s := 'modelmanager()';
help::pkg.synthesis.map.objs.modelmanager.m.image := [=];
help::pkg.synthesis.map.objs.modelmanager.m.image.d := 'Create a model data item from images and a component list';
help::pkg.synthesis.map.objs.modelmanager.m.image.a.images := [=];
help::pkg.synthesis.map.objs.modelmanager.m.image.a.images.d := 'Names of images';
help::pkg.synthesis.map.objs.modelmanager.m.image.a.images.def := 'unset';
help::pkg.synthesis.map.objs.modelmanager.m.image.a.images.a := 'Vector of strings';
help::pkg.synthesis.map.objs.modelmanager.m.image.a.complist := [=];
help::pkg.synthesis.map.objs.modelmanager.m.image.a.complist.d := 'Name of component list';
help::pkg.synthesis.map.objs.modelmanager.m.image.a.complist.def := 'unset';
help::pkg.synthesis.map.objs.modelmanager.m.image.a.complist.a := 'String';
help::pkg.synthesis.map.objs.modelmanager.m.image.s := 'image(images, complist)';
help::pkg.synthesis.map.objs.modelmanager.m.fluxdensity := [=];
help::pkg.synthesis.map.objs.modelmanager.m.fluxdensity.d := 'Create a model data item comprising a point source';
help::pkg.synthesis.map.objs.modelmanager.m.fluxdensity.a.iquv := [=];
help::pkg.synthesis.map.objs.modelmanager.m.fluxdensity.a.iquv.d := 'Flux density (I,Q,U,V)';
help::pkg.synthesis.map.objs.modelmanager.m.fluxdensity.a.iquv.def := '(1,0,0,0)';
help::pkg.synthesis.map.objs.modelmanager.m.fluxdensity.a.iquv.a := 'Vector of doubles';
help::pkg.synthesis.map.objs.modelmanager.m.fluxdensity.s := 'fluxdensity(iquv)';
help::pkg.synthesis.map.objs.modelmanager.m.catalog := [=];
help::pkg.synthesis.map.objs.modelmanager.m.catalog.d := 'Create a model data item from a catalog';
help::pkg.synthesis.map.objs.modelmanager.m.catalog.a.catalogname := [=];
help::pkg.synthesis.map.objs.modelmanager.m.catalog.a.catalogname.d := 'Name of catalog or flux scale';
help::pkg.synthesis.map.objs.modelmanager.m.catalog.a.catalogname.def := 'Perley-Taylor 95';
help::pkg.synthesis.map.objs.modelmanager.m.catalog.a.catalogname.a := 'String';
help::pkg.synthesis.map.objs.modelmanager.m.catalog.s := 'catalog(catalogname)';
help::pkg.synthesis.map.objs.modellistmanager := [=];
help::pkg.synthesis.map.objs.modellistmanager.m := [=];
help::pkg.synthesis.map.objs.modellistmanager.c := [=];
help::pkg.synthesis.map.objs.modellistmanager.d := 'Data manager for modellist data items';
help::pkg.synthesis.map.objs.modellistmanager.c.modellistmanager := [=];
help::pkg.synthesis.map.objs.modellistmanager.c.modellistmanager.d := 'Create a modellist data manager';
help::pkg.synthesis.map.objs.modellistmanager.c.modellistmanager.s := 'modellistmanager()';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.d := 'Create a list of model data items';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source1 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source1.d := 'Source name \#1';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source1.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source1.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model1 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model1.d := 'Model \#1';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model1.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model1.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source2 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source2.d := 'Source name \#2';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source2.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source2.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model2 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model2.d := 'Model \#2';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model2.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model2.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source3 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source3.d := 'Source name \#3';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source3.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source3.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model3 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model3.d := 'Model \#3';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model3.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model3.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source4 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source4.d := 'Source name \#4';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source4.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source4.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model4 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model4.d := 'Model \#4';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model4.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model4.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source5 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source5.d := 'Source name \#5';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source5.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source5.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model5 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model5.d := 'Model \#5';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model5.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model5.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source6 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source6.d := 'Source name \#6';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source6.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source6.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model6 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model6.d := 'Model \#6';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model6.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model6.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source7 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source7.d := 'Source name \#7';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source7.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source7.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model7 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model7.d := 'Model \#7';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model7.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model7.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source8 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source8.d := 'Source name \#8';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source8.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source8.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model8 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model8.d := 'Model \#8';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model8.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model8.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source9 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source9.d := 'Source name \#9';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source9.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.source9.a := 'String';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model9 := [=];
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model9.d := 'Model \#9';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model9.def := 'unset';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.a.model9.a := 'Model';
help::pkg.synthesis.map.objs.modellistmanager.m.modellist.s := 'modellist(source1, model1, source2, model2, source3, model3, source4, model4, source5, model5, source6, model6, source7, model7, source8, model8, source9, model9)';
help::pkg.synthesis.map.objs.maskmanager := [=];
help::pkg.synthesis.map.objs.maskmanager.m := [=];
help::pkg.synthesis.map.objs.maskmanager.c := [=];
help::pkg.synthesis.map.objs.maskmanager.d := 'Data manager for mask items';
help::pkg.synthesis.map.objs.maskmanager.c.maskmanager := [=];
help::pkg.synthesis.map.objs.maskmanager.c.maskmanager.d := 'Create a mask data manager';
help::pkg.synthesis.map.objs.maskmanager.c.maskmanager.s := 'maskmanager()';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask := [=];
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.d := 'Create a mask data item from a pixel box';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.blc := [=];
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.blc.d := 'Bottom left corner of box';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.blc.def := '[]';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.blc.a := 'Vector of 2 integers';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.trc := [=];
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.trc.d := 'top right corner of box';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.trc.def := '[]';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.trc.a := 'Vector of 2 integers';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.value := [=];
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.value.d := 'value of the mask in box';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.value.def := '1.0';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.a.value.a := 'Float';
help::pkg.synthesis.map.objs.maskmanager.m.boxmask.s := 'boxmask(blc, trc, value)';
help::pkg.synthesis.map.objs.maskmanager.m.exprmask := [=];
help::pkg.synthesis.map.objs.maskmanager.m.exprmask.d := 'Create a mask data item from a LEL expression';
help::pkg.synthesis.map.objs.maskmanager.m.exprmask.a.expr := [=];
help::pkg.synthesis.map.objs.maskmanager.m.exprmask.a.expr.d := 'LEL expression';
help::pkg.synthesis.map.objs.maskmanager.m.exprmask.a.expr.def := '';
help::pkg.synthesis.map.objs.maskmanager.m.exprmask.a.expr.a := 'LEL expression';
help::pkg.synthesis.map.objs.maskmanager.m.exprmask.s := 'exprmask(expr)';
help::pkg.synthesis.map.objs.maskmanager.m.fromimage := [=];
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.d := 'Create a mask data item by defining mask interactively from a viewer';
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.a.image := [=];
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.a.image.d := 'name of image to be used in viewer';
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.a.image.def := '\' \' ';
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.a.image.a := 'String';
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.a.maskimage := [=];
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.a.maskimage.d := 'name of  maskimage';
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.a.maskimage.def := '\' \' ';
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.a.maskimage.a := 'String';
help::pkg.synthesis.map.objs.maskmanager.m.fromimage.s := 'fromimage(image, maskimage)';
help::pkg.synthesis.map.objs.maskmanager.m.mask := [=];
help::pkg.synthesis.map.objs.maskmanager.m.mask.d := 'Create a mask data item as defined in a mask image';
help::pkg.synthesis.map.objs.maskmanager.m.mask.a.mask := [=];
help::pkg.synthesis.map.objs.maskmanager.m.mask.a.mask.d := 'name of mask image';
help::pkg.synthesis.map.objs.maskmanager.m.mask.a.mask.def := '\' \' ';
help::pkg.synthesis.map.objs.maskmanager.m.mask.a.mask.a := 'String';
help::pkg.synthesis.map.objs.maskmanager.m.mask.s := 'mask(mask)';
help::pkg.synthesis.map.objs.maskmanager.m.regionmask := [=];
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.d := 'Create a mask data item as defined by a region';
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.a.region := [=];
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.a.region.d := 'name of a region';
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.a.region.def := 'unset';
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.a.region.a := 'any valid region';
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.a.value := [=];
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.a.value.d := 'value to set mask to';
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.a.value.def := '1.0';
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.a.value.a := 'float';
help::pkg.synthesis.map.objs.maskmanager.m.regionmask.s := 'regionmask(region, value)';
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask := [=];
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.d := 'Create a mask data item as defined by  regions from thresholding an image';
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.a.image := [=];
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.a.image.d := 'name of image';
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.a.image.def := '\' \' ';
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.a.image.a := 'String';
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.a.threshold := [=];
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.a.threshold.d := 'value above which to mask';
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.a.threshold.def := '0.0';
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.a.threshold.a := 'float';
help::pkg.synthesis.map.objs.maskmanager.m.thresholdmask.s := 'thresholdmask(image, threshold)';
help::pkg.synthesis.map.objs.calibrationmanager := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m := [=];
help::pkg.synthesis.map.objs.calibrationmanager.c := [=];
help::pkg.synthesis.map.objs.calibrationmanager.d := 'Data manager for calibration data items';
help::pkg.synthesis.map.objs.calibrationmanager.c.calibrationmanager := [=];
help::pkg.synthesis.map.objs.calibrationmanager.c.calibrationmanager.d := 'Create a calibration data manager';
help::pkg.synthesis.map.objs.calibrationmanager.c.calibrationmanager.s := 'calibrationmanager()';
help::pkg.synthesis.map.objs.calibrationmanager.m.general := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.general.d := 'Create a general calibration data item';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.t := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.t.d := 'Interpolation interval (sec)';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.t.def := '0.0';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.t.a := 'Float';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.table := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.table.d := 'Name of calibration table';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.table.def := '';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.table.a := 'String';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.select := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.select.d := 'Calibration table TaQL selection';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.select.def := '';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.a.select.a := 'String';
help::pkg.synthesis.map.objs.calibrationmanager.m.general.s := 'general(t, table, select)';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.d := 'Create a voltage pattern calibration data item';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.usedefaultvp := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.usedefaultvp.d := 'Look up the default VP for this telescope and frequency?';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.usedefaultvp.def := 'T';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.usedefaultvp.a := 'Bool';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.vptable := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.vptable.d := 'If usedefaultvp is false, provide a VP Table made with vpmanager';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.vptable.def := '';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.vptable.a := 'String';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.dosquint := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.dosquint.d := 'Activate the beam squint in the VP model';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.dosquint.def := 'True';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.dosquint.a := 'Bool';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.parangleinc := [=];
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.parangleinc.d := 'Parallactice angle increment for squint application';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.parangleinc.def := '360deg';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.a.parangleinc.a := 'Quantity';
help::pkg.synthesis.map.objs.calibrationmanager.m.vp.s := 'vp(usedefaultvp, vptable, dosquint, parangleinc)';
help::pkg.synthesis.map.objs.calibrationlistmanager := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.c := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.d := 'Data manager for calibrationlist data items';
help::pkg.synthesis.map.objs.calibrationlistmanager.c.calibrationlistmanager := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.c.calibrationlistmanager.d := 'Create a calibrationlist data manager';
help::pkg.synthesis.map.objs.calibrationlistmanager.c.calibrationlistmanager.s := 'calibrationlistmanager()';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.d := 'Create a list of calibration data items';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type1 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type1.d := 'Jones matrix type \#1';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type1.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type1.a := '\' T\' |\' G\' |\' D\' |\' B\' |\' VP\' ';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration1 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration1.d := 'Calibration \#1';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration1.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration1.a := 'Calibration';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type2 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type2.d := 'Jones matrix type \#2';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type2.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type2.a := '\' T\' |\' G\' |\' D\' |\' B\' |\' VP\' ';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration2 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration2.d := 'Calibration \#2';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration2.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration2.a := 'Calibration';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type3 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type3.d := 'Jones matrix type \#3';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type3.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type3.a := '\' T\' |\' G\' |\' D\' |\' B\' |\' VP\' ';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration3 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration3.d := 'Calibration \#3';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration3.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration3.a := 'Calibration';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type4 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type4.d := 'Jones matrix type \#4';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type4.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type4.a := '\' T\' |\' G\' |\' D\' |\' B\' |\' VP\' ';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration4 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration4.d := 'Calibration \#4';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration4.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration4.a := 'Calibration';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type5 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type5.d := 'Jones matrix type \#5';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type5.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.type5.a := '\' T\' |\' G\' |\' D\' |\' B\' |\' VP\' ';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration5 := [=];
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration5.d := 'Calibration \#5';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration5.def := 'unset';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.a.calibration5.a := 'Calibration';
help::pkg.synthesis.map.objs.calibrationlistmanager.m.calibrationlist.s := 'calibrationlist(type1, calibration1, type2, calibration2, type3, calibration3, type4, calibration4, type5, calibration5)';
help::pkg.synthesis.map.objs.solvermanager := [=];
help::pkg.synthesis.map.objs.solvermanager.m := [=];
help::pkg.synthesis.map.objs.solvermanager.c := [=];
help::pkg.synthesis.map.objs.solvermanager.d := 'Data manager for solver data items';
help::pkg.synthesis.map.objs.solvermanager.c.solvermanager := [=];
help::pkg.synthesis.map.objs.solvermanager.c.solvermanager.d := 'Create a solver data manager';
help::pkg.synthesis.map.objs.solvermanager.c.solvermanager.s := 'solvermanager()';
help::pkg.synthesis.map.objs.solvermanager.m.general := [=];
help::pkg.synthesis.map.objs.solvermanager.m.general.d := 'Create a general solver data item';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.t := [=];
help::pkg.synthesis.map.objs.solvermanager.m.general.a.t.d := 'Solution interval (sec)';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.t.def := '0.0';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.t.a := 'Float';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.phaseonly := [=];
help::pkg.synthesis.map.objs.solvermanager.m.general.a.phaseonly.d := 'Solve only for phase ?';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.phaseonly.def := 'F';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.phaseonly.a := 'Boolean';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.table := [=];
help::pkg.synthesis.map.objs.solvermanager.m.general.a.table.d := 'Name of output calibration table';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.table.def := '';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.table.a := 'String';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.append := [=];
help::pkg.synthesis.map.objs.solvermanager.m.general.a.append.d := 'Append to calibration table';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.append.def := 'F';
help::pkg.synthesis.map.objs.solvermanager.m.general.a.append.a := 'Boolean';
help::pkg.synthesis.map.objs.solvermanager.m.general.s := 'general(t, phaseonly, table, append)';
help::pkg.synthesis.map.objs.solverlistmanager := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m := [=];
help::pkg.synthesis.map.objs.solverlistmanager.c := [=];
help::pkg.synthesis.map.objs.solverlistmanager.d := 'Data manager for solverlist data items';
help::pkg.synthesis.map.objs.solverlistmanager.c.solverlistmanager := [=];
help::pkg.synthesis.map.objs.solverlistmanager.c.solverlistmanager.d := 'Create a solverlist data manager';
help::pkg.synthesis.map.objs.solverlistmanager.c.solverlistmanager.s := 'solverlistmanager()';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.d := 'Create a list of solver data items';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type1 := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type1.d := 'Jones matrix type \#1';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type1.def := 'unset';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type1.a := '\' T\' |\' G\' |\' D\' |\' B\' ';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver1 := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver1.d := 'Solver \#1';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver1.def := 'unset';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver1.a := 'Solver';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type2 := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type2.d := 'Jones matrix type \#2';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type2.def := 'unset';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type2.a := '\' T\' |\' G\' |\' D\' |\' B\' ';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver2 := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver2.d := 'Solver \#2';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver2.def := 'unset';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver2.a := 'Solver';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type3 := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type3.d := 'Jones matrix type \#3';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type3.def := 'unset';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type3.a := '\' T\' |\' G\' |\' D\' |\' B\' ';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver3 := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver3.d := 'Solver \#3';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver3.def := 'unset';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver3.a := 'Solver';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type4 := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type4.d := 'Jones matrix type \#4';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type4.def := 'unset';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.type4.a := '\' T\' |\' G\' |\' D\' |\' B\' ';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver4 := [=];
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver4.d := 'Solver \#4';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver4.def := 'unset';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.a.solver4.a := 'Solver';
help::pkg.synthesis.map.objs.solverlistmanager.m.solverlist.s := 'solverlist(type1, solver1, type2, solver2, type3, solver3, type4, solver4)';

help::pkg.synthesis.simulator := [=];
help::pkg.synthesis.simulator.objs := [=];
help::pkg.synthesis.simulator.funs := [=];
help::pkg.synthesis.simulator.d := 'Module for simulation of telescope data';
help::pkg.synthesis.simulator.objs.simulator := [=];
help::pkg.synthesis.simulator.objs.simulator.m := [=];
help::pkg.synthesis.simulator.objs.simulator.c := [=];
help::pkg.synthesis.simulator.objs.simulator.d := 'Tool for simulation';
help::pkg.synthesis.simulator.objs.simulator.c.simulator := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulator.d := 'Construct a simulator tool';
help::pkg.synthesis.simulator.objs.simulator.c.simulator.s := 'simulator()';
help::pkg.synthesis.simulator.objs.simulator.c.simulatorfromms := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulatorfromms.d := 'Construct a simulator tool from a MS';
help::pkg.synthesis.simulator.objs.simulator.c.simulatorfromms.a.ms := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulatorfromms.a.ms.d := 'MeasurementSet to be processed';
help::pkg.synthesis.simulator.objs.simulator.c.simulatorfromms.a.ms.def := '\' MS\' ';
help::pkg.synthesis.simulator.objs.simulator.c.simulatorfromms.a.ms.a := 'Table name';
help::pkg.synthesis.simulator.objs.simulator.c.simulatorfromms.s := 'simulatorfromms(ms)';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.d := 'Construct a simulator tool for  testing';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.filename := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.filename.d := 'Name of MS to create';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.filename.def := '3C273XC1.ms';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.filename.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.clname := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.clname.d := 'Name of componentlist to create';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.clname.def := '3C273XC1.cl';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.clname.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.size := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.size.d := 'Number of pixels on a side';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.size.def := '128';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.size.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.stokes := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.stokes.d := 'Stokes parameters to simulate (e.g. \' IQUV\' )';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.stokes.def := '\' I\' ';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.stokes.a := '\' I\' |\' IV\' |\' IQU\' |\' IQUV\' ';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.coordinates := [=];
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.coordinates.d := 'Coordinate system to use e.g. \' j2000,\' gal\' ';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.coordinates.def := '\' j2000\' ';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.a.coordinates.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.c.simulatortester.s := 'simulatortester(filename, clname, size, stokes, coordinates)';
help::pkg.synthesis.simulator.objs.simulator.m.close := [=];
help::pkg.synthesis.simulator.objs.simulator.m.close.d := 'Close the simulator tool';
help::pkg.synthesis.simulator.objs.simulator.m.close.s := 'close()';
help::pkg.synthesis.simulator.objs.simulator.m.done := [=];
help::pkg.synthesis.simulator.objs.simulator.m.done.d := 'Terminate the simulator process';
help::pkg.synthesis.simulator.objs.simulator.m.done.s := 'done()';
help::pkg.synthesis.simulator.objs.simulator.m.name := [=];
help::pkg.synthesis.simulator.objs.simulator.m.name.d := 'Provide the name of the attached MeasurementSet';
help::pkg.synthesis.simulator.objs.simulator.m.name.s := 'name()';
help::pkg.synthesis.simulator.objs.simulator.m.open := [=];
help::pkg.synthesis.simulator.objs.simulator.m.open.d := 'Open a new MeasurementSet';
help::pkg.synthesis.simulator.objs.simulator.m.open.a.thems := [=];
help::pkg.synthesis.simulator.objs.simulator.m.open.a.thems.d := 'Existing MeasurementSet to be predicted onto and/or corrupted';
help::pkg.synthesis.simulator.objs.simulator.m.open.a.thems.def := '\' MS\' ';
help::pkg.synthesis.simulator.objs.simulator.m.open.a.thems.a := 'Table name';
help::pkg.synthesis.simulator.objs.simulator.m.open.s := 'open(thems)';
help::pkg.synthesis.simulator.objs.simulator.m.summary := [=];
help::pkg.synthesis.simulator.objs.simulator.m.summary.d := 'Summarize the current state';
help::pkg.synthesis.simulator.objs.simulator.m.summary.s := 'summary()';
help::pkg.synthesis.simulator.objs.simulator.m.type := [=];
help::pkg.synthesis.simulator.objs.simulator.m.type.d := 'Return the type of this tool';
help::pkg.synthesis.simulator.objs.simulator.m.type.s := 'type()';
help::pkg.synthesis.simulator.objs.simulator.m.id := [=];
help::pkg.synthesis.simulator.objs.simulator.m.id.d := 'Return the fundamental identifier of this tool';
help::pkg.synthesis.simulator.objs.simulator.m.id.s := 'id()';
help::pkg.synthesis.simulator.objs.simulator.m.create := [=];
help::pkg.synthesis.simulator.objs.simulator.m.create.d := 'Create the MS and its coordinates from scratch';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.newms := [=];
help::pkg.synthesis.simulator.objs.simulator.m.create.a.newms.d := 'Name of the newly created MS';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.newms.def := '\' \' ';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.newms.a := 'Table';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.shadowlimit := [=];
help::pkg.synthesis.simulator.objs.simulator.m.create.a.shadowlimit.d := 'Maximum fraction of geometrically shadowed area before flagging occurs';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.shadowlimit.def := '1e-6';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.shadowlimit.a := 'Double';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.elevationlimit := [=];
help::pkg.synthesis.simulator.objs.simulator.m.create.a.elevationlimit.d := 'Minimum elevation angle before flagging occurs';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.elevationlimit.def := '\' 10deg\' ';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.elevationlimit.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.autocorrwt := [=];
help::pkg.synthesis.simulator.objs.simulator.m.create.a.autocorrwt.d := 'Weight to assign autocorrelations (0=none)';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.autocorrwt.def := '0.0';
help::pkg.synthesis.simulator.objs.simulator.m.create.a.autocorrwt.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.create.s := 'create(newms, shadowlimit, elevationlimit, autocorrwt)';
help::pkg.synthesis.simulator.objs.simulator.m.add := [=];
help::pkg.synthesis.simulator.objs.simulator.m.add.d := 'add more rows to an already created MS';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.shadowlimit := [=];
help::pkg.synthesis.simulator.objs.simulator.m.add.a.shadowlimit.d := 'Maximum fraction of geometrically shadowed area before flagging occurs';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.shadowlimit.def := '1e-6';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.shadowlimit.a := 'Double';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.elevationlimit := [=];
help::pkg.synthesis.simulator.objs.simulator.m.add.a.elevationlimit.d := 'Minimum elevation angle before flagging occurs';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.elevationlimit.def := '\' 10deg\' ';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.elevationlimit.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.autocorrwt := [=];
help::pkg.synthesis.simulator.objs.simulator.m.add.a.autocorrwt.d := 'Weight to assign autocorrelations (0=none)';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.autocorrwt.def := '0.0';
help::pkg.synthesis.simulator.objs.simulator.m.add.a.autocorrwt.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.add.s := 'add(shadowlimit, elevationlimit, autocorrwt)';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.d := 'Set the antenna configuration';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.telescopename := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.telescopename.d := 'Name of the telescope we are simulating (determines VP)';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.telescopename.def := '\' VLA\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.telescopename.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.x := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.x.d := 'Vector of x values of all antennas [currently m]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.x.def := '[]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.x.a := 'Vector';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.y := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.y.d := 'Vector of y values of all antennas [currently m]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.y.def := '[]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.y.a := 'Vector';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.z := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.z.d := 'Vector of z values of all antennas [currently m]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.z.def := '[]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.z.a := 'Vector';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.dishdiameter := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.dishdiameter.d := 'Vector of diameters of all antennas [currently m]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.dishdiameter.def := '[]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.dishdiameter.a := 'Vector';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.mount := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.mount.d := 'Vector of mount types of all antennas (recognized mounts are \' ALT-AZ\' , \' EQUATORIAL\' , \' X-Y\' , \' ORBITING\' , \' BIZARRE\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.mount.def := '[]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.mount.a := 'Vector of strings';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.antname := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.antname.d := 'Vector of names of all antennas';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.antname.def := '[]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.antname.a := 'Vector of strings';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.coordsystem := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.coordsystem.d := 'Coordinate system of antenna positions [x,y,z]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.coordsystem.def := '\' global\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.coordsystem.a := 'String: \' global\'  | \' local\'  | \' longlat\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.referencelocation := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.referencelocation.d := 'Reference location [required for local coords]';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.referencelocation.def := '';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.a.referencelocation.a := 'MPosition';
help::pkg.synthesis.simulator.objs.simulator.m.setconfig.s := 'setconfig(telescopename, x, y, z, dishdiameter, mount, antname, coordsystem, referencelocation)';
help::pkg.synthesis.simulator.objs.simulator.m.setfeed := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfeed.d := 'Set the feed parameters';
help::pkg.synthesis.simulator.objs.simulator.m.setfeed.a.mode := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfeed.a.mode.d := 'Mode for specifying feed parameters (currently, perfect only)';
help::pkg.synthesis.simulator.objs.simulator.m.setfeed.a.mode.def := '\' perfect R L\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setfeed.a.mode.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setfeed.s := 'setfeed(mode)';
help::pkg.synthesis.simulator.objs.simulator.m.setfield := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.d := 'Set one or more observed fields';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.row := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.row.d := 'Row number in the field table';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.row.def := '1';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.row.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.sourcename := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.sourcename.d := 'Name of source or field (must be specified)';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.sourcename.def := '\' unknown\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.sourcename.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.sourcedirection := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.sourcedirection.d := 'Coordinates of source to be observed';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.sourcedirection.def := '';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.sourcedirection.a := 'MDirection';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.integrations := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.integrations.d := 'Number of integrations before changing source';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.integrations.def := '1';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.integrations.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.xmospointings := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.xmospointings.d := 'Number of mosaic pointings in the horizontal direction';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.xmospointings.def := '1';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.xmospointings.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.ymospointings := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.ymospointings.d := 'Number of mosaic pointings in the vertical direction';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.ymospointings.def := '1';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.ymospointings.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.mosspacing := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.mosspacing.d := 'Spacing between mosaic pointings, in units of lambda/2D';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.mosspacing.def := '0';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.mosspacing.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.distance := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.distance.d := 'Distance to the object';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.distance.def := '\' 0km\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.a.distance.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setfield.s := 'setfield(row, sourcename, sourcedirection, integrations, xmospointings, ymospointings, mosspacing, distance)';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.d := 'Set one or more spectral windows';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.row := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.row.d := 'Row number in the spectral windowg table';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.row.def := '1';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.row.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.spwname := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.spwname.d := 'Unique user-supplied name for this spectral window';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.spwname.def := '\' XBAND\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.spwname.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.freq := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.freq.d := 'Starting frequency';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.freq.def := '\' 8.0GHz\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.freq.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.deltafreq := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.deltafreq.d := 'Frequency increment per channel';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.deltafreq.def := '\' 50.0MHz\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.deltafreq.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.freqresolution := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.freqresolution.d := 'Frequency resolution per channel';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.freqresolution.def := '\' 50.0MHz\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.freqresolution.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.nchannels := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.nchannels.d := 'Number of channels';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.nchannels.def := '1';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.nchannels.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.stokes := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.stokes.d := 'Stokes types to simulate';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.stokes.def := '\' RR LL\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.a.stokes.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setspwindow.s := 'setspwindow(row, spwname, freq, deltafreq, freqresolution, nchannels, stokes)';
help::pkg.synthesis.simulator.objs.simulator.m.settimes := [=];
help::pkg.synthesis.simulator.objs.simulator.m.settimes.d := 'Set start, stop, gap, integration times';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.integrationtime := [=];
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.integrationtime.d := 'Integration time';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.integrationtime.def := '\' 10s\' ';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.integrationtime.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.gaptime := [=];
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.gaptime.d := 'Gap time between observations';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.gaptime.def := '\' 20s\' ';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.gaptime.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.usehourangle := [=];
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.usehourangle.d := 'Use starttime/stoptime as hour angles - else they are referenced to referencetime';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.usehourangle.def := 'T';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.usehourangle.a := 'Bool';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.starttime := [=];
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.starttime.d := 'Start time referenced to referenceepoch';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.starttime.def := '\' 0s\' ';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.starttime.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.stoptime := [=];
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.stoptime.d := 'Stop time referenced to referenceepoch';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.stoptime.def := '\' 3600s\' ';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.stoptime.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.referencetime := [=];
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.referencetime.d := 'Reference time for starttime and stoptime';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.referencetime.def := '\' 50000d\' ';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.a.referencetime.a := 'Epoch';
help::pkg.synthesis.simulator.objs.simulator.m.settimes.s := 'settimes(integrationtime, gaptime, usehourangle, starttime, stoptime, referencetime)';
help::pkg.synthesis.simulator.objs.simulator.m.predict := [=];
help::pkg.synthesis.simulator.objs.simulator.m.predict.d := 'Predict astronomical data from an image';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.modelImage := [=];
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.modelImage.d := 'Name of image from which to predict visibilities';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.modelImage.def := '\' \' ';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.modelImage.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.complist := [=];
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.complist.d := 'Name of component list';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.complist.def := '';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.complist.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.incremental := [=];
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.incremental.d := 'Add this model to the existing Data Visibilities?';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.incremental.def := 'F';
help::pkg.synthesis.simulator.objs.simulator.m.predict.a.incremental.a := 'Bool';
help::pkg.synthesis.simulator.objs.simulator.m.predict.s := 'predict(modelImage, complist, incremental)';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.d := 'Set the predict options';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.ftmachine := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.ftmachine.d := 'Fourier transform machine';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.ftmachine.def := '\' gridft\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.ftmachine.a := 'String: \' gridft\' |\' SD\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.cache := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.cache.d := 'Size of gridding cache in complex pixels';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.cache.def := '0';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.cache.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.tile := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.tile.d := 'Size of a gridding tile in pixels (in 1 dimension)';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.tile.def := '16';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.tile.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.gridfunction := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.gridfunction.d := 'Gridding function';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.gridfunction.def := '\' SF\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.gridfunction.a := 'String: \' SF\' |\' BOX\' |\' PB\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.location := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.location.d := 'Location used in phase rotations';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.location.def := '';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.location.a := 'position measure';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.padding := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.padding.d := 'Padding factor in image plane (>=1.0)';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.padding.def := '1.3';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.padding.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.facets := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.facets.d := 'Number of facets';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.facets.def := '1';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.a.facets.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setoptions.s := 'setoptions(ftmachine, cache, tile, gridfunction, location, padding, facets)';
help::pkg.synthesis.simulator.objs.simulator.m.setvp := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setvp.d := 'Set the voltage pattern model for subsequent processing';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.dovp := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.dovp.d := 'Multiply by the voltage pattern (ie, primary beam) when simulating ';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.dovp.def := 'T';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.dovp.a := 'Bool';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.usedefaultvp := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.usedefaultvp.d := 'Look up the default VP for this telescope and frequency?';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.usedefaultvp.def := 'T';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.usedefaultvp.a := 'Bool';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.vptable := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.vptable.d := 'If usedefaultvp is false, provide a VP Table made with vpmanager';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.vptable.def := '';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.vptable.a := 'Table';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.dosquint := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.dosquint.d := 'Activate the beam squint in the VP model';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.dosquint.def := 'T';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.dosquint.a := 'Bool';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.parangleinc := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.parangleinc.d := 'Parallactice angle increment for squint application';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.parangleinc.def := '360deg';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.a.parangleinc.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setvp.s := 'setvp(dovp, usedefaultvp, vptable, dosquint, parangleinc)';
help::pkg.synthesis.simulator.objs.simulator.m.corrupt := [=];
help::pkg.synthesis.simulator.objs.simulator.m.corrupt.d := 'Corrupt the data with visibility errors';
help::pkg.synthesis.simulator.objs.simulator.m.corrupt.s := 'corrupt()';
help::pkg.synthesis.simulator.objs.simulator.m.reset := [=];
help::pkg.synthesis.simulator.objs.simulator.m.reset.d := 'Reset the corruption terms';
help::pkg.synthesis.simulator.objs.simulator.m.reset.s := 'reset()';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.d := 'Set the bandpasses';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.mode := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.mode.d := 'Mode of operation';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.mode.a := 'String: \' calculate\' |\' table\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.table := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.table.d := 'Name of table';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.table.def := '\' \' ';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.table.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.interval := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.interval.d := 'Coherence interval e.g. \' 1h\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.interval.def := '\' 1h\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.interval.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.amplitude := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.amplitude.d := 'Variances errors in amplitude and phase';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.amplitude.def := '[0, 0]';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.a.amplitude.a := '2-Vector of Double';
help::pkg.synthesis.simulator.objs.simulator.m.setbandpass.s := 'setbandpass(mode, table, interval, amplitude)';
help::pkg.synthesis.simulator.objs.simulator.m.setgain := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setgain.d := 'Set the gains';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.mode := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.mode.d := 'Mode of operation';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.mode.a := 'String: \' calculate\' |\' table\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.table := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.table.d := 'Name of table';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.table.def := '\' \' ';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.table.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.interval := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.interval.d := 'Coherence interval e.g. \' 10s\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.interval.def := '\' 10s\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.interval.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.amplitude := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.amplitude.d := 'Variances of errors in amplitude and phase';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.amplitude.def := '[0, 0]';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.a.amplitude.a := '2-Vector of Double';
help::pkg.synthesis.simulator.objs.simulator.m.setgain.s := 'setgain(mode, table, interval, amplitude)';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.d := 'Set the polarization leakage';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.mode := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.mode.d := 'Mode of operation';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.mode.a := 'String: \' calculate\' |\' table\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.table := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.table.d := 'Name of table';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.table.def := '\' \' ';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.table.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.interval := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.interval.d := 'Coherence interval e.g. \' 5.0h\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.interval.def := '\' 5.0h\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.interval.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.amplitude := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.amplitude.d := 'Variance of pol leakage amplitude errors; currently, just real';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.amplitude.def := '0.0';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.a.amplitude.a := 'Double';
help::pkg.synthesis.simulator.objs.simulator.m.setleakage.s := 'setleakage(mode, table, interval, amplitude)';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.d := 'Set the noise level';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.mode := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.mode.d := 'Mode of operation';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.mode.a := 'String: \' table\' |\' simplenoise\' |\' calculate\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.table := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.table.d := 'Name of noise table if not simplenoise or not calculated';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.table.def := '\' \' ';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.table.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.simplenoise := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.simplenoise.d := 'Level of noise if not Table or not Calculated';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.simplenoise.def := '\' 0.0Jy\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.simplenoise.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.antefficiency := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.antefficiency.d := 'antenna efficiency';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.antefficiency.def := '0.8';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.antefficiency.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.correfficiency := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.correfficiency.d := 'Correlation efficiency';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.correfficiency.def := '0.85';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.correfficiency.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.spillefficiency := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.spillefficiency.d := 'Forward spillover efficiency';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.spillefficiency.def := '0.85';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.spillefficiency.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tau := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tau.d := 'Atmospheric Opacity';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tau.def := '0.0';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tau.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.trx := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.trx.d := 'Receiver temp (ie, all non-atmospheric Tsys contributions) [K]';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.trx.def := '50';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.trx.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tatmos := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tatmos.d := 'Temperature of atmosphere [k]';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tatmos.def := '250.0';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tatmos.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tcmb := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tcmb.d := 'Temperature of cosmic microwave background [K]';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tcmb.def := '2.7';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.a.tcmb.a := 'Float';
help::pkg.synthesis.simulator.objs.simulator.m.setnoise.s := 'setnoise(mode, table, simplenoise, antefficiency, correfficiency, spillefficiency, tau, trx, tatmos, tcmb)';
help::pkg.synthesis.simulator.objs.simulator.m.setpa := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setpa.d := 'Corrupt phase by the parallactic angle';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.mode := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.mode.d := 'Mode of operation';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.mode.a := 'String: \' calculate\' |\' table\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.table := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.table.d := 'Name of table';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.table.def := '\' \' ';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.table.a := 'String';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.interval := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.interval.d := 'Interval for parallactic angle application, e.g. \' 10s\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.interval.def := '\' 10s\' ';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.a.interval.a := 'Quantity';
help::pkg.synthesis.simulator.objs.simulator.m.setpa.s := 'setpa(mode, table, interval)';
help::pkg.synthesis.simulator.objs.simulator.m.setseed := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setseed.d := 'Set the seed for the random number generator';
help::pkg.synthesis.simulator.objs.simulator.m.setseed.a.seed := [=];
help::pkg.synthesis.simulator.objs.simulator.m.setseed.a.seed.d := 'Seed';
help::pkg.synthesis.simulator.objs.simulator.m.setseed.a.seed.def := '185349251';
help::pkg.synthesis.simulator.objs.simulator.m.setseed.a.seed.a := 'Int';
help::pkg.synthesis.simulator.objs.simulator.m.setseed.s := 'setseed(seed)';
help::pkg.synthesis.simulator.objs.imageevaluator := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.c := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.d := 'Tool for evaluating simulated images';
help::pkg.synthesis.simulator.objs.imageevaluator.c.imageevaluator := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.c.imageevaluator.d := 'Construct an imageevaluator tool';
help::pkg.synthesis.simulator.objs.imageevaluator.c.imageevaluator.a.myimage := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.c.imageevaluator.a.myimage.d := 'Image to be evaluated';
help::pkg.synthesis.simulator.objs.imageevaluator.c.imageevaluator.a.myimage.def := '';
help::pkg.synthesis.simulator.objs.imageevaluator.c.imageevaluator.a.myimage.a := 'Image name';
help::pkg.synthesis.simulator.objs.imageevaluator.c.imageevaluator.s := 'imageevaluator(myimage)';
help::pkg.synthesis.simulator.objs.imageevaluator.m.dynamicrange := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m.dynamicrange.d := 'Calculate image dynamic range';
help::pkg.synthesis.simulator.objs.imageevaluator.m.dynamicrange.a.offregion := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m.dynamicrange.a.offregion.d := 'A region containing off-source pixels';
help::pkg.synthesis.simulator.objs.imageevaluator.m.dynamicrange.a.offregion.def := 'unset';
help::pkg.synthesis.simulator.objs.imageevaluator.m.dynamicrange.a.offregion.a := 'Region';
help::pkg.synthesis.simulator.objs.imageevaluator.m.dynamicrange.s := 'dynamicrange(offregion)';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.d := 'Calculate the median image fidelity';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.model := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.model.d := 'Model or truth image';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.model.def := '\' \' ';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.model.a := 'Image';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.modmin := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.modmin.d := 'Minimum pixel value in the model image to be used';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.modmin.def := '0.001';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.modmin.a := 'Float';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.mode := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.mode.d := 'Mode of fidelity calculation';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.mode.def := '\' median\' ';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.mode.a := '\' median\' |\' moment\' ';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.moment := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.moment.d := 'Exponent of model image to use for moment fidelity';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.moment.def := '1.0';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.a.moment.a := 'Float';
help::pkg.synthesis.simulator.objs.imageevaluator.m.fidelity.s := 'fidelity(model, modmin, mode, moment)';
help::pkg.synthesis.simulator.objs.imageevaluator.m.done := [=];
help::pkg.synthesis.simulator.objs.imageevaluator.m.done.d := 'Finishes up the imageevaluator tool';
help::pkg.synthesis.simulator.objs.imageevaluator.m.done.s := 'done()';
help::pkg.synthesis.simulator.objs.dynamicsched := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.c := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.d := 'tool for simulating dynamic scheduling';
help::pkg.synthesis.simulator.objs.dynamicsched.c.dynamicsched := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.c.dynamicsched.d := 'Construct an dynamic scheduling';
help::pkg.synthesis.simulator.objs.dynamicsched.c.dynamicsched.s := 'dynamicsched()';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.d := 'Define a few site related data';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.sitedatafile := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.sitedatafile.d := 'ASCII site survey file';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.sitedatafile.def := '\' CH.9506.INT+ALL\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.sitedatafile.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.headerfile := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.headerfile.d := 'Header file associated with sitedatafile';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.headerfile.def := '\' header.sitedata\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.headerfile.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.observatory := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.observatory.d := 'Name of an existing site';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.observatory.def := '\' ALMA\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.observatory.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeinglambda := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeinglambda.d := 'Observing wavelength of seeing monitor';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeinglambda.def := '\' 26.79mm\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeinglambda.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeingel := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeingel.d := 'Elevation angle of seeing monitor\' s beam';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeingel.def := '\' 36deg\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeingel.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeingbaseline := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeingbaseline.d := 'Baseline length of seeing monitor';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeingbaseline.def := '\' 300m\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.a.seeingbaseline.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsitedata.s := 'setsitedata(sitedatafile, headerfile, observatory, seeinglambda, seeingel, seeingbaseline)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settaudata := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.settaudata.d := 'Name the file with the model of opacity vs frequency';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settaudata.a.tautermsfile := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.settaudata.a.tautermsfile.d := 'File containing tau data';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settaudata.a.tautermsfile.def := '\' CH.LIEBE.TERMS\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settaudata.a.tautermsfile.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settaudata.s := 'settaudata(tautermsfile)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.d := 'Specify parameters which affect how quickly source changes occur';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.azslewrate := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.azslewrate.d := 'Slew rate in azimuth axis';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.azslewrate.def := '2deg/s\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.azslewrate.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.elslewrate := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.elslewrate.d := 'Slew rate in elevation axis';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.elslewrate.def := '1deg/s\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.elslewrate.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.changeoverhead := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.changeoverhead.d := 'Time lost to setup and calibration when switching projects';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.changeoverhead.def := '\' 60s\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.a.changeoverhead.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setchangeinfo.s := 'setchangeinfo(azslewrate, elslewrate, changeoverhead)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.d := 'Specify time-related parameters';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.dt := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.dt.d := 'Granularity of scheduling';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.dt.def := '\' 0.25h\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.dt.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.timeref := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.timeref.d := 'relative or absolute starting time';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.timeref.def := '\' relative\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.timeref.a := '\' relative\' |\' absolute\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.absolutestart := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.absolutestart.d := 'Starting time as an absolute epoch';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.absolutestart.def := 'dm.epoch(\' utc\' , \' today\' )';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.absolutestart.a := 'Epoch';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.relativestart := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.relativestart.d := 'Starting time relative to first site data point';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.relativestart.def := '\' 0.0d\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.relativestart.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.duration := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.duration.d := 'Duration of scheduling (<0 means till sitedata runs out)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.duration.def := '\' 1.0d\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.a.duration.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.settimes.s := 'settimes(dt, timeref, absolutestart, relativestart, duration)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.d := 'Provide parameters which determine how well the phase calibration works';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.phasecalmethod := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.phasecalmethod.d := 'Phasecal method to use (only RADIOMETRIC works at the moment';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.phasecalmethod.def := '\' RADIOMETRIC\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.phasecalmethod.a := '\' RADIOMETRIC\' |\' FASTSWITCH\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.baselevel := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.baselevel.d := 'Basic accuracy of the phase correction (in pathlength)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.baselevel.def := '\' 50um\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.baselevel.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.fraclevel := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.fraclevel.d := 'Fraction of the atmospheric phase errors which are not removed';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.fraclevel.def := '0.10';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.fraclevel.a := 'Float';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.windvelocity := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.windvelocity.d := 'Velocity of winds aloft';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.windvelocity.def := '\' 10m/s\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.windvelocity.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.timescale := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.timescale.d := 'Timescale of the atmospheric phase errors';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.timescale.def := '\' 30s\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.a.timescale.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setphasecalinfo.s := 'setphasecalinfo(phasecalmethod, baselevel, fraclevel, windvelocity, timescale)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.d := 'Specifiy coarse telescope parameters which influence sensitivity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.dishdiameter := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.dishdiameter.d := 'Size of antennas';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.dishdiameter.def := '\' 12m\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.dishdiameter.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.nantennas := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.nantennas.d := 'Number of antennas';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.nantennas.def := '64';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.nantennas.a := 'Int';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.npol := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.npol.d := 'Number of polarizations';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.npol.def := '2';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.a.npol.a := 'Int';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setsensitivity.s := 'setsensitivity(dishdiameter, nantennas, npol)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.d := 'Specify band-dependent parameters which influence the sensitivity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.whichband := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.whichband.d := 'Give the band number (1 relative)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.whichband.def := '1';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.whichband.a := 'Int';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.bandname := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.bandname.d := 'Band name (just used as a label';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.bandname.def := '\' band1\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.bandname.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.freqlow := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.freqlow.d := 'Low frequency band limit';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.freqlow.def := '\' 100GHz\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.freqlow.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.freqhigh := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.freqhigh.d := 'High frequency band limit';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.freqhigh.def := '\' 1000GHz\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.freqhigh.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.bandwidth := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.bandwidth.d := 'Bandwith for the observations';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.bandwidth.def := '\' 8GHz\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.bandwidth.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.tsys := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.tsys.d := 'System temperature (below the atmosphere)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.tsys.def := '\' 100K\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.tsys.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.efficiency := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.efficiency.d := 'Cumulative efficiency (antenna and correlator)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.efficiency.def := '0.80';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.a.efficiency.a := 'Float';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setbandsensitivity.s := 'setbandsensitivity(whichband, bandname, freqlow, freqhigh, bandwidth, tsys, efficiency)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.viewsensitivity := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.viewsensitivity.d := 'Look at the sensitivity parameters that have been set';
help::pkg.synthesis.simulator.objs.dynamicsched.m.viewsensitivity.s := 'viewsensitivity()';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.d := 'Create many simulated observing projects';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.nprojects := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.nprojects.d := 'Number of projects to generate';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.nprojects.def := '100';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.nprojects.a := 'Int';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.ratingmin := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.ratingmin.d := 'Minimum rating';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.ratingmin.def := '1';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.ratingmin.a := 'Int';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.ratingmax := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.ratingmax.d := 'Maximum rating';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.ratingmax.def := '10';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.ratingmax.a := 'Int';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timemode := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timemode.d := 'Peak of distribution of allotted observing times';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timemode.def := '\' 5h\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timemode.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timesigma := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timesigma.d := 'Width of distribution of allotted observing times';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timesigma.def := '\' 10h\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timesigma.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timemax := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timemax.d := 'Extent of tail of distribution of allotted observing times';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timemax.def := '\' 20h\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.timemax.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqtransexponent := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqtransexponent.d := 'Exponent of atmospheric transmission in freq distribution';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqtransexponent.def := '2.0';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqtransexponent.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqwt := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqwt.d := 'Multiplier to increase weight of high frequency observations';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqwt.def := '2.0';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqwt.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqexponent := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqexponent.d := 'Exponent to increase weight of high frequency observations';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqexponent.def := '1.5';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.freqexponent.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.decmin := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.decmin.d := 'Minimum declination in dec range';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.decmin.def := '\' -90deg\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.decmin.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.decmax := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.decmax.d := 'Maximum declination in dec range';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.decmax.def := '\' 52deg\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.a.decmax.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.generateprojects.s := 'generateprojects(nprojects, ratingmin, ratingmax, timemode, timesigma, timemax, freqtransexponent, freqwt, freqexponent, decmin, decmax)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.probview := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.probview.d := 'View the probability distributions for time, freq, rating, RA/DEC';
help::pkg.synthesis.simulator.objs.dynamicsched.m.probview.a.whichone := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.probview.a.whichone.d := 'Which distribution should we look at?';
help::pkg.synthesis.simulator.objs.dynamicsched.m.probview.a.whichone.def := '\' freq\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.probview.a.whichone.a := '\' freq\' |\' rating\' |\' radec\' |\' time\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.probview.s := 'probview(whichone)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.d := 'Save the observing projects to a Table';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.projecttable := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.projecttable.d := 'Name of table to save projects to';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.projecttable.def := '\' \' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.projecttable.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.allprojects := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.allprojects.d := 'Save all projects';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.allprojects.def := 'T';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.allprojects.a := 'Bool';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.whichprojects := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.whichprojects.d := 'Projects to save (if allprojects==F)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.whichprojects.def := '[]';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.a.whichprojects.a := 'Vector of Ints';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveprojects.s := 'saveprojects(projecttable, allprojects, whichprojects)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverprojects := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverprojects.d := 'Recover the observing projects from a Table';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverprojects.a.projecttable := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverprojects.a.projecttable.d := 'Name of table to recover projects from';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverprojects.a.projecttable.def := '\' \' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverprojects.a.projecttable.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverprojects.s := 'recoverprojects(projecttable)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveschedule := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveschedule.d := 'Save the current observing schedule to a table';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveschedule.a.scheduletable := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveschedule.a.scheduletable.d := 'Name of table to save the observng schedule to';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveschedule.a.scheduletable.def := '\' \' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveschedule.a.scheduletable.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.saveschedule.s := 'saveschedule(scheduletable)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverschedule := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverschedule.d := 'Recover an observing schedule from a table';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverschedule.a.scheduletable := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverschedule.a.scheduletable.d := 'Name of table to recover the observng schedule from';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverschedule.a.scheduletable.def := '\' \' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverschedule.a.scheduletable.a := 'String';
help::pkg.synthesis.simulator.objs.dynamicsched.m.recoverschedule.s := 'recoverschedule(scheduletable)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.defaultinitialize := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.defaultinitialize.d := 'Perform a default initialization -- archaic';
help::pkg.synthesis.simulator.objs.dynamicsched.m.defaultinitialize.s := 'defaultinitialize()';
help::pkg.synthesis.simulator.objs.dynamicsched.m.done := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.done.d := 'Clean up the dynamic scheduling object';
help::pkg.synthesis.simulator.objs.dynamicsched.m.done.s := 'done()';
help::pkg.synthesis.simulator.objs.dynamicsched.m.getpgplotter := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.getpgplotter.d := 'Get the pgplotter';
help::pkg.synthesis.simulator.objs.dynamicsched.m.getpgplotter.s := 'getpgplotter()';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.d := 'Set criteria for scheduling observations';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.hatozenith := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.hatozenith.d := 'Hour angle approaching zenith';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.hatozenith.def := '\' 2h\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.hatozenith.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.hafromzenith := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.hafromzenith.d := 'Hour angle passing zenith';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.hafromzenith.def := '\' 1.5h\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.hafromzenith.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.phasecutoff := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.phasecutoff.d := 'Maximum residual phase error permitted';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.phasecutoff.def := '\' 30deg\' ';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.a.phasecutoff.a := 'Quantity';
help::pkg.synthesis.simulator.objs.dynamicsched.m.setschedcriteria.s := 'setschedcriteria(hatozenith, hafromzenith, phasecutoff)';
help::pkg.synthesis.simulator.objs.dynamicsched.m.schedule := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.schedule.d := 'Go through the site test data and schedule projects';
help::pkg.synthesis.simulator.objs.dynamicsched.m.schedule.s := 'schedule()';
help::pkg.synthesis.simulator.objs.dynamicsched.m.reobserveschedule := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.reobserveschedule.d := 'Given a schedule reobserve it for the current conditions';
help::pkg.synthesis.simulator.objs.dynamicsched.m.reobserveschedule.s := 'reobserveschedule()';
help::pkg.synthesis.simulator.objs.dynamicsched.m.evaluateobservations := [=];
help::pkg.synthesis.simulator.objs.dynamicsched.m.evaluateobservations.d := 'Evaluate the observations';
help::pkg.synthesis.simulator.objs.dynamicsched.m.evaluateobservations.s := 'evaluateobservations()';

help::pkg.synthesis.newsimulator := [=];
help::pkg.synthesis.newsimulator.objs := [=];
help::pkg.synthesis.newsimulator.funs := [=];
help::pkg.synthesis.newsimulator.d := 'Module for simulation of telescope data';
help::pkg.synthesis.newsimulator.objs.newsimulator := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.c := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.d := 'Tool for simulation';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulator := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulator.d := 'Construct a newsimulator tool';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulator.a.ms := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulator.a.ms.d := 'MeasurementSet to be created';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulator.a.ms.def := '\' MS\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulator.a.ms.a := 'Table name';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulator.s := 'newsimulator(ms)';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulatorfromms := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulatorfromms.d := 'Construct a newsimulator tool from a MS';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulatorfromms.a.ms := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulatorfromms.a.ms.d := 'MeasurementSet to be processed';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulatorfromms.a.ms.def := '\' MS\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulatorfromms.a.ms.a := 'Table name';
help::pkg.synthesis.newsimulator.objs.newsimulator.c.newsimulatorfromms.s := 'newsimulatorfromms(ms)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.close := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.close.d := 'Close the newsimulator tool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.close.s := 'close()';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.Done := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.Done.d := 'Close the newsimulator tool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.Done.s := 'Done()';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.name := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.name.d := 'Provide the name of the attached MeasurementSet';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.name.s := 'name()';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.summary := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.summary.d := 'Summarize the current state';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.summary.s := 'summary()';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.type := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.type.d := 'Return the type of this tool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.type.s := 'type()';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.d := 'Set integration time, {\em etc.}';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.integrationtime := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.integrationtime.d := 'Integration time';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.integrationtime.def := '\' 10s\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.integrationtime.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.usehourangle := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.usehourangle.d := 'Use starttime/stoptime as hour angles - else they are referenced to referencetime';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.usehourangle.def := 'T';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.usehourangle.a := 'Bool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.referencetime := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.referencetime.d := 'Reference time for starttime and stoptime';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.referencetime.def := '\' 50000d\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.a.referencetime.a := 'Epoch';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.settimes.s := 'settimes(integrationtime, usehourangle, referencetime)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.d := 'Observe a given configuration';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.sourcename := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.sourcename.d := 'Name of source or field (must be specified)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.sourcename.def := 'None';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.sourcename.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.spwname := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.spwname.d := 'Unique user-supplied name for this spectral window';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.spwname.def := 'None';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.spwname.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.starttime := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.starttime.d := 'Start time referenced to referenceepoch';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.starttime.def := '\' 0s\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.starttime.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.stoptime := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.stoptime.d := 'Stop time referenced to referenceepoch';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.stoptime.def := '\' 3600s\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.a.stoptime.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.observe.s := 'observe(sourcename, spwname, starttime, stoptime)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.d := 'Set limits for observing';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.a.shadowlimit := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.a.shadowlimit.d := 'Maximum fraction of geometrically shadowed area before flagging occurs';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.a.shadowlimit.def := '1e-6';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.a.shadowlimit.a := 'Double';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.a.elevationlimit := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.a.elevationlimit.d := 'Minimum elevation angle before flagging occurs';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.a.elevationlimit.def := '\' 10deg\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.a.elevationlimit.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setlimits.s := 'setlimits(shadowlimit, elevationlimit)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setauto := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setauto.d := 'Set autocorrelation weight';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setauto.a.autocorrwt := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setauto.a.autocorrwt.d := 'Weight to assign autocorrelations (0=none)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setauto.a.autocorrwt.def := '0.0';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setauto.a.autocorrwt.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setauto.s := 'setauto(autocorrwt)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.d := 'Set the antenna configuration';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.telescopename := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.telescopename.d := 'Name of the telescope we are simulating (determines VP)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.telescopename.def := '\' VLA\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.telescopename.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.x := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.x.d := 'Vector of x values of all antennas [currently m]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.x.def := '[]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.x.a := 'Vector';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.y := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.y.d := 'Vector of y values of all antennas [currently m]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.y.def := '[]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.y.a := 'Vector';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.z := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.z.d := 'Vector of z values of all antennas [currently m]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.z.def := '[]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.z.a := 'Vector';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.dishdiameter := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.dishdiameter.d := 'Vector of diameters of all antennas [currently m]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.dishdiameter.def := '[]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.dishdiameter.a := 'Vector';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.mount := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.mount.d := 'Vector of mount types of all antennas (recognized mounts are \' ALT-AZ\' , \' EQUATORIAL\' , \' X-Y\' , \' ORBITING\' , \' BIZARRE\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.mount.def := '[]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.mount.a := 'Vector of strings';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.antname := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.antname.d := 'Vector of names of all antennas';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.antname.def := '[]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.antname.a := 'Vector of strings';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.coordsystem := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.coordsystem.d := 'Coordinate system of antenna positions [x,y,z]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.coordsystem.def := '\' global\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.coordsystem.a := 'String: \' global\'  | \' local\'  | \' longlat\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.referencelocation := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.referencelocation.d := 'Reference location [required for local coords]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.referencelocation.def := '';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.a.referencelocation.a := 'MPosition';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setconfig.s := 'setconfig(telescopename, x, y, z, dishdiameter, mount, antname, coordsystem, referencelocation)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setknownconfig := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setknownconfig.d := 'Set the antenna configuration to a known array';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setknownconfig.a.arrayname := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setknownconfig.a.arrayname.d := 'Name of the telescope configurationwe are simulating';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setknownconfig.a.arrayname.def := '\' VLAA\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setknownconfig.a.arrayname.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setknownconfig.s := 'setknownconfig(arrayname)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfeed := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfeed.d := 'Set the feed parameters';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfeed.a.mode := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfeed.a.mode.d := 'Mode for specifying feed parameters (currently, perfect only)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfeed.a.mode.def := '\' perfect R L\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfeed.a.mode.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfeed.s := 'setfeed(mode)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.d := 'Set one or more observed fields';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.sourcename := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.sourcename.d := 'Name of source or field (must be specified)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.sourcename.def := '\' unknown\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.sourcename.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.sourcedirection := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.sourcedirection.d := 'Coordinates of source to be observed';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.sourcedirection.def := '';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.sourcedirection.a := 'MDirection';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.calcode := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.calcode.d := 'Calibration code';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.calcode.def := '\' \' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.calcode.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.distance := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.distance.d := 'Distance to the object';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.distance.def := '\' 0km\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.a.distance.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setfield.s := 'setfield(sourcename, sourcedirection, calcode, distance)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.d := 'Set observed mosaic fields';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.sourcename := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.sourcename.d := 'Name of source or field (must be specified).';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.sourcename.def := '\' unknown\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.sourcename.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.calcode := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.calcode.d := 'Calibration code';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.calcode.def := '\' \' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.calcode.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.fieldcenter := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.fieldcenter.d := 'Coordinates of mosaic field center';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.fieldcenter.def := '';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.fieldcenter.a := 'MDirection';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.xmosp := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.xmosp.d := 'Number of mosaic pointing in horizontal direction';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.xmosp.def := '1';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.xmosp.a := 'Int';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.ymosp := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.ymosp.d := 'Number of mosaic pointing in vertical direction';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.ymosp.def := '1';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.ymosp.a := 'Int';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.mosspacing := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.mosspacing.d := 'Spacing between mosaic pointings';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.mosspacing.def := '\' 1arcsec\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.mosspacing.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.distance := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.distance.d := 'Distance to the object';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.distance.def := '\' 0km\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.a.distance.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setmosaicfield.s := 'setmosaicfield(sourcename, calcode, fieldcenter, xmosp, ymosp, mosspacing, distance)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.d := 'Set one or more spectral windows';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.spwname := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.spwname.d := 'Unique user-supplied name for this spectral window';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.spwname.def := '\' XBAND\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.spwname.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.freq := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.freq.d := 'Starting frequency';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.freq.def := '\' 8.0GHz\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.freq.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.deltafreq := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.deltafreq.d := 'Frequency increment per channel';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.deltafreq.def := '\' 50.0MHz\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.deltafreq.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.freqresolution := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.freqresolution.d := 'Frequency resolution per channel';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.freqresolution.def := '\' 50.0MHz\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.freqresolution.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.nchannels := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.nchannels.d := 'Number of channels';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.nchannels.def := '1';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.nchannels.a := 'Int';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.stokes := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.stokes.d := 'Stokes types to simulate';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.stokes.def := '\' RR LL\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.a.stokes.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setspwindow.s := 'setspwindow(spwname, freq, deltafreq, freqresolution, nchannels, stokes)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.d := 'Set the data parameters selection for subsequent processing';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.spwid := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.spwid.d := 'Spectral Window Ids (1 relative) to select';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.spwid.def := '1';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.spwid.a := 'Vector of Ints';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.fieldid := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.fieldid.d := 'Field Ids (1 relative) to select';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.fieldid.def := '1';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.fieldid.a := 'Vector of Ints';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.msselect := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.msselect.d := 'TQL select string applied as a logical "and" with the other selections';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.msselect.def := '';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.msselect.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.async := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.async.d := 'Run asynchronously in the background?';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.async.def := '!dowait';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.a.async.a := 'Bool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setdata.s := 'setdata(spwid, fieldid, msselect, async)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.d := 'Predict astronomical data from an image';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.modelImage := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.modelImage.d := 'Name of image from which to predict visibilities';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.modelImage.def := '\' \' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.modelImage.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.complist := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.complist.d := 'Name of component list';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.complist.def := '';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.complist.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.incremental := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.incremental.d := 'Add this model to the existing Data Visibilities?';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.incremental.def := 'F';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.a.incremental.a := 'Bool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.predict.s := 'predict(modelImage, complist, incremental)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.d := 'Set various processing options';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.ftmachine := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.ftmachine.d := 'Fourier transform machine';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.ftmachine.def := '\' gridft\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.ftmachine.a := 'String: \' gridft\' |\' SD\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.cache := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.cache.d := 'Size of gridding cache in complex pixels';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.cache.def := '0';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.cache.a := 'Int';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.tile := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.tile.d := 'Size of a gridding tile in pixels (in 1 dimension)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.tile.def := '16';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.tile.a := 'Int';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.gridfunction := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.gridfunction.d := 'Gridding function';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.gridfunction.def := '\' SF\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.gridfunction.a := 'String: \' SF\' |\' BOX\' |\' PB\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.location := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.location.d := 'Location used in phase rotations';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.location.def := '';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.location.a := 'position measure';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.padding := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.padding.d := 'Padding factor in image plane (>=1.0)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.padding.def := '1.3';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.padding.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.facets := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.facets.d := 'Number of facets';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.facets.def := '1';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.facets.a := 'Int';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.maxdata := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.maxdata.d := 'Maximum data to write to a single TSM file (MB)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.maxdata.def := '2000';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.a.maxdata.a := 'Double';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setoptions.s := 'setoptions(ftmachine, cache, tile, gridfunction, location, padding, facets, maxdata)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.d := 'Set the voltage pattern model for subsequent processing';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.dovp := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.dovp.d := 'Multiply by the voltage pattern (ie, primary beam) when simulating ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.dovp.def := 'T';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.dovp.a := 'Bool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.usedefaultvp := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.usedefaultvp.d := 'Look up the default VP for this telescope and frequency?';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.usedefaultvp.def := 'T';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.usedefaultvp.a := 'Bool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.vptable := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.vptable.d := 'If usedefaultvp is false, provide a VP Table made with vpmanager';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.vptable.def := '';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.vptable.a := 'Table';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.dosquint := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.dosquint.d := 'Activate the beam squint in the VP model';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.dosquint.def := 'T';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.dosquint.a := 'Bool';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.parangleinc := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.parangleinc.d := 'Parallactice angle increment for squint application';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.parangleinc.def := '360deg';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.a.parangleinc.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setvp.s := 'setvp(dovp, usedefaultvp, vptable, dosquint, parangleinc)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.corrupt := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.corrupt.d := 'Corrupt the data with visibility errors';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.corrupt.s := 'corrupt()';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.reset := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.reset.d := 'Reset the corruption terms';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.reset.s := 'reset()';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.d := 'Set the bandpasses';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.mode := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.mode.d := 'Mode of operation';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.mode.a := 'String: \' calculate\' |\' table\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.table := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.table.d := 'Name of table';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.table.def := '\' \' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.table.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.interval := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.interval.d := 'Coherence interval e.g. \' 1h\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.interval.def := '\' 1h\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.interval.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.amplitude := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.amplitude.d := 'Variances errors in amplitude and phase';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.amplitude.def := '[0, 0]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.a.amplitude.a := '2-Vector of Double';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setbandpass.s := 'setbandpass(mode, table, interval, amplitude)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.d := 'Set the gains';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.mode := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.mode.d := 'Mode of operation';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.mode.a := 'String: \' calculate\' |\' table\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.table := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.table.d := 'Name of table';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.table.def := '\' \' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.table.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.interval := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.interval.d := 'Coherence interval e.g. \' 10s\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.interval.def := '\' 10s\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.interval.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.amplitude := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.amplitude.d := 'Variances of errors in amplitude and phase';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.amplitude.def := '[0, 0]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.a.amplitude.a := '2-Vector of Double';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setgain.s := 'setgain(mode, table, interval, amplitude)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.d := 'Set the polarization leakage';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.mode := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.mode.d := 'Mode of operation';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.mode.a := 'String: \' calculate\' |\' table\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.table := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.table.d := 'Name of table';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.table.def := '\' \' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.table.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.interval := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.interval.d := 'Coherence interval e.g. \' 5.0h\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.interval.def := '\' 5.0h\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.interval.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.amplitude := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.amplitude.d := 'Variance of pol leakage amplitude errors; currently, just real';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.amplitude.def := '0.0';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.a.amplitude.a := 'Double';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setleakage.s := 'setleakage(mode, table, interval, amplitude)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.d := 'Set the noise level';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.mode := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.mode.d := 'Mode of operation';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.mode.a := 'String: \' table\' |\' simplenoise\' |\' calculate\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.table := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.table.d := 'Name of noise table if not simplenoise or not calculated';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.table.def := '\' \' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.table.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.simplenoise := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.simplenoise.d := 'Level of noise if not Table or not Calculated';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.simplenoise.def := '\' 0.0Jy\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.simplenoise.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.antefficiency := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.antefficiency.d := 'antenna efficiency';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.antefficiency.def := '0.8';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.antefficiency.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.correfficiency := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.correfficiency.d := 'Correlation efficiency';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.correfficiency.def := '0.85';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.correfficiency.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.spillefficiency := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.spillefficiency.d := 'Forward spillover efficiency';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.spillefficiency.def := '0.85';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.spillefficiency.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tau := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tau.d := 'Atmospheric Opacity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tau.def := '0.0';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tau.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.trx := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.trx.d := 'Receiver temp (ie, all non-atmospheric Tsys contributions) [K]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.trx.def := '50';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.trx.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tatmos := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tatmos.d := 'Temperature of atmosphere [k]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tatmos.def := '250.0';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tatmos.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tcmb := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tcmb.d := 'Temperature of cosmic microwave background [K]';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tcmb.def := '2.7';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.a.tcmb.a := 'Float';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setnoise.s := 'setnoise(mode, table, simplenoise, antefficiency, correfficiency, spillefficiency, tau, trx, tatmos, tcmb)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.d := 'Corrupt phase by the parallactic angle';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.mode := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.mode.d := 'Mode of operation';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.mode.def := '\' calculate\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.mode.a := 'String: \' calculate\' |\' table\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.table := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.table.d := 'Name of table';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.table.def := '\' \' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.table.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.interval := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.interval.d := 'Interval for parallactic angle application, e.g. \' 10s\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.interval.def := '\' 10s\' ';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.a.interval.a := 'Quantity';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setpa.s := 'setpa(mode, table, interval)';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setseed := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setseed.d := 'Set the seed for the random number generator';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setseed.a.seed := [=];
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setseed.a.seed.d := 'Seed';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setseed.a.seed.def := '185349251';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setseed.a.seed.a := 'Int';
help::pkg.synthesis.newsimulator.objs.newsimulator.m.setseed.s := 'setseed(seed)';
help::pkg.synthesis.newsimulator.objs.newsimhelper := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.m := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.c := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.d := 'Tool to help newsimulator';
help::pkg.synthesis.newsimulator.objs.newsimhelper.c.newsimhelper := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.c.newsimhelper.d := 'Construct a newsimhelper tool';
help::pkg.synthesis.newsimulator.objs.newsimhelper.c.newsimhelper.a.schedtable := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.c.newsimhelper.a.schedtable.d := 'Table of antenna locations';
help::pkg.synthesis.newsimulator.objs.newsimhelper.c.newsimhelper.a.schedtable.def := 'unset';
help::pkg.synthesis.newsimulator.objs.newsimhelper.c.newsimhelper.a.schedtable.a := 'Table';
help::pkg.synthesis.newsimulator.objs.newsimhelper.c.newsimhelper.s := 'newsimhelper(schedtable)';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.close := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.close.d := 'Close the newsimhelper tool';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.close.s := 'close()';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.type := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.type.d := 'Return the type of this tool';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.type.s := 'type()';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarrays := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarrays.d := 'Get all arrays known to newsimhelper';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarrays.s := 'getarrays()';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarray := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarray.d := 'Get a specific array';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarray.a.arrayname := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarray.a.arrayname.d := 'Name of array';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarray.a.arrayname.def := '\' VLAD\' ';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarray.a.arrayname.a := 'String';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getarray.s := 'getarray(arrayname)';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getallstations := [=];
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getallstations.d := 'Get all stations known to newsimhelper';
help::pkg.synthesis.newsimulator.objs.newsimhelper.m.getallstations.s := 'getallstations()';

help::pkg.synthesis.synthesistester := [=];
help::pkg.synthesis.synthesistester.objs := [=];
help::pkg.synthesis.synthesistester.funs := [=];
help::pkg.synthesis.synthesistester.d := 'Module for testing synthesis processing';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.d := 'Testing of imager using resulting source positions';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.d := 'tool for testing the validity of imager and pimager results';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.d := 'Construct an imagerpositiontest tool';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.a.testdir := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.a.testdir.d := 'sub-directory of the current directory where imagerpositiontest will create datasets and other files';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.a.testdir.def := '\' imager\_position\_test\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.a.testdir.a := 'String';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.a.clean := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.a.clean.d := 'Delete files from under testdir which have been left from a previous run';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.a.clean.def := 'T';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.a.clean.a := 'Boolean';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.c.imagerpositiontest.s := 'imagerpositiontest(testdir, clean)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.cleanup := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.cleanup.d := 'Clean up from a previous run.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.cleanup.s := 'cleanup()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.done := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.done.d := 'Release the resources used by this tool.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.done.s := 'done()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.dotests := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.dotests.d := 'Run the tests.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.dotests.s := 'dotests()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.d := 'Locate source positions in an image';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.numsources := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.numsources.d := 'The number of sources to look for';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.numsources.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.numsources.a := 'Int $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.imagename := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.imagename.d := 'The name of the target disk image';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.imagename.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.imagename.a := 'String (any valid disk image table)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.clname := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.clname.d := 'The name of the generated componentlist table';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.clname.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.a.clname.a := 'String (any valid filename)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.findsource.s := 'findsource(numsources, imagename, clname)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_beam := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_beam.d := 'Get the restoring beam plus some extra info from the restored image.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_beam.s := 'get_beam()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_center_position := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_center_position.d := 'Get the center position for the map that will be created.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_center_position.s := 'get_center_position()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_componentlisttable := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_componentlisttable.d := 'Get the name of the disk table containing the positions of the simulated components.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_componentlisttable.s := 'get_componentlisttable()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_corresponding_comps := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_corresponding_comps.d := 'Return the map of found components in the restored image to their true component counterparts.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_corresponding_comps.s := 'get_corresponding_comps()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_rms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_rms.d := 'Get the rms from the restored map in an "intelligent" fashion.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_rms.a.im := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_rms.a.im.d := 'A valid image tool from which to get the rms';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_rms.a.im.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_rms.a.im.a := 'Any valid image tool';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_rms.s := 'get_rms(im)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_seed := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_seed.d := 'Get the seed for the random number generator';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_seed.s := 'get_seed()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_source_box := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_source_box.d := 'Get the pixel coordinates of a box encompassing the simulated sources.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.get_source_box.s := 'get_source_box()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.d := 'Make the default simulated component list.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.clname := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.clname.d := 'The name of the componentlist table that will be written to disk';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.clname.def := '\' dummy.cl\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.clname.a := 'String (any valid file name)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.frequency := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.frequency.d := 'The reference frequency of the component list';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.frequency.def := 'unset (will use the user-specified frequency from  set\_sim\_parms() or the tool\' s default frequency)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.frequency.a := 'String (frequency expressed as a quantity)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.epoch := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.epoch.d := 'The epoch of the positions';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.epoch.def := '\' J2000\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.epoch.a := 'String (any recognized epoch)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.nsources := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.nsources.d := 'The number of components to create';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.nsources.def := '4';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.nsources.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.phasecenter := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.phasecenter.d := 'The phasecenter';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.phasecenter.def := 'unset (uses the user specified phase center from set\_sim\_parms() or the tool\' s default phase center';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.phasecenter.a := 'Direction';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.fluxmin := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.fluxmin.d := 'The minimum flux a component can have in Jy';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.fluxmin.def := '3';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.fluxmin.a := 'Float $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.fluxmax := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.fluxmax.d := 'The maximum flux a component can have in Jy';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.fluxmax.def := '10';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.fluxmax.a := 'Float =$>$ minflux';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.minsep := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.minsep.d := 'The minimum separation between components in arcsec';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.minsep.def := '5';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.a.minsep.a := 'Float =$>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_cl.s := 'make_default_cl(clname, frequency, epoch, nsources, phasecenter, fluxmin, fluxmax, minsep)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.d := 'Create the default simulator.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.a.frequency := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.a.frequency.d := 'The frequency for the output ms.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.a.frequency.def := 'unset will use the tool default value or the user-specified value in set\_sim\_parms()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.a.frequency.a := 'Quantity (frequency)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.a.arrayscale := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.a.arrayscale.d := 'The scale (baseline lengths) of the default interferometer';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.a.arrayscale.def := '1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.a.arrayscale.a := 'Float $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_default_simulator.s := 'make_default_simulator(frequency, arrayscale)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.d := 'Make the images';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.a.ms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.a.ms.d := 'The name of the MS on disk.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.a.ms.def := 'unset (will use the tool default value)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.a.ms.a := 'String (any valid name of a disk MS)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.a.imagename := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.a.imagename.d := 'The output imagename prefix (things like .dirty and .model will be appended to label the appropriate images)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.a.imagename.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.a.imagename.a := 'String (any valid filename)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_image.s := 'make_image(ms, imagename)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.d := 'Make an image of the simulated component distribution.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.a.template := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.a.template.d := 'Name of the template disk image to use';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.a.template.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.a.template.a := 'String: (any valid disk image name)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.a.imagename := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.a.imagename.d := 'Name of the output model image';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.a.imagename.def := '\' simulimage\_orig.model\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.a.imagename.a := 'String (any valid file name)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_model_image.s := 'make_model_image(template, imagename)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.d := 'Make the MS containing the simulated data';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.clfile := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.clfile.d := 'The name of the coponentlist disk table to use for generating the MS';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.clfile.def := 'unset (will use the tool\' s default or that specified by the user in set\_componentlisttable())';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.clfile.a := 'String (a valid componentlist table name)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.docorrupt := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.docorrupt.d := 'Should noise be added to the MS data?';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.docorrupt.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.docorrupt.a := 'Boolean';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.noiselevel := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.noiselevel.d := 'If docorrupt==T, the level of the noise that is passed to simulator.corrupt()';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.noiselevel.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.a.noiselevel.a := 'String (a valid flux density quantity)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.make_ms.s := 'make_ms(clfile, docorrupt, noiselevel)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_mask := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_mask.d := 'Specify how the clean mask should be set.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_mask.a.type := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_mask.a.type.d := 'The mask type to use when cleaning';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_mask.a.type.def := '\' all\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_mask.a.type.a := 'String: \' all\' $|$\' comps\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_mask.s := 'set_clean_mask(type)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.d := 'Set up the parameters for a clean test.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.algorithm := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.algorithm.d := 'The clean algorithm to use';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.algorithm.def := '\' clark\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.algorithm.a := 'String: \' clark\' $|$\' hogbom\' $|$\' mfclark\' $|$\' mfhogbom\' $|$\' wfclark\' $|$\' wfhogbom\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.niter := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.niter.d := 'Number of clean iterations';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.niter.def := '1000';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.niter.a := 'Integer $>$= 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.gain := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.gain.d := 'Loop gain factor';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.gain.def := '0.1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.gain.a := 'Float $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.threshold := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.threshold.d := 'Residual level at which to stop cleaning';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.threshold.def := '\' 0Jy\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.threshold.a := 'Quantity (flux density)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.displayprogress := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.displayprogress.d := 'Display the progress during the clean?';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.displayprogress.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.displayprogress.a := 'Boolean';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.fixed := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.fixed.d := 'Keep one or more models fixed?';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.fixed.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.a.fixed.a := 'Array of booleans';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_clean_parms.s := 'set_clean_parms(algorithm, niter, gain, threshold, displayprogress, fixed)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_componentlisttable := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_componentlisttable.d := 'Set the name of the componentlist table.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_componentlisttable.a.cltablename := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_componentlisttable.a.cltablename.d := 'The disk componentlist table name';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_componentlisttable.a.cltablename.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_componentlisttable.a.cltablename.a := 'String (any valid disk component list table name)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_componentlisttable.s := 'set_componentlisttable(cltablename)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_deconvolution_function := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_deconvolution_function.d := 'Set the decnvolution function to use.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_deconvolution_function.a.df := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_deconvolution_function.a.df.d := 'The deconvolution function to use';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_deconvolution_function.a.df.def := '\' clean\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_deconvolution_function.a.df.a := 'String: \' clean\' $|$\' mem\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_deconvolution_function.s := 'set_deconvolution_function(df)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.d := 'Set the MS parameters to be used for imaging.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.mode := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.mode.d := 'Type of processing';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.mode.def := '\' channel\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.mode.a := 'String: \' channel\' $|$\' velocity\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.nchan := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.nchan.d := 'Number of channels';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.nchan.def := 'Unset (will use number of channels in the simulated MS';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.nchan.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.start := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.start.d := 'Starting channel';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.start.def := '1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.start.a := '0 $>$ Integer $>$= number of channels in data set';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.step := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.step.d := 'Step in channels';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.step.def := '1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.step.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.msselect := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.msselect.d := 'TaQL select string applied as a logical "and" with the other selections';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.msselect.def := 'Unset';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.a.msselect.a := 'String (valid TaQL query)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_data_parms.s := 'set_imaging_data_parms(mode, nchan, start, step, msselect)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.d := 'Set some general options for subsequent processing.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.ftpmachine := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.ftpmachine.d := 'Fourier transform machine';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.ftpmachine.def := '\' gridft\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.ftpmachine.a := '\' gridft\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.cache := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.cache.d := 'Size of gridding cache in complex pixels';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.cache.def := '0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.cache.a := 'Integer $>$= 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.tile := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.tile.d := 'Size of a gridding tile in pixels (in 1 dimension)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.tile.def := '16';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.tile.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.gridfunction := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.gridfunction.d := 'Gridding function';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.gridfunction.def := '\' SF\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.gridfunction.a := 'String: \' SF\' $|$\' BOX\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.location := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.location.d := 'Location used in phase rotations';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.location.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.location.a := 'position measure';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.padding := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.padding.d := 'Padding factor in image plane';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.padding.def := '1.0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.a.padding.a := 'Float $>$= 1.0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_options.s := 'set_imaging_options(ftpmachine, cache, tile, gridfunction, location, padding)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.d := 'Set the parameters to be used for imaging.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.nx := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.nx.d := 'Number of pixels in the x direction.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.nx.def := 'Unset. (determined by (p)imager.advise())';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.nx.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.ny := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.ny.d := 'Number of pixels in the y direction.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.ny.def := 'Unset. (determined by (p)imager.advise())';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.ny.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.cellx := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.cellx.d := 'Cell size in the x direction';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.cellx.def := 'Unset. (determined by (p)imager.advise())';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.cellx.a := 'Qunatity (angle)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.celly := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.celly.d := 'Cell size in the y direction';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.celly.def := 'Unset. (determined by (p)imager.advise())';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.celly.a := 'Qunatity (angle)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.stokes := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.stokes.d := 'Stokes parameters to image';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.stokes.def := 'Unset (will be set to \' I\' )';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.stokes.a := 'String: \' I\' $|$\' IV\' $|$\' IQU\' $|$\' IQUV\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.doshift := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.doshift.d := 'Use the specified phase center?';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.doshift.def := 'Unset (will be set according to if the test is for a single field or multiple fields';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.doshift.a := 'Boolean';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.phasecenter := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.phasecenter.d := 'Direction of phase center as a measure';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.phasecenter.def := 'Unset (will be set if the the test is multi field)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.phasecenter.a := 'MDirection';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.shiftx := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.shiftx.d := 'Shift in x';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.shiftx.def := '\' 0arcsec\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.shiftx.a := 'Quantity (angle)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.shifty := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.shifty.d := 'Shift in y';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.shifty.def := '\' 0arcsec\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.shifty.a := 'Quantity (angle)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.mode := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.mode.d := 'Type of processing';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.mode.def := '\' channel\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.mode.a := 'String: \' mfs\' $|$\' channel\' $|$\' velocity\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.nchan := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.nchan.d := 'Number of channels';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.nchan.def := 'Unset (will use number of channels in the simulated data set)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.nchan.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.start := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.start.d := 'Starting channel';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.start.def := '1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.start.a := '0 $>$ Integer $>$= number of channels in data set';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.step := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.step.d := 'Step in channels';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.step.def := '1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.step.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.facets := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.facets.d := 'Number of facets on each axis';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.facets.def := 'Unset (determined by (p)imager.advise())';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.a.facets.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_parms.s := 'set_imaging_parms(nx, ny, cellx, celly, stokes, doshift, phasecenter, shiftx, shifty, mode, nchan, start, step, facets)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_tool_type := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_tool_type.d := 'Set the imaging tool to test.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_tool_type.a.type := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_tool_type.a.type.d := 'Tool to use';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_tool_type.a.type.def := '\' imager\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_tool_type.a.type.a := 'String: \' imager\' $|$\' pimager';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_imaging_tool_type.s := 'set_imaging_tool_type(type)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.d := 'Set parameters to be used in a mem deconvolution.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.algorithm := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.algorithm.d := 'MEM algorithm to use';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.algorithm.def := '\' entropy\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.algorithm.a := 'String:\' entropy\' $|$\' emptiness\' $|$\' mfentropy\' $|$\' mfemptiness\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.niter := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.niter.d := 'Number of mem iterations';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.niter.def := '20';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.niter.a := 'Integer $>$= 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.sigma := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.sigma.d := 'Image sigma to try to achieve';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.sigma.def := '\' 0.001Jy\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.sigma.a := 'Quantity (flux density)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.targetflux := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.targetflux.d := 'Target flux for final image';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.targetflux.def := '\' 1.0Jy\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.targetflux.a := 'Quantity (flux density)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.constrainflux := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.constrainflux.d := 'Constrain image to match target flux? else targetflux used only to initialize model';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.constrainflux.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.constrainflux.a := 'Boolean';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.displayprogress := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.displayprogress.d := 'Display the progress of the deconvolution';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.displayprogress.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.displayprogress.a := 'Booean';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.fixed := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.fixed.d := 'Keep model fixed?';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.fixed.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.a.fixed.a := 'Vector of booleans';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mem_parms.s := 'set_mem_parms(algorithm, niter, sigma, targetflux, constrainflux, displayprogress, fixed)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.d := 'Set control parameters for multi-field imaging tests.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.cyclefactor := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.cyclefactor.d := 'Cycle threshold = this * max sidelobe * max resid';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.cyclefactor.def := '3.0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.cyclefactor.a := 'Float';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.cyclespeedup := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.cyclespeedup.d := 'Cycle threshold doubles in this number of iterations';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.cyclespeedup.def := '-1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.cyclespeedup.a := 'Float';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.stoplargenegatives := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.stoplargenegatives.d := 'Stop the multiscale cycle for the first n cycles when a negative comp is found on the largest scale';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.stoplargenegatives.def := '2';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.stoplargenegatives.a := 'Intger';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.stoppointmode := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.stoppointmode.d := 'Stop multiscale altogether if the smallest scale recieves this many consecutive components';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.stoppointmode.def := '-1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.stoppointmode.a := 'Integer';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.scaletype := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.scaletype.d := 'mage plane flux scale type';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.scaletype.def := '"NONE\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.scaletype.a := 'String: \' SAULT\' $|$\' NONE\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.minpb := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.minpb.d := 'Minimum PB level to use';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.minpb.def := '0.1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.minpb.a := 'Float $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.constpb := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.constpb.d := 'In Sault weighting the flux scale is constant above this PB level';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.constpb.def := '0.4';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.a.constpb.a := '0 $>$ Float $>$ 1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_mfcontrol_parms.s := 'set_mfcontrol_parms(cyclefactor, cyclespeedup, stoplargenegatives, stoppointmode, scaletype, minpb, constpb)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_pimager_numprocs := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_pimager_numprocs.d := 'Set the number of processors available to pimager.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_pimager_numprocs.a.numprocs := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_pimager_numprocs.a.numprocs.d := 'The number of processors available to pimager';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_pimager_numprocs.a.numprocs.def := '1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_pimager_numprocs.a.numprocs.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_pimager_numprocs.s := 'set_pimager_numprocs(numprocs)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_seed := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_seed.d := 'Set the seed used by the random number generator for creating the simulated components.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_seed.a.seed := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_seed.a.seed.d := 'The value to use for seeding the random number generator';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_seed.a.seed.def := 'None (is set initially during tool construction)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_seed.a.seed.a := 'Float';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_seed.s := 'set_seed(seed)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.d := 'Set up the parameters to be used when creating the default simulator.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.frequency := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.frequency.d := 'The observing frequency';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.frequency.def := '\' 22GHz\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.frequency.a := 'Quantity (frequency)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.docorrupt := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.docorrupt.d := 'Add noise to the simulated data by calling simulator.corrupt()?';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.docorrupt.def := 'F';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.docorrupt.a := 'Boolean';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.scalefactor := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.scalefactor.d := 'The array scale factor.  Controls the size of the baselines (and hence the resolution in the images)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.scalefactor.def := '1.0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.scalefactor.a := 'Float $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nchan := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nchan.d := 'Number of channels in the simulated dataset';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nchan.def := '1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nchan.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nsources := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nsources.d := 'Number of sources to simulate';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nsources.def := '4';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nsources.a := 'Integer $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.noiselevel := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.noiselevel.d := 'The level of the noise to add when docorrupt==T';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.noiselevel.def := '\' 1Jy\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.noiselevel.a := 'Quantity (flux density)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nfields := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nfields.d := 'The number of fields to simulate';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nfields.def := '1';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.nfields.a := 'Integer $>$ 0 and non prime if $>$ 2';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.deltafreq := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.deltafreq.d := 'Channel seperation';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.deltafreq.def := '\' 1MHz\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.deltafreq.a := 'Quantity (frequency)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.freqresolution := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.freqresolution.d := 'Frequency resolution';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.freqresolution.def := '\' 1MHz\' ';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.freqresolution.a := 'Quantity (frequency)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.sourcedirection := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.sourcedirection.d := 'Direction of source';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.sourcedirection.def := 'dm.direction(\' J2000\' , \' 16h00m0.0\' , \' 50d0m0.000\' )';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.sourcedirection.a := 'MDirection';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.source_spread := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.source_spread.d := 'Determines over how large of field the sources will be dispersed, in multiples of the field of view';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.source_spread.def := '1.0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.source_spread.a := 'Float $>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.minflux := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.minflux.d := 'The minimum flux density for a source.  Flux densities are determined using a uniform distribution between minflux and maxflux';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.minflux.def := '3.0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.minflux.a := '0 $<$ Float $<$= maxflux';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.maxflux := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.maxflux.d := 'The maximum flux density for a source.  Flux densities are determined using a uniform distribution between minflux and maxflux';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.maxflux.def := '3.0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.maxflux.a := 'Float $>$= minflux';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.minsep := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.minsep.d := 'The minimum source separation allowed in arcsec.  No two sources will be closer than this.  Note that if minsep is chosen to be too large for the field of view, source\_spread, and nsources, a valid source position distribution will not be possible.  In this case, make\_default\_cl() (or dotests()) will fail (with an informative message)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.minsep.def := '5';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.minsep.a := 'Float $>$= 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.seed := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.seed.d := 'The value to use for the simulator random number generator seed';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.seed.def := '185349251';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.a.seed.a := 'Float';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_sim_parms.s := 'set_sim_parms(frequency, docorrupt, scalefactor, nchan, nsources, noiselevel, nfields, deltafreq, freqresolution, sourcedirection, source_spread, minflux, maxflux, minsep, seed)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_simulator := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_simulator.d := 'Set an alternate simulator to be used for generating the MS.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_simulator.a.sim := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_simulator.a.sim.d := 'The user-defined simulator to use';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_simulator.a.sim.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_simulator.a.sim.a := 'A valid simulator tool';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_simulator.s := 'set_simulator(sim)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_tolerance := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_tolerance.d := 'Set the tolerance allowed for a position test to pass.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_tolerance.a.tol := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_tolerance.a.tol.d := 'The allowed tolerance in beam widths';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_tolerance.a.tol.def := '1.0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_tolerance.a.tol.a := 'Float =$>$ 0';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.set_tolerance.s := 'set_tolerance(tol)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.d := 'Compare the found source positions with the true source positions.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.a.complistfound := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.a.complistfound.d := 'The disk componentlist containing the found components';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.a.complistfound.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.a.complistfound.a := 'Name of disk componentlist';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.a.complisttrue := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.a.complisttrue.d := 'The disk componentlist containing the simulated components';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.a.complisttrue.def := 'None';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.a.complisttrue.a := 'Name of disk componentlist';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.sourcecompare.s := 'sourcecompare(complistfound, complisttrue)';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.view := [=];
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.view.d := 'View the restored image.';
help::pkg.synthesis.synthesistester.objs.imagerpositiontest.m.view.s := 'view()';
help::pkg.synthesis.synthesistester.funs.vlaendtoend := [=];
help::pkg.synthesis.synthesistester.funs.vlaendtoend.a := [=];
help::pkg.synthesis.synthesistester.funs.vlaendtoend.d := 'Test VLA end to end processing';
help::pkg.synthesis.synthesistester.funs.vlaendtoend.s := 'vlaendtoend()';

help::pkg.synthesis.synthesistoys := [=];
help::pkg.synthesis.synthesistoys.objs := [=];
help::pkg.synthesis.synthesistoys.funs := [=];
help::pkg.synthesis.synthesistoys.d := 'Module of toys for playing with synthesis imaging';
help::pkg.synthesis.synthesistoys.objs.synthesistoy := [=];
help::pkg.synthesis.synthesistoys.objs.synthesistoy.m := [=];
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c := [=];
help::pkg.synthesis.synthesistoys.objs.synthesistoy.d := 'Tool for playing with synthesis imaging';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy := [=];
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.d := 'Create a synthesistoy tool';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.modelname := [=];
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.modelname.d := 'Name of image file to use as a model';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.modelname.def := 'unset';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.modelname.a := 'String';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.colormap := [=];
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.colormap.d := 'viewer colormap to use in colored displays';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.colormap.def := '\' Greyscale 1\' ';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.colormap.a := 'String';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.widgetset := [=];
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.widgetset.d := 'widgetserver \tool\ to use to build the GUI';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.widgetset.def := 'ddlws';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.a.widgetset.a := 'widgetserver \tool';
help::pkg.synthesis.synthesistoys.objs.synthesistoy.c.synthesistoy.s := 'synthesistoy(modelname, colormap, widgetset)';

