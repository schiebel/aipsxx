# webpublish: Publish results to the web
#
#   Copyright (C) 1996,1997,1998,1999,2000,2001,2002,2003
#   Associated Universities, Inc. Washington DC, USA.
#
#   This program is free software; you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the Free
#   Software Foundation; either version 2 of the License, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful, but WITHOUT
#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
#   more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   675 Massachusetts Ave, Cambridge, MA 02139, USA.
#
#   Correspondence concerning AIPS++ should be addressed as follows:
#          Internet email: aips2-request@nrao.edu.
#          Postal address: AIPS++ Project Office
#                          National Radio Astronomy Observatory
#                          520 Edgemont Road
#                          Charlottesville, VA 22903-2475 USA
#
#   $Id: webpublish.g,v 19.3 2004/08/25 02:10:48 cvsmgr Exp $
#

pragma include once;

webpublish := function(file='.', what='An AIPS++ generated web page',
		       colormap='Rainbow 3') {

  public := [=];
  private := [=];

  include 'os.g';
  private.root := file;

  if(!dos.fileexists(private.root)) {
    ok:=shell(spaste('mkdir -p ', private.root));
    if (ok::status) { throw('Cannot make results directory')};
  }

  private.parent := spaste(file, '/index.html');
  note('Writing root html file to ', private.parent);

  private.what := what;

  private.colormap := colormap;

  private.haveviewer := have_gui();

  private.tables := [=];
  include 'table.g';
#
# Write header for html
#
  private.writehtmlheader := function(f, title) {
    wider private;
    fprintf (f, '%s\n', '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">');
    fprintf (f, '%s\n', '<html>');
    fprintf (f, '%s\n', '  <head>');
    fprintf (f, '%s\n', spaste('    <title>',title,'</title>'));
    fprintf (f, '%s\n', '  </head>');
    fprintf (f, '%s\n', '  <body>');
    fprintf (f, '%s\n', spaste('    <h1><b>',title,'</b></h1>'));
    return T;
  }

  private.writehtmllink := function(f, text, lnk) {
    wider private;
    fprintf(f, '%s\n', spaste('<p><a href=\"', lnk, '\">', text, '</a></p>'));
  }

  private.writehtmlline := function(f, text='') {
    wider private;
    fprintf(f, '%s\n', text);
  }

  private.writehtmlimage := function(f, text, imagename) {
    wider private;
    fprintf(f, '%s\n', spaste('<p>', text, '</p><img src=\"', imagename, '\"></p>'));;
  }

  private.writehtmlfooter := function(f) {
    wider private;
    fprintf (f, '%s\n', '    <hr>');
    include 'sysinfo.g';
    sysinfo().version(formatted=sys);
    fprintf (f, '%s\n', spaste('    <p><i>This page was generated using the <a href="http://aips2.nrao.edu">AIPS++</a> package, version ', sys));
    include 'misc.g';
    fprintf (f, '%s\n', spaste('    <p><i>Generated by ', environ.USER, ' at ', dms.timetostring(time()), '</i></p>'));
    fprintf (f, '%s\n', '  </body>');
    fprintf (f, '%s\n', '</html>');
    return T;
  }

#
  public.image := function(imfile, heading='', comments='', dozoom=F, dodeep=F,
			   dofits=F, doaxis=T, region=F) {
    wider private, public;
    basename := dos.basename(imfile);
    include 'image.g';
    im := image(imfile);
    if(is_fail(im)) fail;
    include 'catalog.g';
    if(dofits) {
      fitsname := spaste(private.root, '/', basename, '.fits');
      if(dos.fileexists(fitsname)) dc.delete(fitsname, confirm=F);
      im.tofits(fitsname);
      note('Publishing image ', imfile, ' to ', fitsname);
    }
    private.htmlroot:=spaste(private.root, '/', basename, '.html');
    f:=open(spaste('> ', private.htmlroot));
    private.writehtmllink(private.f, basename, dos.basename(private.htmlroot));
    private.writehtmlheader(f, heading);
    if(comments!='') private.writehtmlline(f, comments);

    hdr := [=];
    im.summary(hdr);
    stat := [=];
    for (i in 1:hdr.shape[3]) {
      reg := drm.box([1,1,i,1],[hdr.shape[1], hdr.shape[2], i, 1]);
      stat[i] := [=];
      im.statistics(stat[i], robust=T, region=reg, list=F);
    }
    im.done();
#
# Now write jpg's if we can
#
    ichan := 1;
    if(private.haveviewer) {
      include 'qv.g';
      q:=qv(imfile);
      if(!is_fail(q)) {
	q.setoption('resample', 'bilinear');
	q.papercolors();
	q.colormap(private.colormap);
	if(doaxis) {
	  q.label(paste(imfile));
	}
	if(is_region(region)) {
	  q.region(region);
	}
	q.setoption('wedge', 'right');
	q.writejpg(spaste(private.root, '/', basename, '.jpg'));
	if(dozoom) {
	  q.range(stat[1].min, stat[1].max);
	  q.colormap(private.colormap);
	  if(doaxis) {
	    q.label(paste(imfile));
	  }
	  if(is_region(region)) {
	    q.region(region);
	  }
	  q.setoption('wedge', 'right');
	  ichan := 1;
	  if((len(hdr::shape)>3)&&(hdr::shape[4]>1)) ichan := hdr::shape[4]/2 + 1;
	  zoom:=drm.box([max(1, stat[1].maxpos[1]-hdr.shape[1]/20), max(1, stat[1].maxpos[2]-hdr.shape[2]/20), 1, ichan],
			[min(hdr.shape[1], stat[1].maxpos[1]+hdr.shape[1]/20), min(hdr.shape[2], stat[1].maxpos[2]+hdr.shape[2]/20), 1, ichan]); 
	  q.region(zoom);
	  q.writejpg(spaste(private.root, '/', basename, '.zoom.jpg'));
	}
	q.done();

	if(dodeep) {
	  q:=qv(imfile);
	  q.range(stat[1].min, stat[1].max/10.0);
	  q.setoption('resample', 'bilinear');
	  q.papercolors();
	  q.colormap(private.colormap);
	  if(doaxis) {
	    q.label(paste(imfile));
	  }
	  if(is_region(region)) {
	    q.region(region);
	  }
	  q.setoption('wedge', 'right');
	  q.writejpg(spaste(private.root, '/', basename, '.deep.jpg'));
	  q.done();
	}

	private.writehtmlimage(f, spaste('<i>Image : ', basename, '</i> : Full image, channel ', ichan),
			       spaste(basename, '.jpg'));
	if(dodeep) {
	  private.writehtmlimage(f, spaste('<i>Image : ', basename, '</i> : Factor of ten deeper, channel ', ichan),
			       spaste(basename, '.deep.jpg'));
	}
	if(dozoom) {
	  private.writehtmlimage(f, spaste('<i>Image : ', basename, '</i> : In neighborhood of brightest point, channel ', ichan),
			       spaste(basename, '.zoom.jpg'));
	}
      }
      else {
	private.haveviewer := F;
      }
    }

    private.writehtmlline(f);
    private.writehtmlline(f, '<h2>Header</h2></p>');
    private.writehtmlline(f, '<TABLE BORDER=3 CELLSPACING=3 CELLPADDING=0>');
    private.writehtmlline(f, spaste('<TR><TD>Image name     </TD><TD>', basename, '</TD></TR>'));
    private.writehtmlline(f, spaste('<TR><TD>Image type     </TD><TD>', hdr.imagetype, '</TD></TR>'));
    private.writehtmlline(f, spaste('<TR><TD>Image units    </TD><TD>', hdr.unit, '</TD></TR>'));
    private.writehtmlline(f, spaste('<TR><TD>Image shape    </TD><TD>', hdr.shape, '</TD></TR>'));
    private.writehtmlline(f, '</TABLE>');

    if(has_field(hdr, 'restoringbeam')) {
      private.writehtmlline(f, '<h2>Restoring beam</h2></p>');
      private.writehtmlline(f, spaste(hdr.restoringbeam.major.value, ' ', hdr.restoringbeam.major.unit, ' by ', 
				      hdr.restoringbeam.minor.value, ' ', hdr.restoringbeam.minor.unit, ' at ', 
				      hdr.restoringbeam.positionangle.value, ' ', hdr.restoringbeam.positionangle.unit));
    }
      
    private.writehtmlline(f, '<h2>Coordinate system</h2>');
    private.writehtmlline(f, '<TABLE BORDER=3 CELLSPACING=3 CELLPADDING=0>');
    private.writehtmlline(f, '<TH>Axis</TH><TH>Coord Type</TH><TH>Length</TH><TH>Coord value</TH><TH>Pixel</TH>');
    for (i in 1:length(hdr.shape)) {
      private.writehtmlline(f, spaste('<TR><TD>', i, '</TD><TD>', hdr.axisnames[i], 
				      '</TD><TD>', hdr.shape[i], '</TD><TD>', hdr.refval[i],
				      '</TD><TD>', hdr.refpix[i], '</TD></TR>'));
    }
    private.writehtmlline(f, '</TABLE>');

    private.writehtmlline(f)
    private.writehtmlline(f, '<h2>Statistics</h2>');

    for (i in 1:hdr.shape[3]) {
      private.writehtmlline(f);
      private.writehtmlline(f, spaste('<h3><b>Polarization plane </b></h3>', i));
      private.writehtmlline(f);

      private.writehtmlline(f, '<TABLE BORDER=3 CELLSPACING=3 CELLPADDING=0>');
      private.writehtmlline(f, spaste('<TR><TD>Number points </TD><TD> ', stat[i].npts, '</TD><TD> Sum       </TD><TD> ', stat[i].sum, '</TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>Flux density  </TD><TD> ', stat[i].flux, ' ', hdr.unit,
				      '</TD><TD></TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>Mean          </TD><TD> ', stat[i].mean, ' ', hdr.unit,
				      '</TD><TD>Median    </TD><TD> ', stat[i].median, ' ', hdr.unit, '</TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>RMS           </TD><TD> ', stat[i].rms, ' ', hdr.unit,
				      '</TD><TD>Std. Dev. </TD><TD> ', stat[i].sigma, ' ', hdr.unit, '</TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>MedAbsDevMed  </TD><TD> ', stat[i].medabsdevmed, ' ', hdr.unit,
				      '</TD><TD>Quartile  </TD><TD> ', stat[i].quartile, ' ', hdr.unit, '</TD></TR>'));
      private.writehtmlline(f, '</TABLE>');
      private.writehtmlline(f);
      private.writehtmlline(f, '<TABLE BORDER=3 CELLSPACING=3 CELLPADDING=0>');
      private.writehtmlline(f, '<TH></TH><TH>Value</TH><TH>Pixel coordinates</TH><TH>Sky coordinates</TH>');
      private.writehtmlline(f, spaste('<TR><TD>Minimum</TD><TD>', stat[i].min, ' ', hdr.unit, '</TD><TD>', stat[i].minpos,
				      '</TD><TD>', stat[i].minposf, '</TD></TR>'));
      private.writehtmlline(f, spaste('<TR><TD>Maximum</TD><TD>', stat[i].max, ' ', hdr.unit, '</TD><TD>', stat[i].maxpos,
				      '</TD><TD>', stat[i].maxposf, '</TD></TR>'));
      private.writehtmlline(f, '</TABLE>');
      private.writehtmlline(f);
    }

    if(dofits) {
      private.writehtmlline(f, '<h2>FITS image</h2>');
      private.writehtmllink(f, spaste(basename, '.fits'),
			    spaste(basename, '.fits'));
    }

    private.writehtmlfooter(f);
    f:= F;
#
    return T;
  }

  public.file := function(file) {
    wider private, public;
    f:=open(spaste('< ', file));
    if(is_fail(f)) return throw('Failed to open file ', file, ' : ',
				f::message);
    while(line := read(f)) {
      private.writehtmlline(private.f, spaste('<p>', line, '</p>'));
    }
    f:=F;
  }

  public.log := function() {
    wider private, public;
    include 'logger.g';
    logfile:=spaste(private.root, '/aips++.log.txt');
    dl.printtofile(filename=logfile);
    private.writehtmllink(private.f, 'AIPS++ processing log',
			  dos.basename(logfile));
    return T;
  }

  public.script := function(file) {
    wider private, public;
    include 'logger.g';
    script:=spaste(private.root, '/', file);
    shell(spaste('cp ', file, ' ', script));
    private.writehtmllink(private.f, 'AIPS++ processing script',
			  dos.basename(script));
    return T;
  }

  public.comments := function(comments='') {
    wider private;
    return private.writehtmlline(private.f, comments);
  }

  public.type := function() {
    return "webpublish";
  }

  public.done := function() {
    wider private, public;
    private.writehtmlfooter(private.f);
    private.f:=F;
    private := F;
    return T;
  }

  public.flush := function() {
    wider private, public;
    private.f:=F;
    return (private.f:=open(spaste('>> ', private.parent)));
  }

  private.f:=open(spaste('> ', private.parent));
  private.writehtmlheader(private.f, private.what);

  return public;
}


webpublishtest := function() {
}
