# pgplotwidget_flossy

#pragma include once
note('pgplotwidget middle-mouse zoom plugin included');

include 'types.g';
include 'logger.g';

pgplotwidget_zoom := [=];

pgplotwidget_zoom.attach := function(ref public) {
	
    private := [=];
    private.whenevers := [=];
    private.callbacks := [=];
    private.vertex    := [=];
    private.data	  := [=];
    private.pcom      := [=];
    private.oldCursor := F;
    private.displist  := [=];
    private.lastenv   := 0;
    private.zoomstate := F;
    private.cntr      := 0;
    private.oldrange  := array(0,5,4);

    private.hold := function() {
	wider private,public;
	for (i in ind(private.whenevers)) {
	    deactivate private.whenevers[i];
	}
	
	private.cursorstate:=public.cursor();
	#		public.cursor(private.oldCursor);
    }

    #middle button (two) zoom; button three will 'escape' zoom draw
    private.callbacks.buttontwoon := function(value) {
	wider private;
	private.cntr +:=1;
	#		if (private.cntr > 5 ) {private.cntr:=2};
	#		if (!private.zoomstate) {
	if (private.cntr <= 5) {
	    private.oldrange[private.cntr,]:=public.qwin();
	} else {
	    private.oldrange:=rbind(private.oldrange,public.qwin());
	}
	private.zoomstate:=T;
	#		};
	# 		now cycle through displaylist; play all after env;
	private.displist:=[=];
	junk:=[=];
	j:=1;
	private.lastenv := 0;
	ctr:=0;
	for (i in 1:public.displaylist().ndrawlist()) {
	    tmprec:=public.displaylist().get(i);
	    if (tmprec._method=='subp') {
		dl.log(message='Error: Zoom feature not enabled for multi-panel plots',priority='SEVERE');
		return F;
	    };
	    # skip "settings" if its the first method in the list - this is
	    # automatically generated by the clear we are going to emit before
	    # we replay the rest of this display list.  Otherwise we needlessly
	    # accumulate this initial method
	    if (i != 0 || tmprec._method != "settings") {
		# remember where the last env/swin was seen, in private.displist
		if (tmprec._method=='env' || tmprec._method=='swin'){
		    ctr +:=1;
		    private.lastenv[ctr]:=i;
		}
		junk[tmprec._method]:=tmprec;
		private.displist[j]:=junk;
		j+:=1;
		junk:=[=];
	    }
	}
	#
	ok:=private.hold();
	deactivate private.whenevers.buttontwoon;
	activate private.whenevers.buttontwooff;
	activate private.whenevers.buttonthree;
	private.vertex := value.world;
	private.oldCursor := public.cursor();
	public.cursor('rect',value.world[1],value.world[2]);
    }
    private.whenevers.buttontwoon:=public.setcallback('button2',
						      ref private.callbacks.buttontwoon);
    
    private.callbacks.buttontwooff := function(value) {
	wider private;
	public.cursor('norm');
	deactivate private.whenevers.buttontwooff;
	deactivate private.whenevers.buttonthree;
	activate private.whenevers.buttontwoon;
	activate private.whenevers.buttonone;
	
	if (private.vertex[1] != value.world[1] && 
	    private.vertex[2] != value.world[2]) {
	    #buttons.set_state('zoom',state=T);
	    if (private.vertex[1] < value.world[1]) {
		MinX := private.vertex[1];
		MaxX := value.world[1];
	    } else {
		MinX := value.world[1];
		MaxX := private.vertex[1];
	    }
	    if (private.vertex[2] < value.world[2]) {
		MinY := private.vertex[2];
		MaxY := value.world[2];
	    } else {
		MinY := value.world[2];
		MaxY := private.vertex[2];
	    }
	    #cycle through saved display list
	    public.bbuf();
	    public.clear();
	    # replace *all* the last env or swin values
	    for (i in 1:len(private.lastenv)) {
	       if (private.lastenv[i] > 0) {
		if (has_field(private.displist[private.lastenv[i]],'env')) {
		    private.displist[private.lastenv[i]].env.xmin := MinX;
		    private.displist[private.lastenv[i]].env.xmax := MaxX;
		    private.displist[private.lastenv[i]].env.ymin := MinY;
		    private.displist[private.lastenv[i]].env.ymax := MaxY;
		} else {
		    # must be swin
		    private.displist[private.lastenv[i]].swin.x1 := MinX;
		    private.displist[private.lastenv[i]].swin.x2 := MaxX;
		    private.displist[private.lastenv[i]].swin.y1 := MinY;
		    private.displist[private.lastenv[i]].swin.y2 := MaxY;
		}
	       } else {
		# hmm, no env or swin there - shouldn't happen but try and
		# put one in at any rate
		public.env(MinX,MaxX,MinY,MaxY,0,0);
	       }
	    }; #end for loop
	    # now actually replay it all
	    for (i in 1:len(private.displist)) {
                if (public.canplay(field_names(private.displist[i]))) {
                   public.play(private.displist[i]);
                };
	    }
	    public.ebuf();
	    
	}
	return T;
    }

    private.whenevers.buttontwooff:=public.setcallback('button2',
						       ref private.callbacks.buttontwooff);
    deactivate private.whenevers.buttontwooff;
    
    private.callbacks.buttonthree := function(value) {
	wider private;
	#range_cursor.release();
	public.cursor('norm');
	deactivate private.whenevers.buttonthree;
	deactivate private.whenevers.buttontwooff;
	activate private.whenevers.buttontwoon;
	activate private.whenevers.buttonone;
	private.zoomstate:=F;
    }
    
    private.whenevers.buttonthree:=public.setcallback('button3',
						      ref private.callbacks.buttonthree);
    deactivate private.whenevers.buttonthree;
    
    public.resetzoom := function() {
    	wider private,public;
	private.cntr := 0
    }

    public.unzoom := function () {
	wider private,public;
	if (private.cntr==0) return T;
	#makes zoomActive :=F,redraw();
	public.clear();
	# reset the last env or swin values  with their previous values
	xmin := private.oldrange[private.cntr,1];
	xmax := private.oldrange[private.cntr,2];
	ymin := private.oldrange[private.cntr,3];
	ymax := private.oldrange[private.cntr,4];

	for (i in 1:len(private.lastenv)) {
	    if (private.lastenv[i] > 0) {
	        if (has_field(private.displist[private.lastenv[i]],'env')) {
	    	   private.displist[private.lastenv[i]].env.xmin := xmin;
	    	   private.displist[private.lastenv[i]].env.xmax := xmax;
	    	   private.displist[private.lastenv[i]].env.ymin := ymin;
		   private.displist[private.lastenv[i]].env.ymax := ymax;
	        } else {
		# must be swin
		   private.displist[private.lastenv[i]].swin.x1 := xmin;
		   private.displist[private.lastenv[i]].swin.x2 := xmax;
		   private.displist[private.lastenv[i]].swin.y1 := ymin;
		   private.displist[private.lastenv[i]].swin.y2 := ymax;
	        }
	    } else {
	    # hmm, no env or swin there - shouldn't happen but try and
	    # put one in at any rate
	      public.env(xmin,xmax,ymin,ymax,0,0);
	    }
	}; #end for loop over length of env,swin commands
	# and replay the display list
	for (i in 1:len(private.displist)) {
	    if (public.canplay(field_names(private.displist[i]))) {
	       public.play(private.displist[i]);
	    };
	}
	# reset the saved values
	private.oldrange[private.cntr,]:=0;
	# decrement the counter
	private.cntr -:= 1;
	if (private.cntr < 0) {private.cntr:=0;};
    }
    
    private.callbacks.buttonone := function(value) {
	wider private,public;
	public.unzoom( );
    }
    private.whenevers.buttonone:=public.setcallback('ctrlb2',
						    ref private.callbacks.buttonone);
    
    return T;
}
