# atomsbima.g: help atoms for the bima package. 
# Copyright (C) 1999
# Associated Universities, Inc. Washington DC, USA.
#
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This library is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
# License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
#
# Correspondence concerning AIPS++ should be addressed as follows:
#        Internet email: aips2-request@nrao.edu.
#        Postal address: AIPS++ Project Office
#                        National Radio Astronomy Observatory
#                        520 Edgemont Road
#                        Charlottesville, VA 22903-2475 USA
#
# $Id: atomsbima.g,v 19.948 2006/09/29 01:49:20 wyoung Exp $

pragma include once
val help::pkg.bima := [=];
help::pkg.bima::d := 'BIMA specific modules and tools';

help::pkg.bima.mirfiller := [=];
help::pkg.bima.mirfiller.objs := [=];
help::pkg.bima.mirfiller.funs := [=];
help::pkg.bima.mirfiller.d := 'Module for filling MIRIAD data';
help::pkg.bima.mirfiller.objs.mirfiller := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m := [=];
help::pkg.bima.mirfiller.objs.mirfiller.c := [=];
help::pkg.bima.mirfiller.objs.mirfiller.d := 'a tool for filling MIRIAD data';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller := [=];
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.d := 'Construct a mirfiller tool';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.mirfile := [=];
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.mirfile.d := 'the file name of the Miriad dataset';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.mirfile.def := '';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.mirfile.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.preview := [=];
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.preview.d := 'if true, the file will be scanned in full to determine its contents.  It may be helpful to set this to false for very large files.  In this case, only the beginning of the file is scanned, and the default defpass value is based on the limited information read.';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.preview.def := 'T';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.preview.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.defpass := [=];
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.defpass.d := 'a string indicating the default window passing mode to use.  This mode affects the which kinds of windows get passed when they are not explicitly specified by the select() function.';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.defpass.def := '\' default\' ';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.a.defpass.a := '\' default\'  -- let mirfiller determine which mode to use based on what is found in the data;  \' rawbima\'  -- use a default appropriate for uncalibrated BIMA data: pass all spectral line windows and both side band averages but no window averages;  \' calbima\'  -- use a default appropriate for calibrated data:  pass all spectral line windows but no wideband averages; \' all\'  -- pass all windows and wideband channels by default; \' none\'  -- pass no windows or wideband channels by default, require that they be specified explicitly with select().';
help::pkg.bima.mirfiller.objs.mirfiller.c.mirfiller.s := 'mirfiller(mirfile, preview, defpass)';
help::pkg.bima.mirfiller.objs.mirfiller.m.select := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.select.d := 'select data from the input Miriad dataset.';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.defpass := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.defpass.d := 'a string indicating the default window passing mode to use.  This mode affects the which kinds of windows get passed when they are not explicitly specified by the other parameters.  See general description above for more details.';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.defpass.def := '\' default\' ';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.defpass.a := '\' default\'  -- use the mode that was set (or assumed) at  construction (see  constructor description for more information); \' rawbima\'  -- use a default appropriate for uncalibrated BIMA data: pass all spectral line windows and both side band averages but no window averages;  \' calbima\'  -- use a default appropriate for calibrated data: pass all spectral line windows but no wideband averages; \' all\'  -- pass all windows and wideband channels by default; \' none\'  -- pass no windows or wideband channels by default, require that they be specified explicitly with select().';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.splwin := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.splwin.d := 'a list of one-based spectral window indicies to                     load.';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.splwin.def := '[], the defpass parameter controls how this 		   is interpreted';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.splwin.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.winav := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.winav.d := 'a list of one-based window average indicies to                     load.  An index of 1 means load the average of the 		   first spectral window.';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.winav.def := '[], the defpass parameter 		   controls how this is interpreted';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.winav.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.sbandav := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.sbandav.d := 'a string indicating which sideband averages to                    load.';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.sbandav.def := '\' default\' ';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.a.sbandav.a := '% \' default\'  -- allow the defpass parameter to control sideband average selection; \' lsb\'  -- the lower sideband; \' usb\'  -- the upper sideband; \' all\'  -- both sidebands; \' none\'  -- neither sideband.';
help::pkg.bima.mirfiller.objs.mirfiller.m.select.s := 'select(defpass, splwin, winav, sbandav)';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.d := 'return and/or print a summary of the contents of the Miriad dataset';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.header := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.header.d := 'a record to hold the summary information';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.header.def := '[=]  (allowing the caller to ignore the returned information)';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.header.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.verbose := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.verbose.d := 'If true, detailed information regarding  contents will be sent to the logger.';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.verbose.def := 'T';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.verbose.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.preview := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.preview.d := 'if true, the entire file will be read (if it wasn\' t  already scanned when the tool was constructed) to extract information.   Set this to false to defeat this behavior (e.g. for very large files). In this case, only the first record of the file will be read; thus, some information may be inaccurate if the dataset is a concatonation of  several original datasets.';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.preview.def := 'T';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.a.preview.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.summary.s := 'summary(header, verbose, preview)';
help::pkg.bima.mirfiller.objs.mirfiller.m.getoptions := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.getoptions.d := 'return the current filler options';
help::pkg.bima.mirfiller.objs.mirfiller.m.getoptions.s := 'getoptions()';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.d := 'return the current filler options';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.scanlim := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.scanlim.d := 'the scan time jump limit.  If the jump in       		time between two consecutive Miriad records is greater        		than this limit the scan number that gets written out       		for that record will be incremented.  A change in source       		will always increment the scan number unless scanlim is       		negative; in this case, all records are forced to have       		the same scan number.';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.scanlim.def := '5 minutes';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.scanlim.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.obslim := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.obslim.d := 'the observation ID time jump limit.  The        		observation ID is meant to delimit two tracks that might       		appear in the same file.  If the jump in time        		between two consecutive Miriad records is greater than        		this limit the scan number that gets written out for        		that record will be incremented.  The ID will always be       		incremented if there is a change in telescope or array       		configuration unless obslim is negative, in which case,       		all records will be forced to have the same observation       		ID.';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.obslim.def := '5 minutes';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.obslim.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.tilesize := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.tilesize.d := 'the tiling size to use for storing data       		in the MS using the TiledStorageManager.  If the value        		is <= 0, the standard (non-tiled) storage manager will       		be used.';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.tilesize.def := '32';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.tilesize.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.verbose := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.verbose.d := 'If true, extra messages will be sent to the logger.';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.verbose.def := 'F';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.verbose.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.wideconv := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.wideconv.d := 'a string representing the convention to use                 for interpreting the wideband channels.  Currently,     		this option only affects the writing out of window      		associations in the spectral window subtable.';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.wideconv.def := 'the 		convention detected when mirfiller was 		constructed';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.wideconv.a := '\' bima\'  -- assume that  		the first two wideband channels are the lower \&                  upper sideband averages and the remaining channels represent      		averages of each of the spectral line windows; the output 		wideband and spectral line windows will be linked 		accordingly in the spectral window subtable.  \' none\'  		-- assume no convention for the wideband channels, and 		therefore, encode no associations.';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.joinpol := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.joinpol.d := 'If false (the default), visibilities of                 different polarization correlation types will be 		loaded into different records.  This is appropriate 		for uncalibrated BIMA data.  If this option is true, 		the different polarizations observed at the same time 		will be gathered into a output record.  This is 		appropriate for BIMA polarization measurement data 		that has been calibrated and time-averaged or data 		from a telescope with dual-polarization receivers. 		See section on Polarization in mirfiller module 		description for further discussion.';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.joinpol.def := 'F';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.joinpol.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.tsyswt := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.tsyswt.d := 'If true (the default), the system temperatures                 will be used to estimate the theoretical noise for the 		data which will subsequently be used (automatically) 		as weights during imaging.  If false, system 		temperature weighting will be disabled.  (System 		temperatures will be loaded regardless.)';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.tsyswt.def := 'T';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.tsyswt.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.compress := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.compress.d := 'If true, the data will be                 written in compressed form.  Compression reduces the 		size of the output MS by about a factor of two but 		also limits the dynamic range to 65000:1 (well above 		what is achievable with typical BIMA data).';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.compress.def := 'F';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.compress.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.updmodelint := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.updmodelint.d := 'the time interval after which the model for planet 		observations should be updated.';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.updmodelint.def := '8 hours';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.updmodelint.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.reset := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.reset.d := 'If true, all above options are reset to their       		default values before modifying them to the new values';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.reset.def := 'F';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.a.reset.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.setoptions.s := 'setoptions(scanlim, obslim, tilesize, verbose, wideconv, joinpol, tsyswt, compress, updmodelint, reset)';
help::pkg.bima.mirfiller.objs.mirfiller.m.fill := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.d := 'write selected data into a measurement set';
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.a.msfile := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.a.msfile.d := 'the file name of the ouput MS dataset';
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.a.msfile.def := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.a.msfile.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.a.verbose := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.a.verbose.d := 'If true, extra messages will be sent to the logger during this fill process.  Setting this to true is equivalent to running setoptions(verbose=T) just before calling fill() and then setting it back again after fill() is finished.  If the verbose option has been turned on via setoptions(), then extra messages are sent regardless of the parameter given here.';
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.a.verbose.def := 'F';
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.a.verbose.a := '';
help::pkg.bima.mirfiller.objs.mirfiller.m.fill.s := 'fill(msfile, verbose)';
help::pkg.bima.mirfiller.objs.mirfiller.m.done := [=];
help::pkg.bima.mirfiller.objs.mirfiller.m.done.d := 'shut down this filler';
help::pkg.bima.mirfiller.objs.mirfiller.m.done.s := 'done()';
help::pkg.bima.mirfiller.funs.mirfillertest := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.a := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.d := 'Function to test mirfiller';
help::pkg.bima.mirfiller.funs.mirfillertest.a.summary := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.a.summary.d := 'Record in which to store test results';
help::pkg.bima.mirfiller.funs.mirfillertest.a.summary.def := '[=]';
help::pkg.bima.mirfiller.funs.mirfillertest.a.summary.a := 'Any valid record';
help::pkg.bima.mirfiller.funs.mirfillertest.a.details := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.a.details.d := 'Record in which to store column data when column tests fail';
help::pkg.bima.mirfiller.funs.mirfillertest.a.details.def := '[=]';
help::pkg.bima.mirfiller.funs.mirfillertest.a.details.a := 'Any valid record';
help::pkg.bima.mirfiller.funs.mirfillertest.a.logsummary := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.a.logsummary.d := 'Send a summary of the results to the logger?';
help::pkg.bima.mirfiller.funs.mirfillertest.a.logsummary.def := 'F';
help::pkg.bima.mirfiller.funs.mirfillertest.a.logsummary.a := 'Boolean';
help::pkg.bima.mirfiller.funs.mirfillertest.a.verbose := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.a.verbose.d := 'Controls the amount of logger output, 0=none, higher numbers=more';
help::pkg.bima.mirfiller.funs.mirfillertest.a.verbose.def := '1';
help::pkg.bima.mirfiller.funs.mirfillertest.a.verbose.a := 'Int >= 0';
help::pkg.bima.mirfiller.funs.mirfillertest.a.fill := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.a.fill.d := 'Fill data?';
help::pkg.bima.mirfiller.funs.mirfillertest.a.fill.def := 'T';
help::pkg.bima.mirfiller.funs.mirfillertest.a.fill.a := 'Boolean';
help::pkg.bima.mirfiller.funs.mirfillertest.a.mirdata := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.a.mirdata.d := 'Miriad dataset to fill';
help::pkg.bima.mirfiller.funs.mirfillertest.a.mirdata.def := '\' \'  (defaults to dataset in data repository)';
help::pkg.bima.mirfiller.funs.mirfillertest.a.mirdata.a := 'Any valid Miriad dataset name';
help::pkg.bima.mirfiller.funs.mirfillertest.a.modeldata := [=];
help::pkg.bima.mirfiller.funs.mirfillertest.a.modeldata.d := 'Fiducial measurement set for comparison';
help::pkg.bima.mirfiller.funs.mirfillertest.a.modeldata.def := '\' \'  (defaults to dataset in data repository)';
help::pkg.bima.mirfiller.funs.mirfillertest.a.modeldata.a := 'Any valid measurement set name';
help::pkg.bima.mirfiller.funs.mirfillertest.s := 'mirfillertest(summary, details, logsummary, verbose, fill, mirdata, modeldata)';
help::pkg.bima.mirfiller.funs.miriadtoms := [=];
help::pkg.bima.mirfiller.funs.miriadtoms.a := [=];
help::pkg.bima.mirfiller.funs.miriadtoms.d := 'fill a measurement set from a Miriad dataset';
help::pkg.bima.mirfiller.funs.miriadtoms.a.msfile := [=];
help::pkg.bima.mirfiller.funs.miriadtoms.a.msfile.d := 'the output measurement set name';
help::pkg.bima.mirfiller.funs.miriadtoms.a.msfile.def := '';
help::pkg.bima.mirfiller.funs.miriadtoms.a.msfile.a := '';
help::pkg.bima.mirfiller.funs.miriadtoms.a.mirfile := [=];
help::pkg.bima.mirfiller.funs.miriadtoms.a.mirfile.d := 'the input Miriad dataset name';
help::pkg.bima.mirfiller.funs.miriadtoms.a.mirfile.def := '';
help::pkg.bima.mirfiller.funs.miriadtoms.a.mirfile.a := '';
help::pkg.bima.mirfiller.funs.miriadtoms.a.defpass := [=];
help::pkg.bima.mirfiller.funs.miriadtoms.a.defpass.d := 'a string indicating the window passing mode to use.  This mode affects the which kinds of windows get  selected.';
help::pkg.bima.mirfiller.funs.miriadtoms.a.defpass.def := '\' default\' ';
help::pkg.bima.mirfiller.funs.miriadtoms.a.defpass.a := '\' default\'  -- let mirfiller determine which mode to use based on what is found in the data;  \' rawbima\'  -- use a default appropriate for uncalibrated BIMA data: pass all spectral line windows and both side band averages but no window averages;  \' calbima\'  -- use a default appropriate for calibrated data:  pass all spectral line windows but no wideband averages; \' all\'  -- pass all windows and wideband channels.';
help::pkg.bima.mirfiller.funs.miriadtoms.a.verbose := [=];
help::pkg.bima.mirfiller.funs.miriadtoms.a.verbose.d := 'if true, send lots of messages to the logger.  A summary of the input miriad dataset will be printed, and filling will be done in verbose mode.';
help::pkg.bima.mirfiller.funs.miriadtoms.a.verbose.def := 'F';
help::pkg.bima.mirfiller.funs.miriadtoms.a.verbose.a := '';
help::pkg.bima.mirfiller.funs.miriadtoms.s := 'miriadtoms(msfile, mirfile, defpass, verbose)';

help::pkg.bima.bimafiller := [=];
help::pkg.bima.bimafiller.objs := [=];
help::pkg.bima.bimafiller.funs := [=];
help::pkg.bima.bimafiller.d := 'Module for converting a MIRIAD visibility file to a MeasurementSet';
help::pkg.bima.bimafiller.objs.bimafiller := [=];
help::pkg.bima.bimafiller.objs.bimafiller.m := [=];
help::pkg.bima.bimafiller.objs.bimafiller.c := [=];
help::pkg.bima.bimafiller.objs.bimafiller.d := 'Tool for converting a MIRIAD visibility file to a MeasurementSet (deprecated)';
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller := [=];
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.d := 'Construct the bimafiller tool';
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.a.msname := [=];
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.a.msname.d := 'Filename for MeasurementSet to create';
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.a.msname.def := '\' \' ';
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.a.msname.a := 'String';
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.a.mirname := [=];
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.a.mirname.d := 'Name of an input miriad visibility dataset (note,   miriad datasets are directories).';
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.a.mirname.def := '\' \' ';
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.a.mirname.a := 'String';
help::pkg.bima.bimafiller.objs.bimafiller.c.bimafiller.s := 'bimafiller(msname, mirname)';
help::pkg.bima.bimafiller.objs.bimafiller.m.fill := [=];
help::pkg.bima.bimafiller.objs.bimafiller.m.fill.d := 'Fill the data';
help::pkg.bima.bimafiller.objs.bimafiller.m.fill.s := 'fill()';
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions := [=];
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.d := 'Set options to control the filling.';
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.a.msname := [=];
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.a.msname.d := 'Filename for MeasurementSet to create';
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.a.msname.def := '\' \' ';
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.a.msname.a := 'String';
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.a.mirname := [=];
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.a.mirname.d := 'Name of an input miriad visibility dataset';
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.a.mirname.def := '\' \' ';
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.a.mirname.a := 'String';
help::pkg.bima.bimafiller.objs.bimafiller.m.setoptions.s := 'setoptions(msname, mirname)';
help::pkg.bima.bimafiller.objs.bimafiller.m.gui := [=];
help::pkg.bima.bimafiller.objs.bimafiller.m.gui.d := 'Bring up a GUI for user interaction';
help::pkg.bima.bimafiller.objs.bimafiller.m.gui.s := 'gui()';
help::pkg.bima.bimafiller.objs.bimafiller.m.done := [=];
help::pkg.bima.bimafiller.objs.bimafiller.m.done.d := 'Destroy the bimafiller tool';
help::pkg.bima.bimafiller.objs.bimafiller.m.done.s := 'done()';

help::pkg.bima.bimams := [=];
help::pkg.bima.bimams.objs := [=];
help::pkg.bima.bimams.funs := [=];
help::pkg.bima.bimams.d := 'Module for BIMA measurement set access and manipulation';
help::pkg.bima.bimams.objs.bimams := [=];
help::pkg.bima.bimams.objs.bimams.m := [=];
help::pkg.bima.bimams.objs.bimams.c := [=];
help::pkg.bima.bimams.objs.bimams.d := 'tool for manipulating BIMA measurement sets';
help::pkg.bima.bimams.objs.bimams.c.bimams := [=];
help::pkg.bima.bimams.objs.bimams.c.bimams.d := 'Construct a bimams tool';
help::pkg.bima.bimams.objs.bimams.c.bimams.a.msname := [=];
help::pkg.bima.bimams.objs.bimams.c.bimams.a.msname.d := 'Name of the measurement set on disk to associate with this bimams tool';
help::pkg.bima.bimams.objs.bimams.c.bimams.a.msname.def := '';
help::pkg.bima.bimams.objs.bimams.c.bimams.a.msname.a := 'Disk measurement set name';
help::pkg.bima.bimams.objs.bimams.c.bimams.s := 'bimams(msname)';
help::pkg.bima.bimams.objs.bimams.m.chanwidths := [=];
help::pkg.bima.bimams.objs.bimams.m.chanwidths.d := 'Get the channel widths of the specified type of windows';
help::pkg.bima.bimams.objs.bimams.m.chanwidths.a.type := [=];
help::pkg.bima.bimams.objs.bimams.m.chanwidths.a.type.d := 'type of spectral window';
help::pkg.bima.bimams.objs.bimams.m.chanwidths.a.type.def := '\' c\' ';
help::pkg.bima.bimams.objs.bimams.m.chanwidths.a.type.a := '\' s\'  (sibeband average), \' c\'   (multi-channel data), or \' a\'  (multi-channel average)';
help::pkg.bima.bimams.objs.bimams.m.chanwidths.s := 'chanwidths(type)';
help::pkg.bima.bimams.objs.bimams.m.ddid := [=];
help::pkg.bima.bimams.objs.bimams.m.ddid.d := ' get the DATA\_DESCRIPTION ID (row number)  associated with a specified  spectral window id and a polarization or polarization id.';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.spwid := [=];
help::pkg.bima.bimams.objs.bimams.m.ddid.a.spwid.d := 'The 1-based id (row number) of the spectral window in the SPECTRAL\_WINDOWS subtable';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.spwid.def := '';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.spwid.a := 'Integer';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.stokes := [=];
help::pkg.bima.bimams.objs.bimams.m.ddid.a.stokes.d := 'The stokes parameter associated with the data description. Not used if polid is specified';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.stokes.def := 'YY';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.stokes.a := 'String representation of a valid stokes parameter.';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.polid := [=];
help::pkg.bima.bimams.objs.bimams.m.ddid.a.polid.d := 'The 1-based id (row number) of the desired polarization in the POLARIZATION subtable. If specified, stokes is ignored.';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.polid.def := '';
help::pkg.bima.bimams.objs.bimams.m.ddid.a.polid.a := 'Integer $>$ 0';
help::pkg.bima.bimams.objs.bimams.m.ddid.s := 'ddid(spwid, stokes, polid)';
help::pkg.bima.bimams.objs.bimams.m.ddids := [=];
help::pkg.bima.bimams.objs.bimams.m.ddids.d := ' get the DATA\_DESCRIPTION IDs (row numbers)  associated with specified  spectral window ids and  polarization ids. The spectral window and polarization ids are or-ed within themselves and then anded together.';
help::pkg.bima.bimams.objs.bimams.m.ddids.a.spwids := [=];
help::pkg.bima.bimams.objs.bimams.m.ddids.a.spwids.d := 'The 1-based ids (row numbers) of the spectral windows in the SPECTRAL\_WINDOWS subtable';
help::pkg.bima.bimams.objs.bimams.m.ddids.a.spwids.def := 'unset (all spectral windows)';
help::pkg.bima.bimams.objs.bimams.m.ddids.a.spwids.a := 'Vector of integers';
help::pkg.bima.bimams.objs.bimams.m.ddids.a.polids := [=];
help::pkg.bima.bimams.objs.bimams.m.ddids.a.polids.d := 'The 1-based ids (row numbers) of the desired polarizations in the POLARIZATION subtable.';
help::pkg.bima.bimams.objs.bimams.m.ddids.a.polids.def := 'unset (all polarizations)';
help::pkg.bima.bimams.objs.bimams.m.ddids.a.polids.a := 'Vector of integers';
help::pkg.bima.bimams.objs.bimams.m.ddids.s := 'ddids(spwids, polids)';
help::pkg.bima.bimams.objs.bimams.m.ddtable := [=];
help::pkg.bima.bimams.objs.bimams.m.ddtable.d := ' get the DATA\_DESCRIPTION table associated with the ms';
help::pkg.bima.bimams.objs.bimams.m.ddtable.s := 'ddtable()';
help::pkg.bima.bimams.objs.bimams.m.doptable := [=];
help::pkg.bima.bimams.objs.bimams.m.doptable.d := ' get the DOPPLER table associated with the ms';
help::pkg.bima.bimams.objs.bimams.m.doptable.s := 'doptable()';
help::pkg.bima.bimams.objs.bimams.m.endfreqs := [=];
help::pkg.bima.bimams.objs.bimams.m.endfreqs.d := ' get the frequencies of the last channels  in the multi-channel data spectral windows.';
help::pkg.bima.bimams.objs.bimams.m.endfreqs.s := 'endfreqs()';
help::pkg.bima.bimams.objs.bimams.m.fieldids := [=];
help::pkg.bima.bimams.objs.bimams.m.fieldids.d := 'Get the 1-based field ids associated with the specified source';
help::pkg.bima.bimams.objs.bimams.m.fieldids.a.sname := [=];
help::pkg.bima.bimams.objs.bimams.m.fieldids.a.sname.d := 'The source to which to get the field ids for';
help::pkg.bima.bimams.objs.bimams.m.fieldids.a.sname.def := 'None';
help::pkg.bima.bimams.objs.bimams.m.fieldids.a.sname.a := 'String';
help::pkg.bima.bimams.objs.bimams.m.fieldids.s := 'fieldids(sname)';
help::pkg.bima.bimams.objs.bimams.m.fieldtable := [=];
help::pkg.bima.bimams.objs.bimams.m.fieldtable.d := 'Get the FIELD subtable as a table tool';
help::pkg.bima.bimams.objs.bimams.m.fieldtable.s := 'fieldtable()';
help::pkg.bima.bimams.objs.bimams.m.mcaddids := [=];
help::pkg.bima.bimams.objs.bimams.m.mcaddids.d := 'Given a list of 1-based DATA DESCRIPTION ids which describe multi-channel data spectral windows, get a list of 1-based  DATA DESCRIPTION ids which correspond to the multi-channel average windows.';
help::pkg.bima.bimams.objs.bimams.m.mcaddids.a.mcd := [=];
help::pkg.bima.bimams.objs.bimams.m.mcaddids.a.mcd.d := 'vector of 1-based data description ids which refer to multichannel data windows.';
help::pkg.bima.bimams.objs.bimams.m.mcaddids.a.mcd.def := '';
help::pkg.bima.bimams.objs.bimams.m.mcaddids.a.mcd.a := 'Vector of integers';
help::pkg.bima.bimams.objs.bimams.m.mcaddids.s := 'mcaddids(mcd)';
help::pkg.bima.bimams.objs.bimams.m.ms := [=];
help::pkg.bima.bimams.objs.bimams.m.ms.d := ' get the ms tool contained within this bimams tool.';
help::pkg.bima.bimams.objs.bimams.m.ms.s := 'ms()';
help::pkg.bima.bimams.objs.bimams.m.namespw := [=];
help::pkg.bima.bimams.objs.bimams.m.namespw.d := ' Assign a name to a spectral window.';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.sb := [=];
help::pkg.bima.bimams.objs.bimams.m.namespw.a.sb.d := 'The sideband in which the window is located.';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.sb.def := '';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.sb.a := '\' u\'  (usb) or \' l\'  (lsb)';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.type := [=];
help::pkg.bima.bimams.objs.bimams.m.namespw.a.type.d := 'type of spectral window';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.type.def := '';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.type.a := '\' s\'  (sibeband average), \' c\'   (multi-channel data), or \' a\'  (multi-channel average)';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.mcn := [=];
help::pkg.bima.bimams.objs.bimams.m.namespw.a.mcn.d := 'the 1-based location of this window in the SPECTRAL\_WINDOWS table with respect to other windows of the same type  and sideband (usually NOT the same as its row number in this table). Not used if type=\' s\' ';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.mcn.def := '1';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.mcn.a := 'Integer from 1 to the number of spectral windows of the specified type in the specified sideband';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.name := [=];
help::pkg.bima.bimams.objs.bimams.m.namespw.a.name.d := 'the name to assign to this window';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.name.def := '';
help::pkg.bima.bimams.objs.bimams.m.namespw.a.name.a := 'String';
help::pkg.bima.bimams.objs.bimams.m.namespw.s := 'namespw(sb, type, mcn, name)';
help::pkg.bima.bimams.objs.bimams.m.namespwid := [=];
help::pkg.bima.bimams.objs.bimams.m.namespwid.d := ' Assign a name to a spectral window by specifying its id';
help::pkg.bima.bimams.objs.bimams.m.namespwid.a.spwid := [=];
help::pkg.bima.bimams.objs.bimams.m.namespwid.a.spwid.d := 'The 1-based id of the spectral window (ie, the row number of the window in the SPECTRAL\_WINDOWS table)';
help::pkg.bima.bimams.objs.bimams.m.namespwid.a.spwid.def := '';
help::pkg.bima.bimams.objs.bimams.m.namespwid.a.spwid.a := 'Integer $>=$ 1 and $<=$ number of spectral windows';
help::pkg.bima.bimams.objs.bimams.m.namespwid.a.name := [=];
help::pkg.bima.bimams.objs.bimams.m.namespwid.a.name.d := 'the name to assign to this window';
help::pkg.bima.bimams.objs.bimams.m.namespwid.a.name.def := '';
help::pkg.bima.bimams.objs.bimams.m.namespwid.a.name.a := 'String';
help::pkg.bima.bimams.objs.bimams.m.namespwid.s := 'namespwid(spwid, name)';
help::pkg.bima.bimams.objs.bimams.m.nchans := [=];
help::pkg.bima.bimams.objs.bimams.m.nchans.d := ' Get the number of channels in each multi-channel data spectral window';
help::pkg.bima.bimams.objs.bimams.m.nchans.s := 'nchans()';
help::pkg.bima.bimams.objs.bimams.m.nspw := [=];
help::pkg.bima.bimams.objs.bimams.m.nspw.d := ' Get the number of spectral windows';
help::pkg.bima.bimams.objs.bimams.m.nspw.s := 'nspw()';
help::pkg.bima.bimams.objs.bimams.m.polartable := [=];
help::pkg.bima.bimams.objs.bimams.m.polartable.d := ' Get the POLARIZATION subtable';
help::pkg.bima.bimams.objs.bimams.m.polartable.s := 'polartable()';
help::pkg.bima.bimams.objs.bimams.m.polarids := [=];
help::pkg.bima.bimams.objs.bimams.m.polarids.d := 'Get a list of polarization ids';
help::pkg.bima.bimams.objs.bimams.m.polarids.a.stokes := [=];
help::pkg.bima.bimams.objs.bimams.m.polarids.a.stokes.d := 'The stokes parameter associated with the polarization id (e.g., \' YY\' , \' I\' )';
help::pkg.bima.bimams.objs.bimams.m.polarids.a.stokes.def := '';
help::pkg.bima.bimams.objs.bimams.m.polarids.a.stokes.a := 'String';
help::pkg.bima.bimams.objs.bimams.m.polarids.s := 'polarids(stokes)';
help::pkg.bima.bimams.objs.bimams.m.reavg := [=];
help::pkg.bima.bimams.objs.bimams.m.reavg.d := 'Recompute sideband averages and channel averages based on channel data flags';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.out := [=];
help::pkg.bima.bimams.objs.bimams.m.reavg.a.out.d := 'the output dataset, if not specified the input dataset is modified and no new dataset is written';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.out.def := '\' \' ';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.out.a := 'String';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.dosort := [=];
help::pkg.bima.bimams.objs.bimams.m.reavg.a.dosort.d := 'sort the data when doing subqueries, if F, will speed up execution, but should only be set to F if you are sure the dataset is already sorted in time-data description id-baseline order (the order in which mirfiller writes data when filling)';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.dosort.def := 'T';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.dosort.a := 'Boolean';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.reset := [=];
help::pkg.bima.bimams.objs.bimams.m.reavg.a.reset.d := 'should all average data be recomputed? By default (reset=T), all averages recomputed regardless of the value of the existing flags, otherwise (reset=F), only averages with F flags are recomputed (i.e. averages flagged bad are left untouched). Note that setting reset=F will not increase the speed of the function.';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.reset.def := 'T';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.reset.a := 'Boolean';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.verbosity := [=];
help::pkg.bima.bimams.objs.bimams.m.reavg.a.verbosity.d := 'Controls the level of informational messages, 0 = run quietly, higher numbers = more messages';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.verbosity.def := '1';
help::pkg.bima.bimams.objs.bimams.m.reavg.a.verbosity.a := 'Integer';
help::pkg.bima.bimams.objs.bimams.m.reavg.s := 'reavg(out, dosort, reset, verbosity)';
help::pkg.bima.bimams.objs.bimams.m.reffreqs := [=];
help::pkg.bima.bimams.objs.bimams.m.reffreqs.d := 'Get a list of spectral window reference frequencies';
help::pkg.bima.bimams.objs.bimams.m.reffreqs.s := 'reffreqs()';
help::pkg.bima.bimams.objs.bimams.m.sourcetable := [=];
help::pkg.bima.bimams.objs.bimams.m.sourcetable.d := 'Get the SOURCE subtable as a table tool';
help::pkg.bima.bimams.objs.bimams.m.sourcetable.s := 'sourcetable()';
help::pkg.bima.bimams.objs.bimams.m.spwid := [=];
help::pkg.bima.bimams.objs.bimams.m.spwid.d := 'Get a spectral window id';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.sb := [=];
help::pkg.bima.bimams.objs.bimams.m.spwid.a.sb.d := 'The sideband in which the desired window is located';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.sb.def := '';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.sb.a := 'String: \' l\'  (lsb) or \' u\'  (usb)';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.type := [=];
help::pkg.bima.bimams.objs.bimams.m.spwid.a.type.d := 'The type of window';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.type.def := '';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.type.a := 'String: \' s\'  (sideband average), \' c\'  (multi-channel data), or \' a\'  (multi-channel average)';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.mcn := [=];
help::pkg.bima.bimams.objs.bimams.m.spwid.a.mcn.d := 'The 1-based position of the desired window with respect to other windows of the same type in the same sideband. Usually NOT the same as the row number in the SPECTRAL\_WINDOWS table';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.mcn.def := '1';
help::pkg.bima.bimams.objs.bimams.m.spwid.a.mcn.a := 'Integer: $>=1$ and $<=$ the total number of windows of the specified type in the specified sideband. Not used if type=\' s\' ';
help::pkg.bima.bimams.objs.bimams.m.spwid.s := 'spwid(sb, type, mcn)';
help::pkg.bima.bimams.objs.bimams.m.spwidsbyname := [=];
help::pkg.bima.bimams.objs.bimams.m.spwidsbyname.d := 'Get a list of spectral window ids by specifying  a list of spectral window names';
help::pkg.bima.bimams.objs.bimams.m.spwidsbyname.a.names := [=];
help::pkg.bima.bimams.objs.bimams.m.spwidsbyname.a.names.d := 'The names of the spectral windows';
help::pkg.bima.bimams.objs.bimams.m.spwidsbyname.a.names.def := '';
help::pkg.bima.bimams.objs.bimams.m.spwidsbyname.a.names.a := 'Vector of strings';
help::pkg.bima.bimams.objs.bimams.m.spwidsbyname.s := 'spwidsbyname(names)';
help::pkg.bima.bimams.objs.bimams.m.spwids := [=];
help::pkg.bima.bimams.objs.bimams.m.spwids.d := 'Get a list of spectral window ids by specifying  a type of spectral window and, optionally, a sideband';
help::pkg.bima.bimams.objs.bimams.m.spwids.a.type := [=];
help::pkg.bima.bimams.objs.bimams.m.spwids.a.type.d := 'The spectral window type';
help::pkg.bima.bimams.objs.bimams.m.spwids.a.type.def := '';
help::pkg.bima.bimams.objs.bimams.m.spwids.a.type.a := 'String: \' A\'  (all types), \' a\'  (multi-channel average), \' c\'  (multi-channel data), or \' s\'  (sideband average)';
help::pkg.bima.bimams.objs.bimams.m.spwids.a.sb := [=];
help::pkg.bima.bimams.objs.bimams.m.spwids.a.sb.d := 'The sideband.  Not used if type=\' s\' ';
help::pkg.bima.bimams.objs.bimams.m.spwids.a.sb.def := '\' b\' ';
help::pkg.bima.bimams.objs.bimams.m.spwids.a.sb.a := 'String: \' b\'  (both), \' l\'  (lsb), \' u\'  (usb)';
help::pkg.bima.bimams.objs.bimams.m.spwids.s := 'spwids(type, sb)';
help::pkg.bima.bimams.objs.bimams.m.spwnames := [=];
help::pkg.bima.bimams.objs.bimams.m.spwnames.d := 'Get a list of spectral window names by specifying the type of spectral window';
help::pkg.bima.bimams.objs.bimams.m.spwnames.a.type := [=];
help::pkg.bima.bimams.objs.bimams.m.spwnames.a.type.d := 'The type of spectral window';
help::pkg.bima.bimams.objs.bimams.m.spwnames.a.type.def := '\' all\' ';
help::pkg.bima.bimams.objs.bimams.m.spwnames.a.type.a := 'String: \' all\'  (all  types), \' a\'  (multi-channel averages), \' c\'  (multi-channel data), \' s\'  (sideband averages)';
help::pkg.bima.bimams.objs.bimams.m.spwnames.s := 'spwnames(type)';
help::pkg.bima.bimams.objs.bimams.m.spwtable := [=];
help::pkg.bima.bimams.objs.bimams.m.spwtable.d := 'Get the SPECTRAL$\_$WINDOW subtable as a table tool';
help::pkg.bima.bimams.objs.bimams.m.spwtable.s := 'spwtable()';
help::pkg.bima.bimams.objs.bimams.m.startfreqs := [=];
help::pkg.bima.bimams.objs.bimams.m.startfreqs.d := 'Get the frequencies of the first channels  in the multi-channel data spectral windows.';
help::pkg.bima.bimams.objs.bimams.m.startfreqs.s := 'startfreqs()';
help::pkg.bima.bimams.objs.bimams.m.stokesid := [=];
help::pkg.bima.bimams.objs.bimams.m.stokesid.d := 'Get the system-defined id for the specified stokes parameter.';
help::pkg.bima.bimams.objs.bimams.m.stokesid.a.stokes := [=];
help::pkg.bima.bimams.objs.bimams.m.stokesid.a.stokes.d := 'The stokes parameter (e.g., \' YY\' , \' I\' , etc.)';
help::pkg.bima.bimams.objs.bimams.m.stokesid.a.stokes.def := '';
help::pkg.bima.bimams.objs.bimams.m.stokesid.a.stokes.a := 'String: a stokes parameter';
help::pkg.bima.bimams.objs.bimams.m.stokesid.s := 'stokesid(stokes)';
help::pkg.bima.bimams.objs.bimams.m.subtable := [=];
help::pkg.bima.bimams.objs.bimams.m.subtable.d := 'Get the specified subtable of the underlying measurement set';
help::pkg.bima.bimams.objs.bimams.m.subtable.a.tname := [=];
help::pkg.bima.bimams.objs.bimams.m.subtable.a.tname.d := 'name of the subtable';
help::pkg.bima.bimams.objs.bimams.m.subtable.a.tname.def := '';
help::pkg.bima.bimams.objs.bimams.m.subtable.a.tname.a := 'String';
help::pkg.bima.bimams.objs.bimams.m.subtable.a.readonly := [=];
help::pkg.bima.bimams.objs.bimams.m.subtable.a.readonly.d := 'open the table in read-only mode (no writing allowed)';
help::pkg.bima.bimams.objs.bimams.m.subtable.a.readonly.def := 'T';
help::pkg.bima.bimams.objs.bimams.m.subtable.a.readonly.a := 'Boolean';
help::pkg.bima.bimams.objs.bimams.m.subtable.s := 'subtable(tname, readonly)';
help::pkg.bima.bimams.objs.bimams.m.timerange := [=];
help::pkg.bima.bimams.objs.bimams.m.timerange.d := 'Get the maximum and minimum times in the MS';
help::pkg.bima.bimams.objs.bimams.m.timerange.s := 'timerange()';
help::pkg.bima.bimams.objs.bimams.m.totalintegrationtime := [=];
help::pkg.bima.bimams.objs.bimams.m.totalintegrationtime.d := 'Get the total integration time of this MS';
help::pkg.bima.bimams.objs.bimams.m.totalintegrationtime.a.gaptime := [=];
help::pkg.bima.bimams.objs.bimams.m.totalintegrationtime.a.gaptime.d := 'The minimum time between scans, if $<$0, 2 times the maximum value in the INTERVAL column is used';
help::pkg.bima.bimams.objs.bimams.m.totalintegrationtime.a.gaptime.def := '-1';
help::pkg.bima.bimams.objs.bimams.m.totalintegrationtime.a.gaptime.a := 'Double';
help::pkg.bima.bimams.objs.bimams.m.totalintegrationtime.s := 'totalintegrationtime(gaptime)';

help::pkg.bima.bimacalibrater := [=];
help::pkg.bima.bimacalibrater.objs := [=];
help::pkg.bima.bimacalibrater.funs := [=];
help::pkg.bima.bimacalibrater.d := 'Module for calibrating BIMA data';
help::pkg.bima.bimacalibrater.objs.bimacalibrater := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.d := 'Calibration of BIMA data';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.d := 'Construct a bimacalibrater tool from a set of MeasurementSets';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.targets := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.targets.d := 'Target source measurement set names';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.targets.def := '\'  \' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.targets.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.phcals := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.phcals.d := 'Phase calibrator measurement set names';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.phcals.def := '\'  \' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.phcals.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.pbcals := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.pbcals.d := 'Passband calibrator measurement set names';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.pbcals.def := '\'  \' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.pbcals.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.fcals := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.fcals.d := 'Flux density calibrator measurement set names';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.fcals.def := '\'  \' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.fcals.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.targetnames := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.targetnames.d := 'Target source nicknames';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.targetnames.def := 'unset (will set to targets)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.targetnames.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.phcalnames := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.phcalnames.d := 'Phase calibrator nicknames';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.phcalnames.def := 'unset (will set to phcals)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.phcalnames.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.fcalnames := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.fcalnames.d := 'Flux density calibrator nicknames';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.fcalnames.def := 'unset (will set to fcals)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.fcalnames.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.pbcalnames := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.pbcalnames.d := 'Passband calibrator nicknames';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.pbcalnames.def := 'unset (will set to pbcals)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.a.pbcalnames.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.c.bimacalibrater.s := 'bimacalibrater(targets, phcals, pbcals, fcals, targetnames, phcalnames, fcalnames, pbcalnames)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.getsourcenames := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.getsourcenames.d := 'get a list of source nicknames';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.getsourcenames.a.roles := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.getsourcenames.a.roles.d := 'Return nicknames of sources of these roles';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.getsourcenames.a.roles.def := 'none';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.getsourcenames.a.roles.a := 'Vector of strings.  Recognized values are \' all\'  (all nicknames), \' targets\'  (target source nicknames), \' phcals\'  (phase calibrators), \' pbcals\'  (passband calibrators), and \' fcals\'  (flux density calibrators)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.getsourcenames.s := 'getsourcenames(roles)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.d := 'Set the flux density of the specified sources';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.sources := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.sources.d := 'Nicknames of sources to which to set the flux densities';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.sources.def := '\' phcals\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.sources.a := 'Vector of strings (nicknames or roles of sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.fieldid := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.fieldid.d := 'Field Id (1-relative)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.fieldid.def := '-1 (all)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.fieldid.a := 'Int';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.spwid := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.spwid.d := 'Spectral Window Id. (1-relative)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.spwid.def := '-1 (all)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.spwid.a := 'Int';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.fluxdensity := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.fluxdensity.d := 'Specified flux density (I,Q,U,V) in Jy, if $<$ 0, attempt to look up flux density in BIMA calibrator flux density table';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.fluxdensity.def := '-1';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.a.fluxdensity.a := 'Vector of Doubles';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setjy.s := 'setjy(sources, fieldid, spwid, fluxdensity)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.d := 'Set the data parameters selection for subsequent processing';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.sources := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.sources.d := 'Nicknames of sources on which to run calibrater.setdata()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.sources.def := '\' phcals\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.sources.a := 'Vector of strings (nicknames or roles of sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mode := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mode.d := 'Type of processing: channel or velocity';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mode.def := '';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mode.a := '\' channel\' $|$\' velocity\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.nchan := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.nchan.d := 'Number of channels to select';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.nchan.def := '1';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.nchan.a := 'Int';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.start := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.start.d := 'Start channel (1-relative)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.start.def := '';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.start.a := 'Int';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.step := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.step.d := 'Step in channel number';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.step.def := '';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.step.a := 'Int';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mstart := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mstart.d := 'Start velocity (e.g. \' 20Km/s\' )';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mstart.def := '';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mstart.a := 'Quantity';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mstep := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mstep.d := 'Step in velocity (e.g. \' 100m/s\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mstep.def := '';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.mstep.a := 'Quantity';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.uvrange := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.uvrange.d := 'UV range (in klambda) (e.g. [0, 50])';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.uvrange.def := '0 (all data)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.uvrange.a := 'Vector of Doubles';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.sourcenames := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.sourcenames.d := 'List of sources to select (only useful for multisource datasets; see above';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.sourcenames.def := '\'  \' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.sourcenames.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.msselect := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.msselect.d := 'TAQL selection string';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.msselect.def := '';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.a.msselect.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setdata.s := 'setdata(sources, mode, nchan, start, step, mstart, mstep, uvrange, sourcenames, msselect)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.d := 'Set up what calibration component is to be solved for and how the solution should be determined.';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.sources := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.sources.d := 'Nicknames of sources on which to run calibrater.setsolve()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.sources.def := '\' phcals\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.sources.a := 'Vector of strings (nicknames or roles of sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.type := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.type.d := 'Component type';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.type.def := '\' \' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.type.a := '"G","T","B","D"';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.t := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.t.d := 'Solution interval (in sec)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.t.def := '0.0';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.t.a := 'Float';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.preavg := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.preavg.d := 'Pre-averaging interval (in sec)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.preavg.def := '0.0';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.preavg.a := 'Float';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.phaseonly := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.phaseonly.d := 'Phase only solution ?';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.phaseonly.def := 'False';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.phaseonly.a := 'Bool';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.refant := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.refant.d := 'Reference antenna';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.refant.def := '-1';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.refant.a := 'Int';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.table := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.table.d := 'Output calibration table';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.table.def := '\' \'  (see above for default naming scheme)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.table.a := 'Table name';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.append := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.append.d := 'Append flag (set to T if you have multiple calibraters and want solutions in a single table)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.append.def := 'False';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.a.append.a := 'Bool';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setsolve.s := 'setsolve(sources, type, t, preavg, phaseonly, refant, table, append)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.solve := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.solve.d := 'Solve for the selected calibration components';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.solve.a.sources := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.solve.a.sources.d := 'Nicknames of sources on which to run calibrater.solve()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.solve.a.sources.def := '\' phcals\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.solve.a.sources.a := 'Vector of strings (nicknames or roles of sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.solve.s := 'solve(sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.fit := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.fit.d := 'Interpolate gain solutions by fitting polynomials';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.fit.a.table := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.fit.a.table.d := 'The calibration table for which solutions are to be interpolated';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.fit.a.table.def := 'unset (uses the table specified in setsolve())';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.fit.a.table.a := 'Table name';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.fit.s := 'fit(table)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.d := 'Transfer calibration solutions from one table to another.';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.outtable := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.outtable.d := 'Name of the calibration table to which to write solutions';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.outtable.def := '\' \' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.outtable.a := 'Any valid table name';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.intable := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.intable.d := 'Name of the calibration table from which to transfer solutions';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.intable.def := '\' \'  (will use the table written by solve)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.intable.a := 'Any valid table name';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.spwmap := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.spwmap.d := 'Array describing the spectral window mapping from the input to the output (see above). The spectral windows are 1-based,  and a value of 0 means not to transfer solutions for the specified window (GAINS are filled in with 0\' s)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.spwmap.def := 'unset (transfer will do its best to guess how this should be done; see above)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.spwmap.a := 'Vector of Ints $>=$ 0';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.calibratees := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.calibratees.d := 'Nicknames or roles of sources to which the solutions will be applied (if more than one source is specified they all should have the same spectral window configuration)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.calibratees.def := '\' targets\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.calibratees.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.forcecopy := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.forcecopy.d := 'Force a copy of the input to output table when the input could be used to apply solutions';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.forcecopy.def := 'T';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.a.forcecopy.a := 'Boolean';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.transfer.s := 'transfer(outtable, intable, spwmap, calibratees, forcecopy)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.d := 'Set how solutions should be applied';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.sources := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.sources.d := 'Nicknames of sources on which to run calibrater.setapply()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.sources.def := '\' targets\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.sources.a := 'Vector of strings (nicknames or roles of sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.type := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.type.d := 'Component type';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.type.def := '\' G\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.type.a := '"G","T","B","D"';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.t := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.t.d := 'Interpolation interval (in sec)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.t.def := '0.0';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.t.a := 'Float';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.table := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.table.d := 'Input calibration table';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.table.def := 'unset (will use table written by transfer(), or if transfer() hasn\' t been run, the table written by solve()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.table.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.select := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.select.d := 'TAQL selection string';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.select.def := '" "';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.a.select.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.setapply.s := 'setapply(sources, type, t, table, select)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.correct := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.correct.d := 'Apply calibration';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.correct.a.sources := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.correct.a.sources.d := 'Nicknames of sources on which to run calibrater.correct()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.correct.a.sources.def := '\' targets\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.correct.a.sources.a := 'Vector of strings (nicknames or roles of sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.correct.s := 'correct(sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.type := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.type.d := 'Get the type of this tool, namely  bimacalibrater ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.type.s := 'type()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.d := 'Add target sources';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.a.mss := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.a.mss.d := 'Names of the target MSs';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.a.mss.def := 'None';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.a.mss.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.a.names := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.a.names.d := 'Nicknames for the target MSs';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.a.names.def := 'unset (will use the values supplied in the mss parameter';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.a.names.a := 'Vector of strings';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.addtargets.s := 'addtargets(mss, names)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.done := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.done.d := 'Done with this tool';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.done.s := 'done()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.close := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.close.d := 'Close the calibrater tools associated with the specified measurement sets.';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.close.a.sources := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.close.a.sources.d := 'Nicknames of sources on which to run calibrater.close()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.close.a.sources.def := 'none';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.close.a.sources.a := 'Vector of strings (nicknames or roles of sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.close.s := 'close(sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.d := 'Plot a calibration table(s)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.sources := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.sources.d := 'Nicknames of sources on which to run calibrater.plotcal()';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.sources.def := 'none';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.sources.a := 'Vector of strings (nicknames or roles of sources)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.plottype := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.plottype.d := 'Plot type';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.plottype.def := '\' AMP\' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.plottype.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.tablename := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.tablename.d := 'Calibration table name';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.tablename.def := '\' \' ';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.tablename.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.antennas := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.antennas.d := 'Antennas to plot';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.antennas.def := 'False';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.antennas.a := 'Vector of Ints';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.fields := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.fields.d := 'Fields to plot';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.fields.def := 'False';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.fields.a := 'Vector of Ints';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.polarization := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.polarization.d := 'Polarization to plot';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.polarization.def := '1';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.polarization.a := 'Integer';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.spwids := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.spwids.d := 'Spectral windows id.\' s to plot';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.spwids.def := 'False';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.spwids.a := 'Vector of Ints';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.timeslot := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.timeslot.d := 'Timeslot index for B Jones';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.timeslot.def := '1';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.timeslot.a := 'Integer';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.multiplot := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.multiplot.d := 'Turn on separate antenna plots';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.multiplot.def := 'F';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.multiplot.a := 'Bool';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.nx := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.nx.d := 'If multiplot=T, number of plots on horizontal axis';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.nx.def := '1';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.nx.a := 'Integer';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.ny := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.ny.d := 'If multiplot=T, number of plots on vertical axis';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.ny.def := '1';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.ny.a := 'Integer';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.psfile := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.psfile.d := 'name of output PostScript file to write plot to';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.psfile.def := 'empty string, causing plot to be sent to the screen';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.a.psfile.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.plotcal.s := 'plotcal(sources, plottype, tablename, antennas, fields, polarization, spwids, timeslot, multiplot, nx, ny, psfile)';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.summary := [=];
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.summary.d := 'Print a summary of this tool.';
help::pkg.bima.bimacalibrater.objs.bimacalibrater.m.summary.s := 'summary()';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.c := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.d := 'Tool to retrieve information from the BIMA calibrator tables';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.c.bimacalfluxtable := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.c.bimacalfluxtable.d := 'Construct a bimacalfluxtable tool';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.c.bimacalfluxtable.s := 'bimacalfluxtable()';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.contains := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.contains.d := 'does the table contain the specified calibrator?';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.contains.a.calname := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.contains.a.calname.d := 'The calibrator to determine the existance of';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.contains.a.calname.def := 'none';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.contains.a.calname.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.contains.s := 'contains(calname)';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxlist := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxlist.d := 'Get the flux history for the specified calibrator';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxlist.a.calname := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxlist.a.calname.d := 'Name of the calibrator for which to get the flux history';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxlist.a.calname.def := 'none';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxlist.a.calname.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxlist.s := 'fluxlist(calname)';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxtable := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxtable.d := 'Get the table containing the flux histories of calibrators';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.fluxtable.s := 'fluxtable()';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.d := 'Get the flux nearest in time to the specifed date of the specified calibrator.';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.a.calname := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.a.calname.d := 'The calibrator for which to retrieve information';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.a.calname.def := 'None';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.a.calname.a := 'String';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.a.date := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.a.date.d := 'The date to which to get the nearest-in-time record';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.a.date.def := 'None';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.a.date.a := 'Quantity';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.nearestflux.s := 'nearestflux(calname, date)';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.positiontable := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.positiontable.d := 'Get, as a table tool, the position table (J2000)';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.positiontable.s := 'positiontable()';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.type := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.type.d := 'Get the type of this tool, namely  bimacalfluxtable ';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.type.s := 'type()';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.done := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.done.d := 'Done with this tool';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.done.s := 'done()';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.close := [=];
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.close.d := 'Close the table tools associated with this tool';
help::pkg.bima.bimacalibrater.objs.bimacalfluxtable.m.close.s := 'close()';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest := [=];
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a := [=];
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.d := 'Test bimacalibrater';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.verbose := [=];
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.verbose.d := 'Controls the amount of logger output, 0=none, higher numbers=more';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.verbose.def := '1';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.verbose.a := 'Int >= 0';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.modelcaltable := [=];
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.modelcaltable.d := 'Use this table as the fiducial table for comparison with the generated calibration table';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.modelcaltable.def := '\' \'  (uses table in the data repository)';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.modelcaltable.a := 'Any valid table name';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.modeldatatable := [=];
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.modeldatatable.d := 'Use this table as the fiducial table for comparison with the generated MODEL$\_$DATA and CORRECTED$\_$DATA columns';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.modeldatatable.def := '\' \'  (uses table in the data repository)';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.a.modeldatatable.a := 'Any valid table name';
help::pkg.bima.bimacalibrater.funs.bimacalibratertest.s := 'bimacalibratertest(verbose, modelcaltable, modeldatatable)';

help::pkg.bima.bimatester := [=];
help::pkg.bima.bimatester.objs := [=];
help::pkg.bima.bimatester.funs := [=];
help::pkg.bima.bimatester.d := 'Module for testing filling, calibration, and imaging of BIMA data';
help::pkg.bima.bimatester.objs.bimatester := [=];
help::pkg.bima.bimatester.objs.bimatester.m := [=];
help::pkg.bima.bimatester.objs.bimatester.c := [=];
help::pkg.bima.bimatester.objs.bimatester.d := 'Testing of BIMA data';
help::pkg.bima.bimatester.objs.bimatester.c.bimatester := [=];
help::pkg.bima.bimatester.objs.bimatester.c.bimatester.d := 'Construct a bimatester tool';
help::pkg.bima.bimatester.objs.bimatester.c.bimatester.a.verbose := [=];
help::pkg.bima.bimatester.objs.bimatester.c.bimatester.a.verbose.d := 'Controls the level of output. 0 means run silently, higher values produce more messages';
help::pkg.bima.bimatester.objs.bimatester.c.bimatester.a.verbose.def := '1';
help::pkg.bima.bimatester.objs.bimatester.c.bimatester.a.verbose.a := 'Int';
help::pkg.bima.bimatester.objs.bimatester.c.bimatester.s := 'bimatester(verbose)';
help::pkg.bima.bimatester.objs.bimatester.m.runtests := [=];
help::pkg.bima.bimatester.objs.bimatester.m.runtests.d := 'Run various tests';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.fill := [=];
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.fill.d := 'Fill data and run filler tests?';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.fill.def := 'T';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.fill.a := 'Boolean';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.calibrate := [=];
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.calibrate.d := 'Calibrate data and run calibration tests?';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.calibrate.def := 'T';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.calibrate.a := 'Boolean';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.image := [=];
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.image.d := 'Image data and run imaging tests?';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.image.def := 'T';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.image.a := 'Boolean';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.image := [=];
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.image.d := 'Clean the image and run deconvolution tests?';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.image.def := 'T';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.a.image.a := 'Boolean';
help::pkg.bima.bimatester.objs.bimatester.m.runtests.s := 'runtests(fill, calibrate, image, image)';
help::pkg.bima.bimatester.objs.bimatester.m.summary := [=];
help::pkg.bima.bimatester.objs.bimatester.m.summary.d := 'Summarize the test results';
help::pkg.bima.bimatester.objs.bimatester.m.summary.a.verbose := [=];
help::pkg.bima.bimatester.objs.bimatester.m.summary.a.verbose.d := 'Print results to the log?';
help::pkg.bima.bimatester.objs.bimatester.m.summary.a.verbose.def := 'T';
help::pkg.bima.bimatester.objs.bimatester.m.summary.a.verbose.a := 'Boolean';
help::pkg.bima.bimatester.objs.bimatester.m.summary.s := 'summary(verbose)';
help::pkg.bima.bimatester.funs.bimatest := [=];
help::pkg.bima.bimatester.funs.bimatest.a := [=];
help::pkg.bima.bimatester.funs.bimatest.d := 'A quick way to run tests.';
help::pkg.bima.bimatester.funs.bimatest.a.verbose := [=];
help::pkg.bima.bimatester.funs.bimatest.a.verbose.d := 'Controls the level of output. 0 means run silently, higher values produce more messages';
help::pkg.bima.bimatester.funs.bimatest.a.verbose.def := '1';
help::pkg.bima.bimatester.funs.bimatest.a.verbose.a := 'Int';
help::pkg.bima.bimatester.funs.bimatest.a.summarize := [=];
help::pkg.bima.bimatester.funs.bimatest.a.summarize.d := 'Summarize the results?';
help::pkg.bima.bimatester.funs.bimatest.a.summarize.def := 'T';
help::pkg.bima.bimatester.funs.bimatest.a.summarize.a := 'Boolean';
help::pkg.bima.bimatester.funs.bimatest.a.fill := [=];
help::pkg.bima.bimatester.funs.bimatest.a.fill.d := 'Fill data and run filler tests?';
help::pkg.bima.bimatester.funs.bimatest.a.fill.def := 'T';
help::pkg.bima.bimatester.funs.bimatest.a.fill.a := 'Boolean';
help::pkg.bima.bimatester.funs.bimatest.a.calibrate := [=];
help::pkg.bima.bimatester.funs.bimatest.a.calibrate.d := 'Calibrate data and run calibration tests?';
help::pkg.bima.bimatester.funs.bimatest.a.calibrate.def := 'T';
help::pkg.bima.bimatester.funs.bimatest.a.calibrate.a := 'Boolean';
help::pkg.bima.bimatester.funs.bimatest.a.image := [=];
help::pkg.bima.bimatester.funs.bimatest.a.image.d := 'Image data and run imaging tests?';
help::pkg.bima.bimatester.funs.bimatest.a.image.def := 'T';
help::pkg.bima.bimatester.funs.bimatest.a.image.a := 'Boolean';
help::pkg.bima.bimatester.funs.bimatest.a.image := [=];
help::pkg.bima.bimatester.funs.bimatest.a.image.d := 'Clean the image and run deconvolution tests?';
help::pkg.bima.bimatester.funs.bimatest.a.image.def := 'T';
help::pkg.bima.bimatester.funs.bimatest.a.image.a := 'Boolean';
help::pkg.bima.bimatester.funs.bimatest.s := 'bimatest(verbose, summarize, fill, calibrate, image, image)';

