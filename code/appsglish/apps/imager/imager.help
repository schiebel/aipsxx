%% Copyright (C) 1999,2000,2001,2002,2003
%% Associated Universities, Inc. Washington DC, USA.
%%
%% This library is free software; you can redistribute it and/or modify it
%% under the terms of the GNU Library General Public License as published by
%% the Free Software Foundation; either version 2 of the License, or (at your
%% option) any later version.
%%
%% This library is distributed in the hope that it will be useful, but WITHOUT
%% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
%% License for more details.
%%
%% You should have received a copy of the GNU Library General Public License
%% along with this library; if not, write to the Free Software Foundation,
%% Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
%%
%% Correspondence concerning AIPS++ should be addressed as follows:
%%        Internet email: aips2-request@nrao.edu.
%%        Postal address: AIPS++ Project Office
%%                        National Radio Astronomy Observatory
%%                        520 Edgemont Road
%%                        Charlottesville, VA 22903-2475 USA
%%
%% $Id: imager.help,v 19.33 2006/09/01 16:20:24 kgolap Exp $
\documentclass{article}
\usepackage{aips2help, html, epsfig}
\begin{document}
\providecommand{\briggsURL}{http://www.aoc.nrao.edu/ftp/dissertations/dbriggs/diss.html}
\providecommand{\pixonURL}{http://www.pixon.com/}
\providecommand{\rsiURL}{http://www.rsinc.com/}

\begin{ahmodule}{imager}{Module for synthesis and single dish imaging}
\ahinclude{imager.g}

\begin{ahdescription} 

{\tt imager} provides a unified interface for synthesis and single
dish imaging including deconvolution starting from a MeasurementSet.

\subsubsection*{What {\tt imager} does:}

\begin{description}
\item[Standard synthesis and single dish imaging] {\tt imager} does
nearly all types of synthesis and single dish imaging, including dirty
images, point spread functions, deconvolution, combination of single
dish and synthesis, spectral imaging, polarimetry, wide-field imaging,
mosaicing, holography, near-field imaging, tracking moving objects,
{\em etc.}. As a result of this extensive range of capabilities, it
can be complicated to use, especially for the more esoteric forms of
imaging.
\item[Fine scaled tools] Rather than present one operation
to process data from visibilities to a restored, deconvolved
image, {\tt imager} contains a number of distinct, separate tool functions
that allow careful tuning of the processing. For example, the
weights used in imaging (the IMAGING\_WEIGHT column in the
MeasurementSet), can be altered via a number of tool functions
(\ahlink{weight}{imager:imager.weight}, \ahlink{filter}{imager:imager.filter}) 
and inspected via a plotting
tool function \ahlink{plotweights}{imager:imager.plotweights}. Similarly, the
deconvolution and restoration steps are separate, allowing user
control of each step. It is our intention that other imaging tools may
be built on top of imager: see, for example,
\ahlink{imagerwizard}{imager:imagerwizard}, which also has the side-benefit
that
it displays the imager (and other tools) commands as they are
executed.
\item[Spectral imaging] {\tt imager} can perform either spectral
imaging or frequency synthesis (producing either an image with 
each channel imaged independently or with some or 
all channels summed together).
Channels may be selected in a number of ways, either as channels
or as velocities. Also a continuum model image may be subtracted 
prior to making a cube.
\item[Many different deconvolution algorithms] {\tt imager} is rich in
deconvolution algorithms, including a number of clean variants,
maximum entropy, non-negative least squares, and the pixon algorithm.
\item[Mixing of deconvolution functions] Since the deconvolved images
are calculated and kept purely as images (rather than lists of clean
components), deconvolution functions may be mixed as desired. Thus,
one may use NNLS to deconvolve part of the Stokes I of an image, 
and then use CLEAN to deconvolve another part of all polarizations
in the image. Note that a list of clean components is not available.
\item[Ability to fix model images] In a multifield deconvolution,
it is possible to specify that some fields are not to be deconvolved,
using the {\tt fixed} argument of \ahlink{clean}{imager:imager.clean}.
\item[Single dish imaging] {\tt imager} can process single dish
observations much as it does synthesis images. To make images with no
deconvolution, use the \ahlink{makeimage}{imager:imager.makeimage}
function. This allows construction of traditional single dish images
and holography images. To deconvolve images, just use the
``multifield'' deconvolution algorithms in
\ahlink{clean}{imager:imager.clean} and 
\ahlink{mem}{imager:imager.mem}. You will want to set the gridmachine
in \ahlink{setoptions}{imager:imager.setoptions} to 'sd'.
\item[Combination of single dish and synthesis data] If the single
dish and interferometer data are in the same MeasurementSet, then
imager can perform a joint deconvolution using
``multifield'' deconvolution algorithms in
\ahlink{clean}{imager:imager.clean} and 
\ahlink{mem}{imager:imager.mem}. You will want to set the gridmachine
in \ahlink{setoptions}{imager:imager.setoptions} to 'both'. You can
change the relative weighting of synthesis and single dish data by
using \ahlink{setsdoptions}{imager:imager.setsdoptions}.
If the single dish and synthesis data cannot be combined into
one MeasurementSet then you can still use the
\ahlink{feather}{imager:imager.feather} function to combine already
deconvolved images.
\item[Multi-field processing] {\tt imager} can be run on any number
of images, each of which can have any direction for the phase
center. All coordinate transformations are done correctly.  Using the
measures system, these fields may be given moving positions (such as
the Sun using {\tt dm.direction('sun')} to specify the phase center) or
positions in strange coordinates (such as Supergalactic using
{\em e.g.} {\tt dm.direction('supergal', '0d', '0d')} as well as
the more conventional representations ({\em e.g.}
{\tt dm.direction('b1950', '12h26m33.248000', '02d19m43.290000')} specifies
the coordinates of the core of 3C273). Note that for
some coordinate systems a location must be supplied via
the \ahlink{setoptions}{imager:imager.setoptions} tool function. For example,
one can put an image at a specific azimuth and elevation ({\em e.g.}
{\tt dm.direction('azel', '67.4d', '5.23d')}) at the
VLA {\tt imgr.setoptions(location=dm.observatory('VLA'))}. Phase 
rotation will be automatically calculated to track in 
azimuth-elevation.
\item[Wide-field imaging] {\tt imager} can perform wide-field
imaging as needed to overcome the non-coplanar baselines
effect for the VLA and other non-coplanar arrays.
\item[Mosaicing] {\tt imager} can perform clean-based or mem-based mosaicing
of many pointings into one image, using variants of the multi-field
algorithms.
\item[Processing of component lists] Discrete components
(not the same as clean components!) can be represented by 
\ahlink{componentmodels}{componentmodels}. A componentlist
can hold any number of components. The components are subtracted from
the visibility data before construction of an image. For high
precision imaging, it is recommended that components be used for
bright sources since the Fourier Transform of components avoids the
limitations of the gridded transforms.
%\item[Self-calibration] Self-calibration is accomplished
%using the \ahlink{calibrater}{calibrater} tool. One sets up a calibrater tool
%with the necessary parameters and then passes it by name to
%the \ahlink{selfcal}{imager:imager.selfcal} tool function.
\item[Joint deconvolution of Stokes IQUV] {\tt imager} can produce
images of either $I$ alone, or $I,V$ or $I,Q,U,V$, deconvolving
jointly as appropriate. The point spread function is constrained to
be the same for all processed polarizations so asymmetric u,v coverage is
not allowed.
\item[Production of complex images] {\tt imager} can produce
dirty or residual images or point spread functions in the original 
data representation ({\em e.g.} RR,RL,RL,LL or XX,XY,YX,YY. 
\item[Fine control and evaluation of visibility weighting] Various
tool functions for controlling the visibility weights are available
(\ahlink{weight}{imager:imager.weight}, \ahlink{filter}{imager:imager.filter}) 
as well as tool functions for evaluating the effects of the weighting
(\ahlink{plotweights}{imager:imager.plotweights},
\ahlink{sensitivity}{imager:imager.sensitivity},
\ahlink{fitpsf}{imager:imager.fitpsf}).  The Briggs algorithm for 
weighting of visibility data can be used (see
\ahlink{weight}{imager:imager.weight} and \htmladdnormallink{Dan Briggs'
thesis} {\briggsURL}).
\item[Flexible windowing in the deconvolution] Rather than use boxes
to limit the region CLEANed, a mask image is used to constrain the
region in which flux is allowed. There are various tool functions for making
a mask image, including from regions and blc/trc specifications, and via
thresholding the Stokes I image. In the Clark Clean, the mask is
{\em soft}: it can vary between 0 and 1. Intermediate values of
the mask bias against but do not rule out subtraction of clean components.
\item[Non-Negative Least Squares Deconvolution] This algorithm
is very effective at producing high dynamic range images of moderately
resolved sources (see \htmladdnormallink{Dan Briggs' thesis}
{\briggsURL}). It works on Stokes $I$ alone so the recommended
procedure is to CLEAN $I,Q,U,V$ using \ahlink{clean}{imager:imager.clean}
and then use NNLS to refine the $I$ part of the image using
\ahlink{nnls}{imager:imager.nnls}.
\item[Specification of arguments as \ahlink{measures}{measures}] A measure 
is a measured quantity with optional units, coordinates and reference
frames. These are allowed in a number of circumstances.  The advantage
is that the user can specify arguments in very convenient form, and
let the measures system do whatever conversion is required. For
example:
\begin{description}
\item[Cell sizes] These can be specified as a quantity (see the 
\ahlink{measures}{measures} module).
\begin{verbatim}
imgr.setimage(cellx='7arcsec', celly='7arcsec')
\end{verbatim}
\item[Image center direction] This must be specified as a 
direction (see the \ahlink{measures}{measures} module).
\begin{verbatim}
imgr.setimage(phasecenter=dm.direction('j2000', '05h30m', '-30.2deg'))
imgr.setimage(phasecenter=dm.direction('gal', '0deg', '0deg'))
imgr.setimage(phasecenter=dm.direction('mars'))
imgr.setimage(phasecenter=image('myother.image').coordmeasures().direction);
\end{verbatim}
\item[Velocities] These can be specified as radial velocities.
\begin{verbatim}
imgr.setimage(start=dm.radialvelocity('25km/s'), 
            step=dm.radialvelocity('-500m/s'))
\end{verbatim}
\item[Position] For construction of images in some coordinate
frames ({\em e.g} azimuth-elevation) the position to be used
in processing must be set:
\begin{verbatim}
imgr.setoptions(location=dm.observatory('ATCA'))
\end{verbatim}
\end{description}
\item[More choice in image size] Any even image size will work,
though to speed the FFT, it is advisable to
use a highly composite number (one that has many factors).
The \ahlink{advise}{imager:imager.advise} function will
calculate an acceptable number.
\item[Integrated plotting] Plots of visibility 
amplitude, weights (both point-by-point and gridded),
uv coverage, and field and spectral window ids are available 
(\ahlink{plotvis}{imager:imager.plotvis}, 
\ahlink{plotweights}{imager:imager.plotweights}, 
\ahlink{plotuv}{imager:imager.plotuv}, 
\ahlink{plotsummary}{imager:imager.plotsummary}).
\item[Synchronous or Asynchronous processing] Operations that
take a substantial amount of time to run can be run in the
background either by setting the global variable {\tt dowait:=F}
or by setting an argument {\em e.g.} {\tt imgr.clean(async=T)}.
To retrieve a result, use the result tool function of
defaultservers with the job number as the argument. For example:
\begin{verbatim}
- imgr:=imager('ss433.MS')
T
- imgr.setimage(cellx='0.05arcsec', celly='50marcsec', nx=256, ny=256, 
  spwid=1:2, fieldid=1, stokes='IV') 
T 
- imgr.fitpsf()
1 
# Wait for it to finish and then ask for the result:
- defaultservers.result(1)
[psf=, bpa=[value=42.7269936, unit=deg], bmin=[value=0.13008301, 
unit=arcsec], bmaj=[value=0.159367442, unit=arcsec]] 
\end{verbatim}
\item[A novel sort-less gridding algorithm] The visibility data are
not sorted before the gridding step. Instead, a cache of tiles is
allocated to hold each baseline as it moves around in the Fourier
plane. When a baseline moves off an existing tile, the results are
written to disk and the necessary new tile is read in. Since the
rotation of baselines in the uv plane is usually quite slow, the hit
rate of such a cache is high. The size of the cache is by default
set to half the physical memory of the machine, as specified
by the aipsrc variable system.resources.memory. This can be overridden
by the user, via the \ahlink{setoptions}{imager:imager.setoptions}
tool function. The cache
can be made smaller at the expense of more paging of tiles in and
out. The tile size can also be changed but this is seldom needed.
This approach is optimal for arrays with small numbers of antennas
but can be slow for {\em e.g.} the VLA. We intend to rectify this
in the near future.
\item[Plug-in commands] {\tt imager} can be customized by attaching
commands using the \aipspp\ plug-in system. See the file
code/trial/apps/imager/imager\_standard.gp for an example of how to 
attach commands. 
\item[Suite of tests] {\tt imager} has a suite of tests. A standard 
test data set and component list can also be created.
\item[imagerwizard] The \ahlink{simplemage}{imager:imagerwizard}
function is a wizard that performs interactively guided imaging
of synthesis data.
\item[dragon] The \ahlink{dragon}{imager:dragon} tool performs 
wide-field imaging using imager.
\item[vpmanager] The \ahlink{vpmanager}{imager:vpmanager} tool manages
specification of primary beams for imager.
\item[Near-field imaging {\em experimental}] Images of objects in the near-field of an
array can be made. If the distance to the object is specified 
in \ahlink{setimage}{imager:imager.setimage}, then the extra delay
due to the wavefront curvature is corrected in the transforms.
Note that some telescopes ({\em e.g.} VLA) make this correction in the real-time
system. This effect is important if the distance to the object is comparable
to or less than:
\begin{equation}
{B^2\over\lambda}
\end{equation}
where B is the baseline. Note that the sign of the correction could be
in error in this experimental version: try using a negative distance
as well as a positive distance.
\end{description}

\subsubsection*{What {\tt imager} needs:}

{\tt imager} operates on a specified MeasurementSet to produce any of a
range of different types of image: dirty, point spread function,
clean, residual, {\em etc.}  A MeasurementSet is the holder for
measurements from a telescope. It is simply an \aipspp\ Table obeying
certain conventions as to required and optional contents. The
intention is that it should contain all the information needed to
reduce synthesis and single dish observations (see
\htmladdnormallink{\aipspp\ Note 191} {../../notes/191.ps}). A
UVFITS file can be converted to a MeasurementSet using the
\ahlink{fitstoms}{ms:ms.fitstoms.constructor} tool function (a constructor of the
\ahlink{ms}{ms} tool.

{\tt imager} adds some extra columns to the MeasurementSet to store
results of processing. The following columns in the MS are
particularly important:
\begin{description}
\item[DATA] The original observed visibilities are in a column
called DATA. These are not altered by any processing in \aipspp.
\item[CORRECTED\_DATA] During a calibration process, as carried out by
{\em e.g.} \ahlink{calibrater}{calibrater}, the visibilities may be corrected for
calibration effects. This corrected visibilities are stored in a column
CORRECTED\_DATA which is created on demand by calibrater and imager. In creating
the CORRECTED\_DATA column, {\tt imager} will only correct for parallactic
angle rotation. This can be controlled using the
\ahlink{correct}{correct} tool function. All imaging performed by
imager is from the CORRECTED\_DATA column (apart from the
tool function \ahlink{makeimage}{imager:imager.makeimage} which can also make dirty
images from the other visibility columns).
\item[MODEL\_DATA] During various phases of processing, the
visibilities as predicted from some model are required. These 
model visibilities are stored in a column MODEL\_DATA. 
These are used by the \ahlink{calibrater}{calibrater} tool for 
calibration.
\item[IMAGING\_WEIGHT] Weighting of data (including natural,
uniform and Briggs weighting,
and tapering) is accomplished by setting the column IMAGING\_WEIGHT
appropriately. 
\end{description}
Standard tools such as the \ahlink{table}{table}
module and the \ahlink{ms}{ms} can be used to access and possibly
change these (and all other) columns.

{\tt imager} can handle an initial model in a number of forms: as an
image, as a list of images, as a \ahlink{componentmodels:componentlist}
{componentmodels:componentlist}, or as some combination. Fitting of
{\tt componentmodels} is planned but is not currently supported.

{\tt imager} uses a number of scratch files. Following \aipspp\
practice, these are placed in the directories specified in the
aipsrc variable user.directories.work.
Those disks that possess sufficient free disk space are
chosen in sequence. So to spread your scratch files over
two disks each of which has a directory tcornwel/tmp do {\em
e.g.}

\begin{verbatim}
user.directories.work:   /bigdisk1/tcornwel/tmp /bigdisk2/tcornwel/tmp
\end{verbatim}

\subsubsection*{How to control imager:}

To use {\tt imager}, one has to construct a {\tt imager} tool using
a MeasurementSet as an argument, for example:

\begin{verbatim}
myimager:=imager('3C273XC1.ms')
\end{verbatim}

The Glish variable {\tt myimager} then contains the tool functions
that may be used to do various operations on the MeasurementSet
3C273XC1.ms. These tool functions can be broken down into those that
set {\tt imager} up in some state, and those that actually do some
processing. The setup tool functions are: 

\begin{description}
\item[setimage] is a {\em required} tool function that defines
the parameters (size, sampling, phase center, {\em etc.}) of
any image that is to be constructed. If you omit to call
setimage prior to any operation that needs these parameters,
an error message will result. setimage is passive: nothing 
happens immediately but subsequent processing is altered.
\item[setdata] is an {\em optional} tool function that selects which data
are to be operated on during the processing. This selection can
consist of choosing the spectral windows or fields that are
to be operated on, or setting channels that are to be operated
on in subsequent processing. setdata is active: the selection
occurs immediately and is effective for all subsequent operations
(until setdata is called again).
\item[setoptions] is an {\em optional} tool function that sets parameters
of lesser importance such as gridding parameters, cache sizes. While
these affect the processing, usually the default values will
suffice. setoptions is passive: nothing happens immediately but
subsequent processing is altered.
\item[setbeam] is an {\em optional} tool function that sets the
parameters of the synthesized beam to be used in restoring deconvolved
images. setbeam is passive: nothing happens immediately but
subsequent processing is altered.
\item[setvp] is an {\em optional} tool function that sets the
parameters of the voltage pattern model used in mosaicing.
setvp is passive: nothing happens immediately but
subsequent processing is altered.
\item[setsdoptions] is an {\em optional} tool function that sets the
relative scaling and weighting of single dish data versus 
interferometer data and also other single dish specific parameters like the convolution support when doing single dish imaging.
\end{description}

Thus to understand what imager is doing, one has to remember that at
any time, it has a {\em state} that has been set by using these
tool functions. The state may be viewed in one of two ways: either 
\ahlink{summary}{imager:imager.summary} can be used to output the
current state to the logger, or, in the GUI, the current
state of these parameters is displayed and updated following any
relevant changes. 

All the other tool functions of {\tt imager} are active: something happens
immediately. Hence, for example, the \ahlink{weight}{imager:imager.weight}
tool function acts immediately to change the weighting of the selected
data. In particular, unlike other packages, it does {\em not} set the
weighting parameters for latter operations. The
\ahlink{clean}{imager:imager.clean} tool function performs a clean deconvolution of
an image, reading and writing a model image. Note that operations that
require or produce an image usually take an appropriate image name in
the argument list.  Often if such an image is not given then it is
constructed using the image parameters set via
\ahlink{setimage}{imager:imager.setimage} and using an appropriate name
({\em e.g.} a restored image is named from the model image by
appending .restored so that 3C273XC1.clean becomes
3C273XC1.clean.restored).

The concept of the {\em state} of imager bears a little more
explanation.  The MeasurementSet can potentially contain data for many
different fields and spectral windows. One therefore has to have some
way of distinguishing which data are to be included in
processing. Rather than have each possible tool function ({\em e.g.}
weight, image, clean) take a long list of parameters to determine
which data are to be included, {\tt imager} has a
\ahlink{setdata}{imager:imager.setdata} tool function that sets {\tt
imager} up some that in subsequent processing only the selected data
are processed. For example, to select only field id 1 and spectral
windows 1 and 2, one would do:

\begin{verbatim}
myimager.setdata(fieldid=1, spwid=1:2)
\end{verbatim}

The state of {\tt imager} also consists of information about the
default image settings (set via \ahlink{setimage}{imager:imager.setimage})
and various less important options (set via 
\ahlink{setoptions}{imager:imager.setoptions}).

\subsubsection*{What {\tt imager} produces:}

{\tt imager} reads and writes \aipspp\ MeasurementSets and Images.  The
format of images is 4 dimensional, with the first two being right
ascension and declination, the third being polarization and the fourth
being frequency. By suitable choice of the input parameters, one can
make images of $I$ alone, $I,V$ or $I,Q,U,V$ for one or all channels.
The \ahlink{makeimage}{imager:imager.makeimage} tool function can also make a complex image
of the original polarizations {\em e.g.} RR, RL, LR, LL. This latter
type of image is useful for diagnostic purposes.

Images generated by {\tt imager} may be viewed using
\ahlink{viewer}{viewer:viewer} tool or retrieved using the
\ahlink{images}{images} tool, the MeasurementSets may be accessed
using the \ahlink{ms}{ms} tool. More on this in the example below.

\subsubsection*{What {\tt imager} does not do:}

{\tt imager} does not handle calibration of visibility data beyond correction
for parallactic angle variations.  Instead, you should use the
\ahlink{calibrater}{calibrater} tool for this purpose.  However, {\tt imager} and calibrater can
cooperate on the self-calibration of data. 
%using the tool function
%\ahlink{imager.selfcal}{imager:imager.selfcal}.

\subsubsection*{What improvement to {\tt imager} are in the works:}

We are currently working on a number of improvements:

\begin{itemize}
\item Improved gridder to handle many telescopes and many channels
more efficiently.
\item Parallelized CLEAN and gridding
\end{itemize}

\subsubsection*{Advanced use of imager:}

As with all \aipspp\ applications, {\tt imager} is designed to be open: all
the results are written to and read from standard \aipspp\ table files.
This open design of {\tt imager} also allows the user to try out new
methods of processing data.  Models may be read into Glish, edited or
manipulated via standard Glish facilities, and then written out and
used subsequently in {\tt imager}.  Suppose that we want to halve the
Stokes I of all pixels with negative Stokes I. The following Glish
fragment does the trick:
\begin{verbatim}
m:=image('myimage')
shape:=im.shape()
blc:=[1,1,1,1]
trc:=[shape[1],shape[2],1,shape[4]]
a:=m.getchunk(blc,trc)
a[a<0.]*:=0.5
m.putchunk(a,blc)
m.flush()
m.close()
\end{verbatim}

\subsubsection*{Overview of {\tt imager} tool functions:}

\begin{description}
\item[Data access] \ahlink{open}{imager:imager.open},
\ahlink{close}{imager:imager.close}, \ahlink{done}{imager:imager.done}
\item[Data selection] \ahlink{setdata}{imager:imager.setdata}
\item[Data editing] \ahlink{clipvis}{imager:imager.clipvis}
\item[Data calibration] \ahlink{correct}{imager:imager.correct}
\item[Data examination] \ahlink{plotvis}{imager:imager.plotvis}, \ahlink{plotuv}{imager:imager.plotuv}, 
\ahlink{plotweights}{imager:imager.plotweights}, \ahlink{plotsummary}{imager:imager.plotsummary}
\item[Weighting] \ahlink{weight}{imager:imager.weight}, \ahlink{filter}{imager:imager.filter}, 
\ahlink{uvrange}{imager:imager.uvrange}, \ahlink{sensitivity}{imager:imager.sensitivity}, 
\ahlink{fitpsf}{imager:imager.fitpsf}, \ahlink{plotweights}{imager:imager.plotweights}
\item[Image definition] \ahlink{advise}{imager:imager.advise}, \ahlink{setimage}{imager:imager.setimage}, \ahlink{make}{imager:imager.make}
\item[Imaging] \ahlink{makeimage}{imager:imager.makeimage},
\ahlink{clean}{imager:imager.clean},
\ahlink{nnls}{imager:imager.nnls}, \ahlink{mem}{imager:imager.mem}, 
\ahlink{pixon}{imager:imager.pixon}, 
\ahlink{restore}{imager:imager.restore},
\ahlink{residual}{imager:imager.residual}, 
\ahlink{approximatepsf}{imager:imager.approximatepsf}, 
\ahlink{fitpsf}{imager:imager.fitpsf}, 
\ahlink{setbeam}{imager:imager.setbeam}, 
\ahlink{ft}{imager:imager.ft}, 
\ahlink{smooth}{imager:imager.smooth}
\ahlink{feather}{imager:imager.feather}
\ahlink{makemodelfromsd}{imager:imager.makemodelfromsd}
\item[Masks] \ahlink{mask}{imager:imager.mask},
\ahlink{boxmask}{imager:imager.boxmask},
\ahlink{regionmask}{imager:imager.regionmask},
\ahlink{exprmask}{imager:imager.exprmask},
\ahlink{clipimage}{imager:imager.clipimage}
\item[Miscellaneous] \ahlink{summary}{imager:imager.summary}, 
\ahlink{setoptions}{imager:imager.setoptions}
\ahlink{setoptions}{imager:imager.setmfcontrol}
\ahlink{setoptions}{imager:imager.setsdoptions}
\end{description}

\end{ahdescription}


\begin{ahexample}
The following example shows the quickest way to make a CLEAN image and
display it. Note that this can be more easily done from the
\ahlink{toolmanager}{tasking:toolmanager}.
\begin{verbatim}
include 'imager.g'
#
# First make the MS from a FITS file:
#
m:=fitstoms(msfile='3C273XC1.MS', fitsfile='3C273XC1.FITS'); m.close();
#
# Now make an imager tool for the MS
#
imgr:=imager('3C273XC1.MS')      
#
# Set the imager to produce images of cellsize 0.7 and
# 256 by 256 pixels
#
imgr.setimage(nx=256,ny=256, cellx='0.7arcsec',celly='0.7arcsec');
#
# Wait for results before proceeding to the next step
#
dowait:=T
#
# Make and display a clean image
#
imgr.clean(niter=1000, threshold='30mJy',
model='3C273XC1.clean.model', image='3C273XC1.clean.image')
dd.image('3C273XC1.clean.image')
#
# Fourier transform the model 
#
imgr.ft(model='3C273XC1.clean.model')
#
# Plot the visibilities
#
imgr.plotvis()
#
# Write out the final MS and close the imager tool
#
imgr.close()
\end{verbatim}
\end{ahexample}

\ahobjs{}
\ahfuncs{}

\begin{ahobject}{imager}{tool for synthesis imaging}
\begin{ahdescription}
imager is an tool that accomplishes synthesis processing.
A {\tt imager} must be constructed for each MeasurementSet for which one
wishes to do processing. Multiple copies of {\tt imager} may
be made at any time (provide they are given different names).
\end{ahdescription}

\ahfuncs{}

\begin{ahconstructor}{imager}{Construct an imager tool}
\begin{ahdescription}
This is used to construct {\tt imager} tools associated
with a MeasurementSet. The {\tt imager} tool may then be
used to generate various types of images. Note that
a new executable is started every time the constructor
is called. 

This returns a Glish variable containing the tool functions of
imager.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{filename}{MeasurementSet to be imaged}{''}{Table name}
\ahaddarg{compress}{Compress calibration columns?}{F}{Bool}
\ahaddarg{host}{Host on which to run imager}{''}{String: '' means localhost}
\ahaddarg{forcenewserver}{Flag to force a new imager client}{T}{Bool}
\end{ahargs}
\ahreturns{imager tool}
\begin{ahexample}
\begin{verbatim}
imgr:=imager('3C273XC1.MS')      
imgr.setimage(nx=256, ny=256, cellx='0.7arcsec', celly='0.7arcsec')
imgr.image(type='corrected', image='3C273XC1.dirty')
imgr.close()
\end{verbatim}
\end{ahexample}
\end{ahconstructor}

\begin{ahfunction}{advise}{Advise (and optionally use) parameter values}

\begin{ahdescription}
Advise on recommended values of certain parameters. Return these
values and optionally use them in Imager.

The calculations are performed as following:

\begin{description}
\item[cell] The maximum uv distance in wavelength is found and then half of the
inverse is taken as the maximum cellsize allowed.
\item[pixels] The field of view is converted to a number of pixels
using the calculated cell size.
\item[facets] The number of facets on an axis is calculated in two
different ways. The first method simply requires that the peeling of 
facets away from the celestial sphere should not cause an amplitude
drop of more than the argument {\tt amplitudeloss}. The positions may
be incorrect, but all the sources will be removed correctly. The
second method requires that the source positions be accurate to the
same fraction of the beam specified by {\tt amplitudeloss}. The 
second calculates the second moment in w and in uv distance and
chooses the number of facets correspondingly. The first method does
the same but after fitting a plane to the sampling: $w = a u + b v$.
For an approximately coplanar array, the positions may be wrong but
the removal of sidelobes will be accurate. The number of facets
returned is the second, usually smaller, number. The formula used
is:
\begin{equation}
N_{facets} = N_{pixels} \sqrt{{{\Delta \theta}\over{\sqrt{8 \delta A}}}{w_{rms}}\over{uv_{rms}}}
\end{equation}
where $\Delta \theta$ is the cellsize in radians, and $\delta A$ is
the amplitude loss. This formula can be derived from (a) the peeling
of facets from the celestial sphere, and (b) a quadratic approximation 
for the beam size both in the plane of the sky and along the $w$ axis.
\end{description}


\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{takeadvice}{Use the advised values?}{T}{Bool}
\ahaddarg[in]{amplitudeloss}{Maximum fractional amplitude loss due to faceting}{0.05}{Float}
\ahaddarg[in]{fieldofview}{Desired field of view}{'1deg'}{Quantity}
\ahaddarg[out]{pixels}{Number of pixels on a side}{}{Int}
\ahaddarg[out]{cell}{Recommended maximum cellsize}{}{Quantity}
\ahaddarg[out]{facets}{Recommended number of facets on one axis}{}{Integer}
\ahaddarg[out]{phasecenter}{Direction of phase center as a measure}{}{MDirection}
\end{ahargs}
\end{ahfunction}

\begin{ahfunction}{approximatepsf}{Calculate approximate point spread functions}
\begin{ahdescription}
Calculate the approximate point spread function.
{\em Note that the model visibilities are updated}.

Some types of imaging do not yield a well-defined point spread
function. For example, mosaicing or single dish imaging both yield
point spread functions that are position dependent. Nevertheless, one
can still usefully define an {\em approximate} PSF that is of some
utility. This is calculated by doing the following calculation: a
point source is located at the center of the specified coordinate
system and the model data predicted. The approximate PSF is then formed from
those model data using the full sky equation. For regular sampling in
the image plane, this approximate PSF is actually quite good. It can
be used in a deconvolution. For a mosaic with similar uv sampling per
pointing, the approximate PSF is roughly the PSF per pointing
multiplied by the primary beam. For a single dish image, it is roughly
the telescope primary beam convolved with itself (if the
gridfunction='pb' was selected).
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{model}{Names of input models}{}{Vector of Strings}
\ahaddarg[in]{psf}{Names of output point spread functions}{}{Vector of Strings}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.approximatepsf(model='3C273XC1.clean', psf='3C273XC1.clean.psf')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{boxmask}{Construct a mask image from blc, trc}
\begin{ahdescription}
A mask image is an image with the same shape as the other images but
with values between 0.0 and 1.0 as a pixel value. Mask images are used in
imager to control the region selected in a deconvolution. 

In the Clark CLEAN, the mask image can usefully have any value between
0.0 and 1.0. Intermediate value discourage but do not rule out
selection of clean components in that region. This is accomplished by
multiplying the residual image by the mask prior to entering the minor
cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
it must cover only a quarter of the image. boxmask does not enforce
this requirement.

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{mask}{name of mask image}{}{String}
\ahaddarg[in]{blc}{Bottom left corner}{[1,1,1,1]}{Vector}
\ahaddarg[in]{trc}{Top right corner}{image shape}{Vector}
\ahaddarg[in]{value}{Value to fill in}{1.0}{Float}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.boxmask(mask='bigmask', blc=[56,45,1,1], trc=[87,93,4,1])
imgr.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Makes the image bigmask, and then sets it to unity for all points in
the region bounded by the blc and trc.  Then cleans using it as the
mask.
\end{ahcomments}
\end{ahfunction}

\begin{ahfunction}{clean}{Calculate a deconvolved image with selected clean algorithm}
\begin{ahdescription}
Makes a clean image using either the Hogbom, Clark, multi-scale or multi-field
algorithms. The Clark algorithm is the default. The clean is performed
on the residual image calculated from the visibility data currently
selected. Hence the first step performed in clean is to transform the
current model or models (optionally including a componentlist) to fill
in the MODEL\_DATA column, and then inverse transform the residual
visibilities to get a residual image. This residual image is then
cleaned using the corresponding point spread function. This means that
the initial model is used as the starting point for the
deconvolution. Thus if you want to restart a clean, simply set the
model to the model that was previously produced by clean.

Rather than explicit CLEAN boxes, mask images are used to constrain
the region that is to be deconvolved. To make mask images,
use either \ahlink{boxmask}{imager:imager.boxmask} (to define a mask
via the corner locations blc and trc) or 
\ahlink{mask}{imager:imager.mask} (to define a mask via
thresholding an existing image) or \ahlink{regionmask}{imager:imager.regionmask} (to make masks via regions using the regionmanager or interactively through the viewer)  . The default mask is the inner quarter
of the image.

The CLEAN deconvolution is joint in whatever Stokes parameters are
present. Thus it searchs for peaks in either $I$ or $I+|V|$ or
$I+\sqrt{Q^2+U^2+V^2}$, the rationale for the latter two forms being
to be biased towards finding strongly polarized pixels first (these
forms are also the maximum eigenvalue of the coherency matrix).  The
PSF is constrained to be the same in all polarizations (a feature of
this implementation, not of the Hamaker-Bregman-Sault formalism).

The clean algorithms possible are:
\begin{description}
\item[Hogbom] The classic algorithm: points are found iteratively
by searching for the peak. Each point is subtracted from the
full residual image using the shifted and scaled point spread
function.
\item[Multiscale] An experimental multi-scale clean algorithm is invoked.
The algorithm is fully described in 
\ahlink{deconvolver}{deconvolver:deconvolver.clean}.
\item[Clark] The faster algorithm: the cleaning is split into
minor and major cycles. In the minor cycles only the brightest
points are cleaned, using a subset of the point spread function.
In the major cycle, the points thus found are subtracted correctly
by using an FFT-based convolution.
\item[Multi-field] Cleaning is split into minor and major
cycles. For each field, a Clark-style minor cycle is performed. 
In the major cycle, the points thus found are subtracted
either from the original visibilities (for multiple fields)
or using a convolution (for only one field). The latter is
much faster.  Multi-field imaging has been implemented for
Clark, Hogbom, and Multi-scale deconvolution algorithms.
\item[Cotton-Schwab] Cleaning is split into minor and major
cycles. For each field, a Clark-style minor cycle is performed. 
In the major cycle, the points thus found are subtracted
from the original visibilities. A fast variant does a convolution
using a FFT. This will be faster for large numbers of
visibilities. Double the image size from that used for Cotton-Schwab
and set a mask to clean only the inner quarter.
\item[Wide-field] The user will need to use a wide-field algorithm to
deconvolve if the array is not coplanar over the field of view being
imaged . The technique used is to break the field being imaged into
smaller pieces (facets), over each of which the array appear
planar. We implement a rectangular facetting scheme. If the number of
facets specified in \ahlink{setimage}{imager:imager.setimage} is
greater than one, Either wfhogbom or wfclark algorithm has to be
selected here to perform a wide-field decovolution. The function
\ahlink{advise}{imager:imager.advise} can be used to calculate or
check if you need to use a wide-field deconvolution. Note that
aliasing can be reduced by using the {\tt padding} argument in
\ahlink{setoptions}{imager:imager.setoptions}. In practice the
previous sentence means that if you notice the clean to diverge at the
edges of the facets then you need to use a larger amount of padding
for the FT; the default being 1.2. Wide-field imaging has been
implemented for Clark and Hogbom algorithms.
\end{description}

The multi-field clean should be used if either of two conditions
hold:
\begin{enumerate}
\item Multiple fields are to be cleaned simultaneously {\bf OR}
\item Primary beam correction is enabled. In this case, a
mosaiced clean is performed.
\end{enumerate}

Note that for the single pointing algorithms, only a quarter of the
image may be cleaned. If no mask is set, then the cleaned region
defaults to the inner quarter. If a mask larger than a quarter of the
image is set, then only the inner quarter part of that mask is used.
However, for the wide-field and multi-field imaging (including the
Cotton-Schwab algorithm), the entire field may be imaged because the
major cycles either do an exact subtraction from the visibilities or
because PSF extent is more than twice the extent of the primary beam
support.

Before {\tt clean} can be run, you must run {\tt setdata} and {\tt setimage}.
Before {\tt clean} can be run with a multi-field algorithm, you should run
{\tt setvp}.  You may want to run {\tt setmfcontrol} before running {\tt clean}
with a multi-field or wide-field algorithm, though the default control values
may be acceptable.  Before {\tt clean} can be run with a multi-scale algorithm,
{\tt setscales} must be run.

Interactive cleaning/masking: If the user wants to see what the clean
image looks like after npercycle iteration and mask or modify the mask
each time, he/she should set interactive=T and give npercycle to a
fraction of niter. A viewer with the last residual image along with an
overlayed mask appear after every npercycle iteration. The user can
add or delete regions (by clicking on the appropriate button) to the
mask using the region button and drawing regions and double clicking
inside the region. Use 'refresh mask' to review the recent changes in
the mask. When satisfied and ready to continue cleaning press 'DONE
with masking' (if the user want to terminate the cleaning process use
the 'STOP' button). The button 'No more mask changes' should be used
if the user want clean to proceed without any further interruption.
PLEASE be patient and wait for the viewer to load both the image and
mask before clicking on the buttons or drawing regions. If impatient
please use interactive=F. Even if interactive=F, and if the parameter
'mask' is non-empty, it is still used in limiting the search area for
clean components.
If the parameter 'masktemplate' is not empty this means that the user
want to use a prior image to make the mask  the first time (e.g
a previously cleaned image) 



\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{algorithm}{Algorithm to use}{'clark'}{String:'clark'|'hogbom'|'multiscale'|'mfclark'|'csclean'|'csfast'|
'mfhogbom'|'mfmultiscale'|'wfclark'|'wfhogbom'}
\ahaddarg[in]{niter}{Number of Iterations, set to zero for no CLEANing}{1000}{Int}
\ahaddarg[in]{gain}{Loop Gain for CLEANing}{0.1}{Float}
\ahaddarg[in]{threshold}{Flux level at which to stop CLEANing}{'0Jy'}{Quantity}
\ahaddarg[in]{displayprogress}{Display the progress of the cleaning?}{F}{Bool}
\ahaddarg[in]{model}{Names of clean model images}{None}{Vector of strings}
\ahaddarg[in]{fixed}{Keep one or more models fixed}{F}{Vector of booleans}
\ahaddarg[in]{complist}{Name of component list}{}{String}
\ahaddarg[in]{mask}{Names of mask images used for CLEANing}{}{Vector of strings}
\ahaddarg[in]{image}{Names of restored images}{model name concatenated
  with '.restored'}{Vector of strings or unset}
\ahaddarg[in]{residual}{Names of residual images}{model name concatenated
  with '.residual'}{Vector of strings or unset}
\ahaddarg[in]{interactive}{whether to stop clean and interactively mask}{F}{Boolean}
\ahaddarg[in]{npercycle}{If interactive is 'T', then no of iter of clean 
before stopping, usually a fraction of niter}{100}{Int}
\ahaddarg[in]{masktemplate}{If non empty then will use this image to make
the mask the first time}{''}{String}
\ahaddarg[in]{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.clean(model='3C273XC1.clean.model',
mask='3C283XC1.mask', niter=1000, gain=0.25, threshold='0.03Jy')
\end{verbatim}

A few points should be noted in this example:

\begin{itemize}
\item When the mask parameter is specified, the number of mask images
      listed should be equal to the number of model images.  They
      should also have the same coordinate system as their
      corresponding model images.  
\item If one or more model images are listed in the model parameter
      but the image and residual parameters are empty, the restored
      and residual images are automatically named as the model names
      appended with '.restored' and '.residual', respectively.
\item No restored or residual image is made if the respective image 
      string is explicitly unset.
\end{itemize}

\begin{verbatim}
include 'imager.g';
msfile := 'vlac125K.ms';
imgr:=imager(msfile);
npix := 500; cell:='5arcsec';
#
# CS on 500 by 500
#
imgr.setimage(nx=npix, ny=npix, cellx=cell, celly=cell, stokes='I',
	      spwid=[1,2]);i
imgr.setoptions(padding=1.0);
imgr.setdata(spwid=[1,2]);
imgr.clean('cs', model='vlac125K.cs', image='vlac125K.cs.restored',
	   niter=1000, gain=0.1);
#
# CSF on 1000 by 1000, cleaning inner quarter
#
include 'regionmanager.g';
imgr.setimage(nx=2*npix, ny=2*npix, cellx=cell, celly=cell, stokes='I',
	      spwid=[1,2]);
imgr.regionmask('vlac125K.mask', region=drm.quarter());
imgr.clean('csf', model='vlac125K.csf', image='vlac125K.csf.restored',
	   mask='vlac125K.mask', niter=1000, gain=0.1);

#
# CS on 1000 by 1000, cleaning entire image
#
include 'regionmanager.g';
imgr.setimage(nx=2*npix, ny=2*npix, cellx=cell, celly=cell, stokes='I',
	      spwid=[1,2]);
imgr.clean('cs', model='vlac125K.csl', image='vlac125K.csl.restored',
	   mask='vlac125K.mask', niter=1000, gain=0.1);

imgr.done();
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{clipimage}{Zero all pixels where Stokes I is below
a threshold}
\begin{ahdescription}
All pixels in the image with Stokes I less than some threshold
are set to zero. This is useful prior to self-calibration where one 
oftens wishes to remove negative pixels from the model. Note that
if the image has polarization information, then the polarized
part of a pixel is also set to zero if Stokes I is less than the
threshold.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{image}{name of image}{}{String}
\ahaddarg[in]{threshold}{Threshold}{'0Jy'}{Quantity}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.clipimage(image='clean', threshold='50mJy')
%imgr.selfcal(cal='mycal', model='clean');
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{clipvis}{Flag visibilities where residual exceeds
a threshold}
\begin{ahdescription}
All visibilities where the residual exceeds some threshold
are flagged. This provides a simple way of flagging bad
data.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{threshold}{Threshold}{'0Jy'}{Quantity}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.plotvis('residual')
# determine threshold then apply it
imgr.clipvis(threshold='50mJy')
%imgr.selfcal(cal='mycal', model='clean');
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{close}{Close the imager tool, with data written on disk, keeping imager process running for future use}
\begin{ahdescription}
This is used to close {\tt imager} tools. Note that the
data is written to disk. The {\tt imager} process keeps running
until a \ahlink{done}{imager:imager.done} tool function call is performed.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr:=imager('3C273XC1.MS')      
imgr.image(image='3C273XC1.dirty',type='corrected')
imgr.close()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{correct}{Correct the MeasurementSet for correctable effects}
\begin{ahdescription}
By default, {\tt imager} makes images from the CORRECTED\_DATA column.
This tool function copies the data from the DATA column
to the CORRECTED\_DATA column. The main correction that sometimes
must be made is for parallactic angle rotation. 

Note that correct is automatically invoked whenever MeasurementSet
without a CORRECTED\_DATA columns is loaded (usually the first time
it is processed in {\tt imager}).
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{doparallactic}{Do the correction for parallactic angle?}{T}{Bool}
\ahaddarg[in]{timestep}{Time step for corrections}{'10s'}{Quantity}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
m:=fitstoms('3C273XC1.ms', '3C273XC1.fits'); m.close()
imgr:=imager('3C273XC1.ms')
imgr.correct(T, '1s')
imgr.clean(model='3C273XC1.clean.model')
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
\end{ahcomments}
\end{ahfunction}


\begin{ahfunction}{done}{Terminate the imager process}
\begin{ahdescription}
This is used to totally stop the {\tt imager} process. It is a good idea
to conserve memory use on your machine by stopping the process once
you no longer need it.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr:=imager('3C273XC1.MS')      
imgr.image(image='3C273XC1.dirty',type='corrected')
imgr.close()
imgr.done()
\end{verbatim}
\end{ahexample}
\end{ahfunction}
\begin{ahfunction}{exprmask}{Construct a mask image from a LEL expression}
\begin{ahdescription}
A mask image is an image with the same shape as the other images but
with values between 0.0 and 1.0 as a pixel value. Mask images are used in
imager to control the region selected in a deconvolution. 

In the Clark CLEAN, the mask image can usefully have any value between
0.0 and 1.0. Intermediate value discourage but do not rule out
selection of clean components in that region. This is accomplished by
multiplying the residual image by the mask prior to entering the minor
cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
it must cover only a quarter of the image. boxmask does not enforce
this requirement.

This function allows Lattice Express Language (LEL) expressions to
be used in defining a mask. See the documentation on 
\ahlink{imagecalc}{images:image.imagecalc.constructor} for more details.
\end{ahdescription}
\begin{ahargs}
\ahaddarg{mask}{name of mask image}{}{String}
\ahaddarg{expr}{Value to set the mask to}{1.0}{Any scalar or LEL expression}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.exprmask(mask='bigmask', expr='"3C273XC1.clean">0.5')
imgr.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Makes the image bigmask, and then sets it to unity for all points in
the region where 3C273XC1.clean is greater than 0.5Jy.
Then cleans using it as the mask.
\end{ahcomments}
\end{ahfunction}


\begin{ahfunction}{feather}{Feather together an interferometer and a single dish image
in the Fourier plane} 

\begin{ahdescription} 
Basically the "imerg" algorithm of AIPS and SDE, or the "feather"
algorithm of MIRIAD, we regrid the total power (or low resolution)
image onto the interferometer (or high resolution) image, Fourier
transform both the interferometer and single dish images, down weight
the Fourier transform of the interferometer image by 1.0 - FT(low res psf),
add the weighted interferometer Fourier plane to the single dish Fourier
plane, and transform back into the image plane.

The tapering is by the transform of a point spread function. If lowpsf
is specified, that image is used, otherwise the appropriate telescope
beam is used. The point spread function for a single dish image may be
calculated using \ahlink{makeimage}{imager:imager.makeimage}. 

{\tt Advice:} Note that if you are feathering large images, you'd be advised to have
the number of pixels along the X and Y axes to be composite numbers
and  definitely not  prime numbers. In general FFTs work much faster on even
and composite numbers. You may use \ahlink{subimage function of image
  tool}{image:image.subimage} to trim the number of pixels to something desirable.


\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{image}{Name of output feathered image}{'feathered.image'}{Image}
\ahaddarg[in]{highres}{Name of high resolution (interferometer) image}{}{Image}
\ahaddarg[in]{lowres}{Name of low resolution (single dish) image}{}{Image}
\ahaddarg[in]{lowpsf}{Name of optional low resolution point spread function}{}{Image}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}


####Please note that if you have both the images from somewhere else
####then one can just create imager without an ms
imgr:=imager(); 

###else one would use the imager that one used to deconvolve the
###interferometer data say
######
imgr.setvp(dovp=T, usedefaultvp=T)
imgr.feather(image='feathered.image', highres='casa.vlaonly',
lowres='casa.sd');
\end{verbatim}
In the above example its using the default beams and the observatory
information is in the image header.

But if you have a single dish image with a beam which is not defined
in the aips++ database then the example below is a guide of how to do
that, say you know the beam of the single dish as a gaussian.

\begin{verbatim}

#create a beam pattern table using vpmanager
include 'vpmanager.g'
vpman:=vpmanager();
vpman.setpbgauss(telescope='OTHER', othertelescope='BONN',
halfwidth='1arcmin', maxrad='20arcmin', reffreq='1.4GHz');
vpman.saveastable('bonn.pb')
vpman.done()

##....would have done  your usual imager setup (setimage etc) then before feathering
imgr.setvp(dovp=T, usedefaultvp=F, vptable='bonn.pb')
imgr.feather(image='feathered.image', highres='casa.vlaonly',
lowres='casa.sd');

###




\end{verbatim}

\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{filter}{Apply additional weighting by filtering (u-v taper)}
\begin{ahdescription}
Apply visibility tapering to emphasize certain scale structures.  The
imaging tapers are applied to a Table column called IMAGING\_WEIGHT,
which may be plotted using 
\ahlink{plotweights}{imager:imager.plotweights}. In addition, this column
may be accessed directly using either the \ahlink{table}{table}
or \ahlink{ms}{ms} modules. Note that the taper is multiplicative and
so the weights must be calculated first using
\ahlink{weight}{imager:imager.weight}. The points are not flagged!

Note that the scale size to be emphasized is given in the image plane
as the parameters of the corresponding Gaussian. Note also use of this
function provides an optimum detection for the given scale size, which
is not the same as requiring that the resulting dirty beam have the
specified Gaussian fit. The resultant fitted beam size will {\em very
roughly} be the quadratic sum of the original beam and the specified
beam. If you wish to obtain a specified beam, then the best approach
is to perform this calculation and check the value obtained using
\ahlink{imager.fitpsf}{imager:imager.fitpsf}.

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{type}{Type of filtering or u-v tapering}{gaussian}{String}
\ahaddarg[in]{bmaj}{Major axis of filter}{'0rad'}{Quantity}
\ahaddarg[in]{bmin}{Minor axis of filter}{'0rad'}{Quantiy}
\ahaddarg[in]{bpa}{Position angle of filter}{'0deg'}{Quantity}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.weight('uniform')
imgr.filter(type='gaussian', bmaj='2.3arcsec', bmin='1.67arcsec',
bpa='-34.5deg')
\end{verbatim}
\end{ahexample}
\end{ahfunction}
\begin{ahfunction}{fitpsf}{Fit the point spread function, making psf image first if needed}
\begin{ahdescription}
This fits an elliptical Gaussian to the point spread function
and returns the fitted beam parameters. If psf image is not specified
then a psf is made and used. The values for the beam fit
are saved internally and used whenever needed (for example in the functions \ahlink{restore}{imager:imager.restore} or \ahlink{smooth}{imager:imager.smooth}) until invalidated. The values
are invalidated by setdata, setimage or any tool function that changes
the weights. Use the function \ahlink{summary}{imager:imager.summary} to check if there is a valid fitted psf stored internally.
 
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{psf}{Name of input psf}{}{String}
\ahaddarg[out]{bmaj}{Major axis of beam}{}{Quantity record}
\ahaddarg[out]{bmin}{Minor axis of beam}{}{Quantity record}
\ahaddarg[out]{bpa}{Position angle of beam}{}{Quantity record}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.makeimage(type='psf', image='3C273XC1.psf')
- majaxis:=[=]; minaxis:=[=]; pangle:=[=]
- imgr.fitpsf('3C273XC1.psf', bmaj=majaxis, bmin=minaxis, bpa=pangle, async=F)
- print bmaj, bmin, bpa
- imgr.restore(model='bla' , complist='', image='bla.restored' , residual='bla2.residual' )
\end{verbatim}

Or if one wants to generate a psf from the uv coverage and use that subsequently as in the  following example:

\begin{verbatim}
- imgr.fitpsf(psf='')
- imgr.restore(model='bla' , complist='', image='bla.restored' , residual='bla2.residual' )
\end{verbatim}

\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{ft}{Fourier transform the specified model and componentlist}
\begin{ahdescription}
Fourier transform the specified model (and optionally componentlist) 
and insert into the MODEL\_DATA column. The current contents of
the MODEL\_DATA column are replaced unless incremental is set to
T (in which case the results are added to the column).
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{model}{Name of image}{}{Vector of strings}
\ahaddarg[in]{complist}{Name of component list}{}{String}
\ahaddarg[in]{incremental}{Add to the existing MODEL\_DATA column?}{F}{Bool}
\ahaddarg[in]{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.ft(model='3C273XC1.nnls.model')
imgr.ft(model='3C273XC1.another.model', incremental=T)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Fourier transforms the model in the image 3C273XC1.nnls.model
and then adds the visibility due to 3C273XC1.another.model
\end{ahcomments}
\end{ahfunction}

\begin{ahfunction}{linearmosaic}{Make a linear mosaic of several images}

\begin{ahdescription} 
Make a linear mosaic of several images.
Currently, the pointing center is not specified in the image, so
we specify the pointing center in terms of the row numbers of the FIELD subtable.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{images}{Input images to be mosaiced}{}{Vector of strings}
\ahaddarg[in]{mosaic}{Output mosaic image}{}{Image}
\ahaddarg[in]{fluxscale}{Fluxscale image}{}{Image}
\ahaddarg[in]{sensitivity}{Sensitivity image}{}{Image}
\ahaddarg[in]{fieldids}{output component list after PB has been applied [optional]}{}{Vector of Ints}
\ahaddarg{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.linearmosaic(images=['orion.1.cln', 'orion.2.cln', 'orion.4.cln'], mosaic='orion.linmos',
fluxscale='orion.linmos.fluxscale', fieldid=[1,2,4]);
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{make}{Make an empty (i.e. blank) image}
\begin{ahdescription}
Make an empty image using the current image parameters. Often this is
unnecessary, but you will typically need to use this if you wish to
deconvolve a set of images. The steps are to make the empty images
that you require to be deconvolved, and then pass them into clean as a
vector of strings.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{image}{name of output image}{}{String}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.setimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
nchan=1, stokes='IV', phasecenter=dm.direction('mars'));
imgr.make('mars.moving');
imgr.setimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
nchan=1, stokes='IV', 
phasecenter=dm.direction('j2000', '12:23:48.7', '-15:56:32.9')
imgr.make('mars.fixed');
imgr.clean(algorithm='mf', model=['mars.moving', 'mars.fixed'],
image=['mars.moving.restored', 'mars.fixed.restored'])
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
This makes two empty images, one moving with mars and one fixed
in j2000, and then deconvolves the two jointly using clean.
Finally the images are restored.
\end{ahcomments}
\end{ahfunction}

\begin{ahfunction}{makeimage}{Calculate images by gridding, etc.}
\begin{ahdescription}
This tool function actually does gridding (and Fourier inversion if
needed) of visibility data to make an image. It allows calculation of
various types of image:
\begin{description}
\item[observed] Make the dirty image from the DATA column ({\em default})
\item[model] Make the dirty image from the MODEL\_DATA column
\item[corrected] Make the dirty image from the CORRECTED\_DATA column
\item[residual] Make the dirty image from the difference of the
CORRECTED\_DATA and MODEL\_DATA columns
\item[psf] Make the point spread function
\item[singledish] Make a single dish image
\item[coverage] Make a single dish coverage image
\item[holography] Make a complex holography image
\item[pb] Make the primary beam as defined by \ahlink{setvp}{imager:imager.setvp}
\end{description}

Note the full {\tt imager} equation is not used and so, for example, the
primary beam correction is not performed. Use
\ahlink{restore}{imager:imager.restore} to get a residual image
using the full {\tt imager} equation where primary beam correction is
performed.

A position shift can be applied when specifying the image parameters
with \ahlink{setimage}{imager:imager.setimage}. If a shift is specified then
the uvw coordinates are reprojected prior to gridding, and a phase
rotation is applied. If the image is a PSF then no phase shift is
applied but the uvw are recomputed. To see the effects of the uvw
reprojected, you can use the
\ahlink{plotuv}{imager:imager.plotuv} function.

If desired, the full complex image (before conversion to stokes
I,Q,U,V) may be retained. Note that the \ahlink{image}{images:image}
tool cannot load a complex image directly. Instead, use the
\ahlink{imagecalc}{images:image.imagecalc.constructor} constructor 
to take {\em e.g.}  the real and imaginary parts of the image.

For making single dish and holography images, the data are convolved onto the
grid using a one of a number of options:
\begin{description}
\item[gridfunction='SF'] Circularly symmetric prolate spheroidal wavefunction. 
This is always the same function in pixels.  To get this to match to
the antenna primary beam, the optimum cellsize to use in constructing
the image is the antenna primary beam half-width-half-maximum times
1.20192.
\item[gridfunction='BOX'] Nearest neighbor gridding.
\item[gridfunction='PB'] The telescope primary beam is used as the
convolution function. This function is the same in arcseconds,
independent of the cellsize. This choice is optimum in the least
squares sense. To override the default choice of telescope primary beam
for a given telescope, use the function
\ahlink{setvp}{synthesis:imager.imager.setvp}. Usually the default will be acceptable.
\end{description}

To make a reasonable approximation to the sky, one should divide
the type='singledish' image by the type='coverage' image, thresholding
at some level. For example:

\begin{verbatim}
include 'image.g';
imcov  := image('scanweight'); imcov.view();
s:=0; imcov.statistics(s);	
threshold := s.max / 10.0;
#
im:=imagecalc('sdimage',
	      pixels=spaste('scanimage[scanweight>', threshold,
			    ']/scanweight[scanweight>', threshold, ']'))
im.view(raster=T, axislabels=T);
\end{verbatim}

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{type}{Type of output image}{'observed'}{String}
\ahaddarg[in]{image}{Name of output image}{}{String}
\ahaddarg[in]{compleximage}{Name of output complex image}{}{String}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.ft(model='3C273XC1.model', complist='3C273XC1.complist');
imgr.makeimage(type='residual', image='3C273XC1.residual')
imgr.makeimage(type='psf', image='3C273XC1.psf')
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Fill in the MODEL\_DATA column from Fourier transforming the model and
the componentlist.  Make the residual image and write it to
3C273XC1.residual. 
\end{ahcomments}
\begin{ahexample}
\begin{verbatim}
imgr.setvp(dovp=T, usedefaultvp=T, telescope='GBT');
imgr.makeimage(type='pb', image='gbt.pb')

\end{verbatim}
\end{ahexample}
\begin{ahcomments}
In the above we may want to see what the primary beam we are using
look like. May also be useful to deconvolve single dish images in the
deconvolver tool.

\end{ahcomments}

\end{ahfunction}
%%%

\begin{ahfunction}{makemodelfromsd}{Make stating model image from a
    Single Dish image}
\begin{ahdescription}
This functions use an image from a single dish and make a model
(clean component) image out of it. This allows one to use this as the
starting model in a deconvoltion  function e.g
\ahlink{clean}{imager:imager.clean} or \ahlink{mem}{imager:imager.mem}
This provides an alternative to
\ahlink{feather}{imager:imager.feather}.
The difference between the two is that in {\tt feather} the
interferometer image is deconvolved first and the single dish image is 
put in at the end. Whereas if one starts with a model from the single
dish image it will give a different starting point for the deconvolving
algorithm to interpolate the missing short baseline. 

The function \ahlink{setsdoptions}{imager:imager.setsdoptions} to set
a factor by which to scale the SD image, if necessary.

The {\tt sdpsf} parameter (optional) should be used if an external PSF image of the 
single dish is needed to calculate the beam parameters of the primary
beam of the dish. This is usually needed if the dish image is from a
non standard telescope or the beam is not in the {\tt aips++} system.
This parameter should point to an image, if you have a vptable made from vpmanager then \ahlink{setvp}{imager:imager.setvp} should be used to define this beam. 

The {\tt mask} is a mask image that may be needed to be used for
clean.  This is usually the case when the dish image does not fully
cover the field defined by \ahlink{setimage}{imager:imager.setimage}.


\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{sdimage}{Single Dish image}{''}{String}
\ahaddarg[in]{modelimage}{Name of output image to be used as model}{''}{String}
\ahaddarg[in]{sdpsf}{PSF of Single Dish if needed}{''}{String}
\ahaddarg[in]{maskimage}{mask image}{''}{String}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}

myim:=imager('orion\_only.ms')
myim.setdata(fieldid=[1:10], spwid=[1:2])
myim.setimage(nx=1000, ny=1000, cellx='1arcsec', celly='1arcsec', fieldid=5, spwid=[1,2])
myim.setvp(dovp=T)
myim.setoptions(ftmachine='mosaic')
myim.setscales(nscales=3)
myim.setsdoptions(scale=0.9);
myim.makemodelfromsd(sdimage='orion\_gbt.im', modelimage='orion\_model', maskimage='orion.mask')
myim.clean(algorithm='mfmultiscale', model='orion\_model',
residual='orion.residual', image='orion.restored', gain=0.2, niter=500, mask='orion.mask')
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
In the above example we are making a mosaic with the fields 1 to 10. A
single dish image {\tt orion\_gbt.im} is used scaled down by a factor 0.9 to
make the initial model that is passed to multi-scale clean.


\end{ahcomments}
\end{ahfunction}




%%
\begin{ahfunction}{mask}{Construct a mask image by thresholding an image}
\begin{ahdescription}
A mask image is an image with the same shape as the other images but
with values between 0.0 and 1.0 as a pixel value. Mask images are used
in {\tt imager} to control the region selected in a deconvolution.
One makes a mask image by clipping the I part of the restored image
(this function) or via the \ahlink{boxmask}{imager:imager.boxmask},
\ahlink{regionmask}{imager:imager.regionmask}, and 
\ahlink{exprmask}{imager:imager.exprmask} functions.  In this
function, all points greater than the threshold are set to unity. The
mask is the same in I,Q,U, and V. Note that
\ahlink{exprmask}{imager:imager.exprmask} is the most powerful
method for making mask images.

In the Clark CLEAN, the mask image can usefully have any value between
0.0 and 1.0. Intermediate value discourage but do not rule out
selection of clean components in that region. This is accomplished by
multiplying the residual image by the mask prior to entering the minor
cycle.

Note that if you do use a mask for the Clark or Hogbom Clean, it must
cover only a quarter of the image. It is particularly important to
check this when creating an image using a threshold. If it extends
further, the easiest fix is to use
\ahlink{getchunk}{images:image.getchunk} and
\ahlink{getchunk}{images:image.getchunk} to set parts of it to zero.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{image}{name of template image}{}{String}
\ahaddarg[in]{mask}{name of mask image}{}{String}
\ahaddarg[in]{threshold}{threshold for mask}{'0.0Jy'}{Quantity}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.mask( image='bigimage', mask='bigmask',threshold='0.07Jy')
imgr.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Makes the image bigmask, and then sets it to unity
for all points where the Stokes I in bigimage is
greater than 0.07. Then clean using it as the mask.
\end{ahcomments}
\end{ahfunction}


\begin{ahfunction}{mem}{Calculate a deconvolved image with selected mem (maximum entropy) algorithm}
\begin{ahdescription}
Makes a mem image using either the Cornwell-Evans maximum entropy or
maximum emptiness algorithms, using the single field or multi-field
contexts. The maximum entropy algorithm is the default. The mem is performed
on the residual image calculated from the visibility data currently
selected. Hence the first step performed in mem is to transform the
current model or models (optionally including a componentlist) to fill
in the MODEL\_DATA column, and then inverse transform the residual
visibilities to get a residual image. This residual image is then
deconvolved using the corresponding point spread function. This means that
the initial model is used as the starting point for the
deconvolution. Thus if you want to restart a mem, simply set the
model to the model that was previously produced by clean.

Mask images are used to constrain the region that is to be
deconvolved. To make mask images, use either
\ahlink{boxmask}{imager:imager.boxmask} (to define a mask via the
corner locations blc and trc) or \ahlink{mask}{imager:imager.mask} (to
define a mask via thresholding an existing image). The default mask is
the inner quarter of the image.

The MEM deconvolution only operates on one Stokes parameter at a time.
Joint MEM deconvolution for multiple Stokes parameters will be
implemented in the future. 

Some reference regarding MEM :
Cornwell and Evans,
Astronomy and Astrophysics (ISSN 0004-6361), vol. 143, no. 1, Feb. 1985,
                    p. 77-83.

Narayan and  Nityananda,
Annual review of astronomy and astrophysics. Volume 24 (A87-26730
10-90). Palo Alto, CA, Annual Reviews, Inc., 1986, p. 127-170.

The mem algorithms possible are:
\begin{description}
\item[Cornwell-Evans Maximum Entropy (entropy)] The classic "vm" or "vtess" 
deconvolution algorithm.
\item[Cornwell-Evans Maximum Emptiness (emptiness)] The historic, but 
largely undocumented, modification to the Cornwell-Evans algorithm
which seeks a model image which is consistent with the data and
simultaneously minimizes the number of pixels with no emission
(meaning "with pixel values below the noise level").
\item[Multi-field Maximum Entropy (mfentropy)] Deconvolution is split
into minor and major cycles. For each field, the MEM analog of a Clark
Clean minor cycle is performed. In the major cycle, the emission thus
modelled is subtracted either from the original visibilities (for
multiple fields) or using a convolution (for only one field). The
latter is much faster.
\item[Multi-field Maximum Emptiness (mfemptiness)] Just like {\tt mfentropy},
but with emptiness.
\end{description}

The multi-field mem ({\tt mfentropy} or {\tt mfemptiness}) should be
used if either of two conditions hold:
\begin{enumerate}
\item Multiple fields are to be deconvolved simultaneously {\bf OR}
\item Primary beam correction is enabled. In this case, a
mosaiced mem is performed.
\end{enumerate}

Note that for the single pointing algorithms, only a quarter of the
image may be deconvolved. If no mask is set, then the deconvolved
region defaults to the inner quarter. If a mask larger than a quarter
of the image is set, then only the quarter starting at the bottom left
corner is used.  However, for the multi-field imaging, the entire
field may be imaged because the major cycles either do an exact
subtraction from the visibilities or because PSF extent is more than
twice the extent of the primary beam support.

Before {\tt mem} can be run, you must run {\tt setdata} and {\tt setimage}.
Before {\tt mem} can be run with a multi-field algorithm, you should run
{\tt setvp}.  You may want to run {\tt setmfcontrol} before running {\tt mem}
with a multi-field algorithm, though the default control values
may be acceptable. 

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{algorithm}{Algorithm to use}{'entropy'}{String:'entropy'|'emptiness'|'mfentropy'|'mfemptiness'}
\ahaddarg[in]{niter}{Number of Iterations}{20}{Int}
\ahaddarg[in]{sigma}{Image sigma to try to achieve}{'0.001Jy'}{Quantity}
\ahaddarg[in]{targetflux}{Target flux for final image}{'1.0Jy'}{Quantity}
\ahaddarg[in]{constrainflux}{Constrain image to match target flux? else targetflux used only to initialize model}{F}{Bool}
\ahaddarg[in]{displayprogress}{Display the progress of the cleaning?}{F}{Bool}
\ahaddarg[in]{model}{Names of model images}{}{Vector of strings}
\ahaddarg[in]{fixed}{Keep model fixed}{F}{Vector of booleans}
\ahaddarg[in]{complist}{Name of component list}{}{String}
\ahaddarg[in]{prior}{Names of mem prior images}{}{Vector of strings}
\ahaddarg[in]{mask}{Names of mask images (0=>no emission, 1=>emission permitted}{}{Vector of strings}
\ahaddarg[in]{image}{Names of restored images}{}{Vector of strings}
\ahaddarg[in]{residual}{Names of residual images}{}{Vector of strings}
\ahaddarg[in]{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.mem(model='3C273XC1.mem.model',
mask='3C283XC1.mask', niter=40, sigma='0.001Jy')
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{nnls}{Calculate a deconvolved image using the 
NNLS algorithm} 

\begin{ahdescription} 

Solve for the model brightness using the Briggs' Non-Negative Least
Squares algorithm. Since NNLS works only on the $I$ image, the $I$
pixels in the current image is set to zero where the fluxmask is $>
0.0$, then NNLS is used to estimate the $I$-pixels for that region.
The deconvolution is performed on the residual image calculated from
the visibility data currently selected. Hence the first step performed
in clean is to transform the current model to fill in the MODEL\_DATA
column, and then inverse transform the residual visibilities to get a
residual image. This residual image is then deconvolved using the
corresponding point spread function.

Some other points to remember are that rather than explicit boxes,
mask images are used to constrain the region that is to be
deconvolved.  For NNLS, there are two masks, the fluxmask specifying
the region within which flux is allowed, and the datamask specifying
the region of the dirty image to be used as constraints. Typically the
datamask will be somewhat larger than the fluxmask. On a large
machine, a practical limit to both will be about 5000-6000
pixels. Hence NNLS is only useful for compact tools.  (For more
details, see the \htmladdnormallink{Briggs thesis}{\briggsURL}).  To
make mask images, use either \ahlink{boxmask}{imager:imager.boxmask} (to
define a mask via the corner locations blc and trc) or
\ahlink{mask}{imager:imager.mask} (to define a mask via
thresholding an existing image).

On the canonical \aipspp\ machine with 64MBytes of physical memory,
you should try to keep the product of the pixels in the fluxmask
and the datamask below about 5-10 million. Otherwise the 
solution phase will swap badly.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{model}{Name of image}{}{Vector of strings}
\ahaddarg[in]{fixed}{Keep model fixed}{F}{Vector of booleans}
\ahaddarg[in]{complist}{Name of component list}{}{String}
\ahaddarg[in]{niter}{Number of Iterations, set to zero for no NNLS}{0}{Int}
\ahaddarg[in]{tolerance}{Tolerance for solution}{1e-06}{Double}
\ahaddarg[in]{fluxmask}{Name of mask for allowed flux}{}{Vector of strings}
\ahaddarg[in]{datamask}{Name of mask for constraint pixels in dirty image}{}{Vector of strings}
\ahaddarg[in]{image}{Names of restored images}{}{Vector of strings}
\ahaddarg[in]{residual}{Names of restored images}{}{Vector of strings}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.nnls(image='3C273XC1.nnls.image', model='3C273XC1.nnls.model',
fluxmask='3C283XC1.fluxmask', datamask='3C273XC1.datamask', niter=1000,
tolerance=0.00001)
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{open}{Open a new MeasurementSet, for processing, closing current MeasurementSet}
\begin{ahdescription}
Close the current MeasurementSet and open a new MeasurementSet
instead. The current state of {\tt imager} is retained, except for
the data selection.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{thems}{New MeasurementSet to be processed}{'MS'}{Table name}
\ahaddarg[in]{compress}{Compress calibration columns?}{F}{Bool}
\end{ahargs}
\ahreturns{Bool}
\end{ahconstructor}


\begin{ahfunction}{pb}{Applies or corrects for a primary beam}

\begin{ahdescription} 

Multiply ({\tt operation='apply'}) or divide ({\tt operation='correct'})
by the primary beam function.  The primary beam can be applied to images and/or 
Componentlists.  

If {\tt pointingcenter==F} then you must specify {\tt inimage}
and the pointing center is taken from its reference direction.
Otherwise, {\tt pointingcenter} must be a Direction measure.
It cannot take on the value T.

The applied primary beam function is deterimed as follows.  If you used
function \ahlink{Imager.setvp}{imager:imager.setvp} to set an external
voltage pattern table, then this is where the applied primary beam will
come from (regardless of whether you set {\tt inimage} or not).  If you
did not run this function, then you must supply argument {\tt inimage}. 
The telescope name embedded in its Coordinate System will be used to
determine the primary beam function. 

\end{ahdescription}

\begin{ahargs}
\ahaddarg[in]{inimage}{Input image to apply beam to}{None}{String}
\ahaddarg[in]{outimage}{Output image after beam is applied}{No output image}{String}
\ahaddarg[in]{incomps}{Input Componentlist table name}{None}{String}
\ahaddarg[in]{outcomps}{Output Componentlist table name}{No output Componentlist}{String}
\ahaddarg[in]{operation}{Operation}{'apply'}{String from 'apply' or 'correct'}
\ahaddarg[in]{pointingcenter}{Pointing center for primary beam application}{F in CLI or the N. pole in the GUI}{F or Direction measure}
\ahaddarg[in]{parangle}{Parallactic angle for calculation}{'0deg'}{Quantity}
\ahaddarg[in]{pborvp}{Primary Beam or Voltage Pattern }{'pb'}{String from 'pb' or 'vp'}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}


\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
# make a flat image
imgr.make('flat.image');
img := image('flat.image');
arr := img.getchunk();
arr[1:shape(arr)[1], 1:shape(arr)[2]] := 1.0;
img.putchunk(arr);
img.done()
arr := F;
#
# as we are using "pointingcenter=F", it defaults to the image center
imgr.pb(inimage='flat.image', outimage='pb.image', pointingcenter=F)
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{pixon}{Calculate a deconvolved image with the pixon
algorithm ({\em experimental})}
\begin{ahdescription}

Makes a image using the Pixon algorithm. According to its developers,
the pixon method is:

\begin{quote}
a new way of viewing the problem of modeling the underlying, unblurred,
noise-free image. The goal of the [new] Pixon method model was to
construct the simplest, i.e. smoothest, model for the image that would
be consistent with the data, i.e. have an acceptable chi-square
fit. Being the simplest model, the derived image would be artifact
free, i.e. there would be no spurious sources, since by construction
the simplest model eliminates unneeded structures. In addition, the
model would necessarily be a "critical" model, i.e. most tightly
constrained by the data, and consequently have the most accurately
determined parameters.
\end{quote}

In the simplest terms, the pixon method smooths a model locally as
much as is allowed by the specified noise level. This, like all
high performance estimation methods, the pixon approach works
best when the noise level is known and well-characterized.

The Pixon algorithm is available via an IDL library courtesy of the
\htmladdnormallink{Pixon LLC}{\pixonURL}. This means that you must
have the library and IDL installed on your computer. The Pixon library
is available free of charge for your personal scientific use direct
from \htmladdnormallink{Pixon LLC}{info@pixon.com}. IDL is available
commercially from \htmladdnormallink{RSI}{\rsiURL}.

Before {\tt pixon} can be run, you must run {\tt setdata} and {\tt setimage}.

The algorithms available are:

\begin{description}
\item[singledish] The single dish observations are fed directly to the
pixon algorithm. Make the image cellsize considerably finer than Nyquist
sampling. The errors are those attached to each data
point. It is particularly important that the estimated sigmas
attached to the data are accurate. 
\item[synthesis] A dirty image and dirty point spread function are fed 
to the pixon algorithm. The error is assumed to be constant across
the image. This approach is not formally correct and gives results
that are not optimum. Development of pixon processing for synthesis
observations is proceeding.
\item[test] The standard Pixon LLC test is run.
\end{description}

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{algorithm}{Algorithm to use}{'singledish'}{String:'singledish'|'synthesis'|'test'}
\ahaddarg[in]{sigma}{Image sigma to try to achieve}{'0.001Jy'}{Quantity}
\ahaddarg[in]{model}{Name of model image}{}{String}
\ahaddarg[in]{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.pixon(model='3C273XC1.pixon.model', algorithm='synthesis', 
sigma='0.001Jy')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{plotsummary}{Plot a summary of field and spectral window  ids}
\begin{ahdescription}
Performs a simple plot of the field and spectral window IDs
versus time (after sorting).
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
m:=fitstoms('3C273XC1.ms', '3C273XC1.fits'); m.close()
imgr:=imager('3C273XC1.ms')
imgr.plotsummary()
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
\end{ahcomments}
\end{ahfunction}

\begin{ahfunction}{plotuv}{Plot the uv coverage}
\begin{ahdescription}
Performs a simple plot of the uv coverage of all selected data.

Optionally, plotuv will rotate the uvw coordinates to the
specified phase center (set via \ahlink{setimage}{imager:setimage}).
\end{ahdescription}
\begin{ahargs}
\ahaddarg{rotate}{Rotate uvw coordinates to specified phase center?}{F}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
m:=fitstoms('3C273XC1.ms', '3C273XC1.fits'); m.close()
imgr:=imager('3C273XC1.ms')
imgr.plotuv(F)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
\end{ahcomments}
\end{ahfunction}


\begin{ahfunction}{plotvis}{Plot the visibility amplitudes as a function of u-v radius (also, see visplot tool}
\begin{ahdescription}
Performs a simple plot of the visibility amplitudes of all selected data.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{type}{Type of plot: can contain all, observed, corrected, model, residual}{all}{String}
\ahaddarg{increment}{Increment in points to plot}{1}{Int}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
m:=fitstoms('3C273XC1.ms', '3C273XC1.fits'); m.close()
imgr:=imager('3C273XC1.ms')
imgr.plotvis(increment=10)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
\end{ahcomments}
\end{ahfunction}

\begin{ahfunction}{plotweights}{Plot the visibility weights as a function of u-v radius}
\begin{ahdescription}
Performs a plot of the visibility weights of all selected data (stored in
the IMAGING\_WEIGHT column of the MeasurementSet).
The plot can be of the gridded weights (type='gridded') or
ungridded.

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{gridded}{Do gridded plot?}{F}{Bool}
\ahaddarg[in]{increment}{Increment in points to plot}{1}{Int}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
m:=fitstoms('3C273XC1.ms', '3C273XC1.fits'); m.close()
imgr:=imager('3C273XC1.ms')
imgr.setimage(cellx='0.7arcsec', celly='0.7arcsec')
imgr.weight('briggs')
imgr.plotweights(gridded=T,increment=10)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
\end{ahcomments}
\end{ahfunction}


\begin{ahfunction}{regionmask}{Construct a mask image from a region}
\begin{ahdescription}
A mask image is an image with the same shape as the other images but
with values between 0.0 and 1.0 as a pixel value. Mask images are used in
imager to control the region selected in a deconvolution. 

In the Clark CLEAN, the mask image can usefully have any value between
0.0 and 1.0. Intermediate value is discouraged but do not rule out
selection of clean components in that region. This is accomplished by
multiplying the residual image by the mask prior to entering the minor
cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
it must cover only a quarter of the image. boxmask does not enforce
this requirement. 

The function regionmask also allows multiple regions to be used. A record of the regions can be made as in the example below. 

Regions can be made in many different ways using the
\ahlink{regionmanager}{images:regionmanager} functions. An example
using \ahlink{wbox}{images:regionmanager.wbox} function is given
below. The default regionmanager tool 'drm' can be used for most
cases unless it is already set for some other images.

For gui users regions to be masked can be made from an image:

\begin{itemize}

\item  Fill in the desired name of the mask.

\item On the ``Spanner'' button for the region, select the 'FromImage'.

\item This will pop a catalogue GUI, select the image you want to use
a template to draw mask and press the 'send \& Dismiss' button. This 
will display the image using the viewer.

\item  To set a polygonal region, click once on the bottommost button on
the lefthand side of the viewer (clue: it looks like a polygon with a
letter 'R' on it). Then set the vertices of the polygon by left-clicking
each in turn. Finish with a double click on the last vertex and then
another double click inside the polygon.

\item  In the region box a name of the region like 'myregion1' will appear.

\item Press the ``Go'' button for \texttt{imager:regionmask}.

\end{itemize}

Now to set multiple regions a 'union of  regions' can be easily made
by using the viewer in step 3 above. Under the Tools menu, select
'ImageAnalysis'. A box of rollups will appear. Select the region
rollup.  Select 'union' and press 'Start'. Then on the viewer click on
one of the Region making buttons (the two bottom most buttons on the
left margin with 'R's on them). After making a region click twice
inside. The 'accumulate' on the Region rollup should increment. Keep
repeating this process of making a region at different places and
clicking twice in (remember 'ESC' key is used to get rid of a box you
have drawn before drawing the next one).  Press on the 'Finish' button
and dismiss the rollup and viewer. A region with a name like
'myregion1' would have appeared in the region box, which represent a
union of all the regions the user has selected.

For script writers who still want to interactively set the regions,
 a call to the {gopher}{widgets:gopher} tool can used. 

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{mask}{name of mask image}{}{String}
\ahaddarg[in]{region}{Region}{unset}{Any valid region or a record of regions}
\ahaddarg[in]{value}{Value to set the mask to}{1.0}{Any scalar}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}

The following  the image bigmask, and then sets the inner quarter to unity. Then cleans using it as the mask.

- imgr.regionmask(mask='bigmask', region=drm.quarter())
- imgr.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)

Another example using drm.wbox function: 
- im:=image('dirty')
- cs:=im.coordsys()
- drm.setcoordinates(cs,F)
- r1:=drm.wbox(blc=['173pix', '347pix'], trc=['183pix', '370pix'])
- imagr.regionmask(mask='bigmask',region=r1)

Or using a record of regions:

- r2:=drm.wbox(blc=['180pix', '344pix'], trc=['191pix', '369pix'])
- r3:=drm.wbox(blc=['189pix', '341pix'], trc=['204pix', '364pix'])
- rec:=[=]
- rec[1]:=r1
- rec[2]:=r2
- rec[3]:=r3
- imagr.regionmask(mask='bigmask',region=rec)

\end{verbatim}

Now one may wish to make regions and later use it with higher
resolution images etc. Regions can be stored in tables on disk and
recovered later for re-use (especially if its a long series of regions
making using the gui as described above. 

\begin{verbatim}
- drm.fromglobaltotable('mytab.region', 'T', 'F', "myregionoftoday", myregion1) 
\end{verbatim}

The above command using the default regionmanager tool saves the
region 'myregion1' into a table 'mytab.region'
Subsequently this table is used to recover the region and use it to
create a mask image as below. We use the function drm.namesintable()
to remind ourselves under what names the regions was saved and hence
allow us to pick the one we want.

\begin{verbatim}

- drm.namesintable('mytab.region')

myregionoftoday

- myoldregion:=drm.fromtabletoglobal('mytab.region', T, 'myregionoftoday')

- imagr.regionmask(mask='newmask',region=myoldregion)
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{residual}{Calculate the residual image with respect to current model and component list}
\begin{ahdescription}
Calculate the residuals corresponding to the model and
componentlist. {\em Note that the model visibilities are updated}.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{model}{Names of input models}{}{Vector of Strings}
\ahaddarg[in]{complist}{Name of component list}{}{String}
\ahaddarg[in]{image}{Names of output residual images}{}{Vector of Strings}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.residual(model='3C273XC1.clean', complist='3C273XC1.cl',
image='3C273XC1.clean.residual')
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{restore}{Calculate the restored image with restored model, component list, and  residuals}
\begin{ahdescription}
Restore the residuals to a smoothed version of the model. The model
images are convolved with the specified Gaussian beam and then the
residual images are added.  {\em Note that the model visibilities are
updated and thus reflect the model and componentlist that was
used.}. Use \ahlink{setbeam}{imager:imager.setbeam} to set the beam
parameters.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{model}{Names of input model}{}{Vector of Strings}
\ahaddarg[in]{complist}{Name of component list}{}{String}
\ahaddarg[in]{image}{Names of output restored images}{}{Vector of Strings}
\ahaddarg[in]{residual}{Names of residual images}{}{Vector of strings}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setbeam(bmaj='2.0arcsec', bmin='2.0arcsec')
- imgr.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',
\end{verbatim}
\end{ahexample}
\end{ahfunction}


%\begin{ahfunction}{selfcal}{Self-calibrate the MeasurementSet using a
%- calibrater tool and model+component list}
%
% THIS FUNCTION IS DEPRECATED AND SHOULD NOT BE USED. WE WILL BE
% REMOVING IT FROM THE IMAGER TOOL SOON.
%
%
%To self-calibrate, first make a \ahlink{calibrater}{calibrater} tool and
%set it up as required. Then use this tool function to do the selfcal.
%The steps coded in the tool function may also be done by hand, of
%course. These are:
%\begin{enumerate}
%\item Call \ahlink{imager.ft}{imager:imager.ft} To Fourier transform the model
%and optional componentlist
%\item Call \ahlink{calibrater.solve}{calibrater:calibrater.solve} to do the solution,
%optionally writing out tables containing gain information.
%\item Call \ahlink{calibrater.correct}{calibrater:calibrater.correct} to do the correction
%of the data.
%\end{enumerate}
%
%After the selfcal step, the next stage is to re-image the data using
%{\em e.g.} \ahlink{clean}{imager:imager.clean} or \ahlink{nnls}{imager:imager.nnls}.

%\begin{ahdescription}
%\begin{ahargs}
%\ahaddarg{caltool}{Glish name of calibrater tool}{NONE!}{Any valid calibrater tool}
%\ahaddarg{model}{Name of images}{}{Vector of strings}
%\ahaddarg{complist}{Name of component list}{}{String}
%\end{ahargs}
%\ahreturns{Bool}
%\begin{ahexample}
%\begin{verbatim}
%imgr:=imager('3C273XC1.ms')
%cl:=calibrater('3C273XC1.ms')
%cl.setsolve('T', 60, 'T', -1, '', F)
%imgr.selfcal(cl, model='clean')
%imgr.clean(model='newclean', image='newclean.restored')
%\end{verbatim}
%\end{ahexample}
%\begin{ahcomments}
%\end{ahcomments}
%\end{ahfunction}

\begin{ahfunction}{sensitivity}{Calculate rms  sensitivity}
\begin{ahdescription}
Calculate the point source sensitivity for the selected data, both
absolutely and relatively (to that for natural weighting).

To do the calculation, we use the imaging weights (in the 
column called IMAGING\_WEIGHT) and the specified sigma per point
(in the column SIGMA). Therefore, this includes all the effects
of \ahlink{weight}{imager:imager.weight} and \ahlink{filter}{imager:imager.filter}.

\end{ahdescription}
\begin{ahargs}
\ahaddarg[out]{pointsource}{Calculated point source sensitivity (Jy/beam)}{}{Quantity}
\ahaddarg[out]{relative}{Calculated relative sensitivity}{}{Double}
\ahaddarg[out]{sumweights}{Calculated sum of weights}{}{Double}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}

\begin{ahexample}
\begin{verbatim}
local s,r,sum
ok := imgr.sensitivity(s,r,sum,F)
print 'Sensitivity = ', s
print 'Relative to Natural Weighting = ', r
\end{verbatim}
\end{ahexample}

\begin{ahexample}
\begin{verbatim}
imgr.sensitivity()
# Wait for it to finish and then ask for the result:
- defaultservers.result(1)
[pointsource=[value=0.25, unit='Jy'], relative=2.5, sumweights=642085.45]
\end{verbatim}
\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{setbeam}{Set the beam parameters for clean restoration}
\begin{ahdescription}
This sets the clean beam that will be used in all restoration
operations.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{bmaj}{Major axis of beam}{}{Quantity record}
\ahaddarg[in]{bmin}{Minor axis of beam}{}{Quantity record}
\ahaddarg[in]{bpa}{Position angle of beam}{}{Quantity record}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\end{ahfunction}


\begin{ahfunction}{setdata}{Set the data parameters selection for subsequent processing}
\begin{ahdescription}
This setup tool function selects which data are to be used 
subsequently. After invocation of setdata, only the selected
data are operated on. Thus, for example, in imaging, only the selected
data are gridded into an image, and in plotting, only the
selected data are plotted.

Data can be selected by field and spectral window ids. Note that
all data thus selected are passed to the imaging, and may or
may not be imaged, depending on how the image was constructed
using \ahlink{setimage}{imager:imager.setimage}. For example,
in mosaicing, use fieldid in setimage to control what pointing
is used to define the field center, and use fieldid in setdata
to control what pointings are used in the imaging.

For spectral processing,  it is possible to make cubes out
multi-spectral window selections but the selection is terse till a
better selection scheme is devised.

The selection is controlled by the mode argument:

\begin{description}
\item[none] Selection ignores channel parameters but selects all
  channels from spectral window ids and field ids selected.
\item[channel]   Selection in channels using the nchan, start and step
arguments
\end{description}

For channel mode, the other fields have the following meaning:

\begin{description}
\item[nchan]   is the number of output channels selected. It
defaults to 1 (i.e., the first channel).
\item[start] is the first channel from input dataset that is to be used.
It defaults to 1 (i.e. first channel).
\item[step] gives the increment between selected input channels. 
\end{description}

The channels are centered on velocities: start, start+step,
start+2*step, etc.  

By choosing the parameters for setdata and setimage correctly,
one may obtain various mappings of visibility channels to image
channels. For example, to average 512 visibility channels into 64 
image channels (producing image channels consisting of 8
visibility channels):

\begin{verbatim}
imgr.setimage(mode='channel', nchan=64, start=1, step=8);
imgr.setdata(mode='channel', nchan=512, start=1, step=1)
imgr.clean(....);
\end{verbatim}

This averages the spectral channels during the gridding process. If
one wanted to only include every 8th channel in the
deconvolution, one would do:

\begin{verbatim}
imgr.setdata(mode='channel', nchan=64, start=1, step=8)
imgr.setimage(mode='channel', nchan=64, start=1, step=8);
imgr.clean(....);
\end{verbatim}

For velocity and opticalvelocity modes, the mstart and mstep
are the start and step velocities as strings.

\begin{verbatim}
imgr.setimage(mode='velocity', nchan=64, mstart='20km/s', mstep='-100m/s');
imgr.setdata(mode='velocity', nchan=64, mstart='20km/s', mstep='-100m/s');
imgr.clean();
\end{verbatim}

If the image and data selections differ, then averaging is done during
the gridding and degridding process in the image deconvolution.

\begin{verbatim}
imgr.setimage(mode='channel', nchan=64, start=1, step=8);
imgr.setdata(mode='channel', nchan=512, start=1, step=1)
imgr.clean()
\end{verbatim}

Note:  The channels numbers used in {\tt setimage}
and {\tt setdata} refers to the same channel. So if a channel is not
selected in {\tt setdata} but is selected in {\tt setimage}, then
blank channels image are made. The example below will result in the 
having the first 5 channels in the image to be blank.

\begin{verbatim}
imgr.setdata(mode='channel', nchan=50, start=6, step=1) #selected chan 6-55
imgr.setimage(mode='channel', nchan=50, start=1, step=1); 

# will try to image channel 1-50. But as previously only channel 6-55 
# was selected only channel 6-50 will have data; images of channels
# 1-5 are blank 
imgr.clean()
\end{verbatim}


For multi-spectral window cube imaging the selection of the data can
be done as follows

\begin{verbatim}
imgr.setdata(mode='channel', nchan=[50,60], start=[1,1], step=[1,1],
             spwid=[1,2]) 
imgr.setimage(mode='channel', nchan=110, start=1, step=1, spwid=[1,2]); 

\end{verbatim}

The above means that you would make a data selection of 50 channels
(starting from 1 steping 1) from the first spectral window and 60
channels (starting from 1 steping 1). The setimage defines the image
to be a cube of 110 channels. The caveat is the step size in the
frequency direction is the step size of the first spectral window. If
the step size of channels of the two spectral windows are different
then one is better off defining the image cube in velocities (e.g. as below). 

                                                                      
\begin{verbatim}
imgr.setdata(mode='channel', nchan=[50,60], start=[1,1], step=[1,1],
             spwid=[1,2]) 
imgr.setimage(mode='velocity', nchan=200, mstart='20km/s',
             mstep='-100m/s'); 
	

\end{verbatim}



Multi ms processing. One can use many ms's to make an image. Setdata
is used to select the ms and make the selections. {\em Please note
  that the imager tool has to be constructed empty to be able to do a
  multi ms processing.}




\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{msname}{ms to be used for this selection ONLY when no ms is
  used at contruction}{''}{String}
\ahaddarg[in]{mode}{Type of selection }{}{'none'| 'channel'}
\ahaddarg[in]{nchan}{Number of channels to select}{1}{Vector of Ints}
\ahaddarg[in]{start}{Start channels (1-relative)}{1}{ Vector of Ints}
\ahaddarg[in]{step}{Step in channel number}{1}{Vector of Int}
\ahaddarg[in]{spwid}{Spectral Window Ids (1 relative) to select}{1}{Vector of Ints}
\ahaddarg[in]{fieldid}{Field Ids (1 relative) to select}{1}{Vector of Ints}
\ahaddarg[in]{msselect}{TQL select string applied as a logical "and" with the other selections}{}{String}
\ahaddarg[in]{async}{Run asynchronously in the background?}{!dowait}{Bool}
\end{ahargs}
\begin{ahexample}

A selection that picks the first 512 channels of spectral window 1 and data 
after the 10th scan.
\begin{verbatim}
imgr:=imager('3C273XC1.MS');
imgr.setdata(mode='channel', spwid=1, nchan=512,start=1,step=1, 
             msselect='SCAN_NUMBER > 10')
\end{verbatim}
\end{ahexample}

Example of how to use imager on multiple ms to make an image to make a
2 fields mosaic:

\begin{ahexample}
\begin{verbatim}
include 'imager.g'
im:=imager();
im.setdata(mode="none" ,  spwid=[1, 2] ,
        fieldid=1, msname='FIELD_1.ms);

im.setdata(mode="none" ,  spwid=[1, 2] ,
        fieldid=1, msname='FIELD_2.ms);

mydir:=dm.direction('J2000','9h10m15.0', '-5d44m5.2')

im.setimage(nx=300, ny=300, cellx='2.0arcsec',
        celly='2.0arcsec' , stokes="I" , doshift=T,
        phasecenter=mydir, spwid=[1:2], fieldid=1);
im.weight('natural')
im.setvp(dovp=T)
im.setoptions(ftmachine='mosaic')
im.make('testB');
im.clean(algorithm='mfclark', niter=2000, gain=0.2, model='testB')
im.done()
\end{verbatim}
\end{ahexample}

\end{ahfunction}

\begin{ahfunction}{setimage}{Set the image parameters for subsequent processing}
\begin{ahdescription}
Define the default image parameters. If an image is to be
made, then these parameters are used in the construction
of the image. Thus, for example, the tool function \ahlink{make}{imager:imager.make}
makes an (empty) image using these parameters. 

Note that some parameters can be specified either in canonical units
or via measures. To establish default values, the ids for the default
spectral window and default field id must be given.

The meaning of arguments mode, nchan, step, {\em etc.} is described in
\ahlink{setdata}{imager:imager.setdata}. {\tt imager} can perform multi-frequency
synthesis over several spectral windows (mode='mfs'). To achieve this,
you should set spwid to an array of the required spectral windows
({\em e.g.}  {\tt spwid=1:2}).\\
WARNING: For multifrequency synthesis, 'mfs', it is important that the spwid's
selected in \ahlink{setdata}{imager:imager.setdata} be the SAME as the one
selected in 'setimage'.  Otherwise the frequency at which the  image
is made is not going to be the same as to the one as the one used in
gridding the visibility and can lead to image artifacts.  


The phase center of the image defaults to that of the specified
fieldid (the first if none is specified). This is important if you have 
multiple pointings in the data. The user would have used 
\ahlink{setdata}{imager:imager.setdata} to select which pointings 
would be used in imaging. Note that the fieldid refers
to the ordering of fields in a MeasurementSet, and has no connection
with the number of facets in an image. A phase center may be also
specified in an argument to setimage using any valid
\ahlink{direction}{measures:measures.direction}. If the conversion
from the observed direction requires frame information then this
is taken as follows:
\begin{itemize}
\item Direction information, including the coordinate system,
is taken from the relevant entry in the Field table of the
MeasurementSet.
\item The epoch is taken from the time of observation of
each visibility.
\item A position is specified via the {\tt imager} tool function \ahlink{setoptions}
{imager:imager.setoptions}
\end{itemize}

If the specified number of facets is greater than unity then the image
is split into facets (this number along the x and y axes) and
processed. This is necessary when using wide-field algorithm for
deconvolving the image, in cases of non-coplanar arrays (e.g the VLA
at low frequencies but can be safely left at 1 for the ATCA or WSRT).

A position shift may be added using the arguments shiftx,
shifty. This will be added to whatever the phase center was set to
as described above. The shift is a real angle on the {\tt imager} so that,
in e.g. RA, DEC, the RA shift is divided by cos(DEC) before being
added to the RA. The sense of the shift is that the position after
addition of the shift gives the new phase center of the image. The
shift is in the reference frame of the phase center.

For spectral imaging {\tt setimage} and {\tt setdata} defines the
spectral channels that are imaged. Examples are given in the
\ahlink{setdata} {imager:imager.setdata} section.

For wide-field or 3D imaging see \ahlink{setoptions} {imager:imager.setoptions}
section for some examples.


{\it Note for multi-ms usage}: When using imager with multiple
ms's; the spwid and field id parameters will refer to the ms used in the
last \ahlink{setdata}{imager:imager.setdata} call. If this is not
appropriate then the direction has to be explicitly given through the
{\tt phasecenter parameter}. Similarly if the spwid cannot
appropriately be used to define the spectral parameters of the image
wanted, then the {\tt velocity} mode needs to be selected with
explicit velocity parameters.

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{nx}{Total number of spatial pixels in x}{128}{Int}
\ahaddarg[in]{ny}{Total number of spatial pixels in y}{128}{Int}
\ahaddarg[in]{cellx}{Cellsize in x (e.g. '1arcsec')}{'1arcsec'}{Quantity}
\ahaddarg[in]{celly}{Cellsize in y (e.g. '1arcsec')}{'1arcsec'}{Quantity}
\ahaddarg[in]{stokes}{Stokes parameters to image (e.g. 'IQUV')}{'I'}{'I'|'IV'|'IQU'|'IQUV'}
\ahaddarg[in]{doshift}{Use the specified phase center? T or F}{F}{Bool}
\ahaddarg[in]{phasecenter}{Direction of phase center as a measure}{}{MDirection}
\ahaddarg[in]{shiftx}{Shift in x (e.g. '23.7arcsec')}{'0arcsec'}{Quantity}
\ahaddarg[in]{shifty}{Shift in y (e.g. '-54.2arcsec')}{'0arcsec'}{Quantity}
\ahaddarg[in]{mode}{Type of processing}{'mfs'}{'mfs'|'channel'|'velocity'}
\ahaddarg[in]{nchan}{Number of channels}{1}{Int}
\ahaddarg[in]{start}{Start channel (1-relative)}{}{Int}
\ahaddarg[in]{step}{Step in channel}{}{Int}
\ahaddarg[in]{mstart}{Start velocity}{}{MRadialVelocity}
\ahaddarg[in]{mstep}{Step in velocity}{}{MRadialVelocity}
\ahaddarg[in]{spwid}{Spectral Window Ids (1 relative)}{1}{Vector of Ints}
\ahaddarg[in]{fieldid}{Field Id (1 relative)}{1}{Int}
\ahaddarg[in]{facets}{Number of facets on each axis}{1}{Integer}
\ahaddarg[in]{distance}{Distance to object: usually ignore this! (m)}{'0m'}{Quantity}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
## Example 1
imgr.setimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
nchan=1, stokes='IV', doshift=T, phasecenter=dm.direction('mars'));
## Example 2
imgr.setimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
nchan=1, stokes='IV', doshift=T, 
phasecenter=image('othermarsimage').coordmeasures().direction);
## Example 3
myimager.setdata(mode='channel', nchan=10, start=3, spwid=[1,2], fieldid=[3, 4, 5, 6, 7, 9, 10])
myimager.setimage(nx=500, ny=500, mode='mfs', spwid=[1,2], fieldid=7)
myimager.clean(algorithm='mfclark', niter=1000, model='mosaic') 

## Example 4

dir1:=dm.direction('J2000', '20h00m00', '21d00m00')
dir2:=dm.direction('J2000', '20h10m00', '21d00m00')
dir3:=dm.direction('J2000', '20h00m00', '21d03m00')
imgr.setimage(nx=100, ny=100, cellx='0.1arcsec', celly='0.1arsec',
              doshift=T, phasecenter=dir1)
imgr.make('box1')
imgr.setimage(nx=100, ny=100, cellx='0.1arcsec', celly='0.1arsec',
              doshift=T, phasecenter=dir2)
imgr.make('box2')
imgr.setimage(nx=100, ny=100, cellx='0.1arcsec', celly='0.1arsec',
              doshift=T, phasecenter=dir3)
imgr.make('box3')
imgr.clean(algorithm='mfclark', model=['box1', 'box2', 'box3'], 
	   image=['box1.restored', 'box2.restored', 'box3.restored'],
	   residual=['box1.residual', 'box2.residual', 'box3.residual'])



\end{verbatim}
\end{ahexample}
\begin{ahcomments}
In the first example, the image parameters are set for 1024 by 1024
pixels of 30marc, 1 channel will be made, Stokes I and V will be
imaged, and the phasecenter will be the direction of Mars as given by
the JPL DE-200 emphemeris. In the second, the phase center is taken
to be that of the reference pixel of another image.

The third example shows the use of setdata and setimage to setup a mosaic. In 
the set data we have chosen 10 channels (for each IF) of data starting form 
channel 3. We also have selected IF 1 and 2. We have selected data from 
fields 3 to 10. In the setimage we decide to use the data to make a 
multifrequency synthesis image. We center the image on the field 7 pointing.  

The fourth example is use to clean regions where the user knows the
sources are and ignore all the other regions. This is very efficient
in large fields with few sources. Smaller images are made and
deconvolved around known sources rather than making a big image
englobing all three fields. Care should be taken in NOT overlapping
the regions imaged this way otherwise the deconvolution will fail.

\end{ahcomments}



\end{ahfunction}


\begin{ahfunction}{setjy}{Compute the model visibility for a specified source flux density}
\begin{ahdescription}
Compute the model visibility for a specified source flux density, and
insert into the MODEL\_DATA column. The source flux density for
a set of standard flux density reference sources may optionally
be pre-computed, by setting the input flux density to -1 (the default).
At present, these include 3C286, 3C48, 3C147, 3C138, and 1934-638.
In this case, if the source is not in this set, an unpolarized
flux density of 1 Jy will be assumed.  Users may also specify
{\tt standard='SOURCE'} to use the model(s) in the SOURCE\_MODEL column of the
SOURCE subtable.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{fieldid}{Field Id (1-relative)}{-1}{Int}
\ahaddarg[in]{spwid}{Spectral Window Id. (1-relative)}{-1}{Int}
\ahaddarg[in]{fluxdensity}{Specified flux density (I,Q,U,V) in Jy}{-1 (lookup the value; use 1.0 if not found)}{Vector of Doubles}
\ahaddarg[in]{standard}{Flux density standard}{}{String:'Baars'|'Perley 90'|'Perley-Taylor 95'|'Perley-Taylor 99'|'SOURCE'}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.setjy(fieldid=2, spwid=-1, fluxdensity=[2.6,0.2,0.3,0.5],standard='Baars')
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Compute the model visibility for field id. 2 to the specified
point-source (I,Q,U,V) for all spectral windows id.'s on the
Baars flux density scale.
\end{ahcomments}
\end{ahfunction}



\begin{ahfunction}{setmfcontrol}{Set various cycle control parameters for 
multi-field and wide-field imageing.}
\begin{ahdescription} 
Control parameters for mosaicing or wide-field imaging which are not
required in single field deconvolution are set here to streamline the
user interface.  As multifield and widefield imaging is accomplished
by deconvolution in cycles, many of these parameters control how the
deconvolution cycles are ended.

\begin{description}
\item cyclefactor: this parameter helps in lowering or increasing the
  threshold at which the deconvolution cycle will stop  and degrid and
  subtract from the visibilities. For very bad PSFs you may want to
  reconcile with the visibilties often, thus a larger number is
  required here...(4 to 5). For very well behaved data you may want to
  deconvolve deep before reconciling: a lower number is used (1.5 to 2.0). 
\item cyclespeedup: this is used if the PSF is not well behaved and
  you want clean to raise by 2 the threshold if it has not reached the
  threshold in this number of iteration
\item stoplargenegatives: This parameter is exclusively for when using
  multiscale clean. This is used to stop the component
  search when the largest scale has found this number of negative
  components. -1 here means that continue component search even if the
  largest component is negative. 
\item stoppointmode: Again exclusively for when using multiscale
  clean. The clean will stop if the smallest scale receives this
  number of consecutive components. 
\item minpb: This is to defined up to what level the voltage pattern
  is going to applied when  using
  \ahlink{setvp}{imager:imager.setvp}. The default is 0.1 of the
  primary beam or the voltage pattern defined for the antenna.
\item scaletype: This parameter cab be NONE or SAULT. If NONE the
  image is not scaled, if SAULT is used the image is weighted so that
  the noise is kept uniform across the image. The next two parameters
  defines how the SAULT weighting is limited. Obviously then the flux
  scale is not uniform across the image. To get the right flux
  multiply the image with the fluxscale image.
\item constpb: this parameter defines up to what amplitude of the
  Primary beam the noise floor is kept uniform, when using SAULT as scaletype.
\item fluxscale: use this to give a filename to store the factor image
  to apply to the image to get the fluxscale right.
\end{description}


\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{cyclefactor}{Cycle threshold = this * max sidelobe * max resid}{1.5}{Float}
\ahaddarg[in]{cyclespeedup}{Cycle threshold doubles in this number of iterations}{-1}{Float}
\ahaddarg[in]{stoplargenegatives}{Stop the multiscale cycle for the first n cycles when a negative comp is found on the largest scale}{2}{Int}
\ahaddarg[in]{stoppointmode}{Stop multiscale altogether if the smallest
  scale recieves this many consecutive components}{-1}{Int}
\ahaddarg[in]{minpb}{Minimum PB level to use}{0.1}{Float}
\ahaddarg[in]{scaletype}{Image plane flux scale type}{'NONE'}{String:'NONE'|'SAULT'}
\ahaddarg[in]{constpb}{In Sault weighting the flux scale is constant above this PB level}{0.4}{Float}
\ahaddarg[in]{fluxscale}{Names of flux scale images for mosaicing}{}{Vector of strings}
\end{ahargs}

\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.setmfcontrol(cyclefactor=2.0, cyclespeedup=niter/10, 
stoplargenegatives=T, stoppointmode=10, fluxscale='image.fluxscale');
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\begin{ahfunction}{setoptions}{Set some general options for subsequent processing}
\begin{ahdescription}
This function is for setting different gridding and memory options

\begin{description}
\item[ftmachine] The options for ftmachine are: 
\begin{description}
\item[ft] Standard interferometric gridding
\item[sd] Standard single dish gridding
\item[both] ft and sd as appropriate.
\item[wfmemoryft] option for wide-field imaging, to grid in memory for
  all facets in one pass through the data
\item[wproject] option for using the wproject algorithm for wide-field
  imaging; when this option is used the parameter {\tt wprojplanes}
  define the number of convolution functions to be used
\item[mosaic] option to use the gridder that uses the primary beam as
  the convolution function in gridding

\end{description}
\item[cache] The size of the cache used (in complex pixels) during the
gridding process. The default is to use half the physical memory of
the machine as specified by the aipsrc variable system.resources.memory.
\item[tile] The side of the tile (in complex pixels) during the
gridding process.
\item[gridfunction] The gridding function used. Currently only
Box-car ('BOX') and Prolate Spheriodal Wave Function ('SF')
are supported.  In the case of Single-Dish imaging the Primary Beam ('PB') also can be used. 
\item[location] For some unusual types of image, one needs to know the
location to be used in calculating phase rotations. For example,
one can specify images to be constructed in azel, in which
case, an antenna position must be chosen. One can use functions of
\ahlink{measures}{measures}: either
\ahlink{observatory}{measures:measures.observatory} to
get the position of a named observatory ({\em e.g.}
dm.observatory('ATCA')) or
\ahlink{position}{measures:measures.position} to set
the position ({\em e.g.} dm.position('wgs84','30deg','40deg','10m')).
Although this information is available from the MeasurementSet, what
location is ambiguous in some cases {\em e.g.} VLBI.
\item[padding] When gridding and transforming, the array may be
padded by this factor in the image plane. This reduces aliasing,
especially in wide-field cleaning.
\item[usemodelcol] if this is false it tells imager to create and use the model
  visibility on the fly and in memory as far as possible...otherwise
  if it is True then imager will use the MODEL\_DATA column to do this.
\item[wprojplanes] this parameter is is used only of {\tt ftmachine}
  is set to {\tt wproject}. This defines how many convolution functions
  is used in the Wprojection gridder.
\end{description}
\end{ahdescription}

\begin{ahargs}
\ahaddarg[in]{ftmachine}{Fourier transform
  machine}{'ft'}{String:'ft'|'sd'|'both' | 'wfmemoryft'| 'wproject' |'mosaic'}
\ahaddarg[in]{cache}{Size of gridding cache in complex pixels}{4194304}{Int}
\ahaddarg[in]{tile}{Size of a gridding tile in pixels (in 1 dimension)}{16}{Int}
\ahaddarg[in]{gridfunction}{Gridding function}{'SF'}{String: 'SF'|'BOX'|'PB'}
\ahaddarg[in]{location}{Location used in phase rotations}{}{position measure}
\ahaddarg[in]{padding}{Padding factor in image plane (>=1.0)}{1.0}{Float}
\ahaddarg[in]{usemodelcol}{use MODEL\_DATA column or not}{T}{boolean}
\ahaddarg[in]{wprojplanes}{No of gridding convolution functions used in
  wproject-ft machine}{1}{Integer}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setoptions(cache=10000000, tile=32, gridfunction='BOX',
  location=dm.location('vla'))
\end{verbatim}
The above example is to tell imager to use memory to fit 10000000
complex numbers and tile the image with tiles of 32 pixels on a side. 
Also it tells imager to use a box function as gridding function.  The
location parameter will make imager overide the position of the
telescope to use (the default is the one it gets from the ms). 

\begin{verbatim}
myim:=imager('n1333.ms')
myim.setdata(fieldid=[2:6, 8:12], spwid=[1:2])
myim.setimage(nx=800, ny=800, cellx='0.5arcsec', celly='0.5arcsec', mode='velocity', nchan=30, mstart='-10km/s', mstep='1.8km/s', spwid=[1,2],fieldid=3)
myim.setoptions(ftmachine='mosaic')
myim.setvp(dovp=T)
myim.setoptions(ftmachine='mosaic')
myim.clean(algorithm='mfclark', model='try1', niter=200)

\end{verbatim}

In the above example we are making a mosaic using the fields
2,3,4,5,6,8,9,10,11,12 and we use the mosaic ftmachine. This uses the
primary beam of the telescope as the gridding function.


\begin{verbatim}
pim:=imager('coma.ms')

pim.setdata(spwid=1, fieldid=1);
mydir:=dm.direction('J2000', '12h30m48', '12d24m0')
pim.setimage(nx=200, ny=200, cellx='30arcsec', celly='30arcsec', doshift=T, phasecenter=mydir); 
pim.make('outlier1');
pim.setimage(nx=1800, ny=1800, cellx='30arcsec',celly='30arcsec',facets=1);
pim.setoptions(ftmachine='wproject',wprojplanes=512, padding=1.0)
pim.make('main')
pim.clean(algorithm='mfclark',model=['main', 'outlier1'], niter=10000)
pim.done()

\end{verbatim}

In the above example we are using the Wprojection algorithm for 3-D
imaging. We are using 512 gridding functions. Sometimes if there is a
memory issue (very large images and many griding functions) we suggest  
the use of facetting of the image with wprojection. So the example
above would be something like below. Note that when using facets only
the {\tt wfclark} and {\tt wfhogbom} can be used for now. Note on how
an outlier field (or flanking) field is set on an interfering  source
outside of the field of interest.

\begin{verbatim}
pim:=imager('coma.ms')

pim.setdata(spwid=1, fieldid=1);
mydir:=dm.direction('J2000', '12h30m48', '12d24m0')
pim.setimage(nx=200, ny=200, cellx='30arcsec', celly='30arcsec', doshift=T, phasecenter=mydir); 
pim.make('outlier1');
pim.setimage(nx=3000, ny=3000, cellx='30arcsec',celly='30arcsec',facets=3);
pim.setoptions(ftmachine='wproject',wprojplanes=200, padding=1.2)
pim.make('main')
pim.clean(algorithm='wfclark',model=['main', 'outlier1'], niter=10000)
pim.done()

\end{verbatim}

\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{setscales}{Set the scale sizes for MultiScale Clean}
\begin{ahdescription}

The multiscale clean algorithm cleans an image on a number of
different scales, decomposing the image into Gaussians of these scale sizes.
This function allows the user to set the number
of scales used (using the nscales method), or to directly control the
sizes of the scales in pixels (using the uservector method).  When using the
nscales method, the scales are calculated using the following formula:
\begin{equation}
\theta_{minor}  10.0 ^{(i- N_{scales}/2)/2.0}
\end{equation}
where $\theta_{min}$ is the fitted minor axis of the clean beam. The
first value is zero.
\end{ahdescription}

\begin{ahargs} 
\ahaddarg[in]{scalemethod}{Method by which scales are set}{nscales}{String: 'nscales'|'uservector'}
\ahaddarg[in]{nscales}{Number of scales}{5}{Int}
\ahaddarg[in]{uservector}{Vector of scale sizes in pixels to use}{[0, 3, 10]}{Vector of Doubles}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setscales(scalemethod='nscales', nscales=6);
\end{verbatim}
Here we make six scales automatically using the method described
above.
Or we could manually choose the scales in pixel numbers as follows:
\begin{verbatim}
- imgr.setscales(scalemethod='uservector', uservector=[0,3,10,30]);
\end{verbatim}

Note: 0 pixel is the delta function, so if one were to select scale 0 only
it would be  equivalent to a Hogbom clean.

\end{ahexample}

\end{ahfunction}


\begin{ahfunction}{setsdoptions}{Set some options for single dish processing}
\begin{ahdescription}
Various less-often-used options for single dish processing can be set.


\begin{description}
\item[scale] The overall scale of the single dish data is multiplied by this
factor.
\item[weight] The weight given to the single dish data in the imaging
is multiplied by this factor.
\end{description}
\item[convsupport] This parameter can be used to change the support used in gridding single dish data in imaging. If 'PB' or 'pb' is used as the 'convtype' in 
 \ahlink{setoptions}{imager:imager.setoptions} this parameter is ignored as the support is defined by the primary beam. The deafult of -1 means 1 as convsupport is used for 'box' convolution function and 3 is used for 'SF' convolution function.

\end{ahdescription}

\begin{ahargs}
\ahaddarg[in]{scale}{Scaling applied to single dish data}{1.0}{Float}
\ahaddarg[in]{weight}{Weights applied to single dish data}{1.0}{Float}
\ahaddarg[in]{convsupport}{number of pixel for convolution support}{-1}{Int}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.setsdoptions(scale=1.0, weight=1.0, convsupport=5)
\end{verbatim}
\end{ahexample}

\end{ahfunction}

\begin{ahfunction}{setvp}{Set the voltage pattern model for subsequent processing}
\begin{ahdescription}
Set the voltage pattern model (and hence, the primary beam) used for a Telecope.
There are currently two ways to set the voltage pattern: by using the extensive
list of defaults which the system knows about, or by creating a voltage pattern
description with the \ahlink{vpmanager}{imager:vpmanager}.  The default voltage patterns
include both a high and a low frequency VP for the WSRT, a VP for each observing
band at the AT, several VP's for the VLA, including the approrpiate beam squint for
each observing band, and  Gaussian for the BIMA dishes.  Due to temporary limitations
in the internal structure of the visibility buffer, only one telescope's voltage
pattern can be applied to a particular MeasurementSet.  This will be corrected shortly.
\end{ahdescription}

\begin{ahargs}
\ahaddarg[in]{dovp}{Do voltage pattern (ie, primary beam) correction}{F}{Bool}
\ahaddarg[in]{usedefaultvp}{Look up the default VP for this telescope and frequency?}{T}{Bool}
\ahaddarg[in]{vptable}{If usedefaultvp is false, provide a VP Table made with vpmanager}{}{String}
\ahaddarg[in]{dosquint}{Activate the beam squint in the VP model}{F}{Bool}
\ahaddarg[in]{parangleinc}{Parallactice angle increment for squint
  application}{360deg}{Quantity}
\ahaddarg[in]{telescope}{Which default telescope to use; if empty use the
  one in encoded in MS }{''}{String}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
 imgr.setvp(dovp=T, usedefaultvp=T, dosquint=F);
\end{verbatim}
\end{ahexample}

\end{ahfunction}




%

\begin{ahfunction}{smooth}{Calculate an image smoothed with a Gaussian beam}
\begin{ahdescription}
The model images are convolved with the specified Gaussian beam.  By
default (normalize=T), the beam volume is normalized to unity so that
the smoothing is flux preserving. The smoothing used in restoration is
not normalized.
\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{model}{Name of input model}{}{Vector of Strings}
\ahaddarg[in]{image}{Name of output smoothed images}{}{Vector of Strings}
\ahaddarg[in]{usefit}{Use the fitted value (rather than that specified}{T}{Boolean}
\ahaddarg[in]{bmaj}{Major axis of beam}{}{Quantity record}
\ahaddarg[in]{bmin}{Minor axis of beam}{}{Quantity record}
\ahaddarg[in]{bpa}{Position angle of beam}{}{Quantity record}
\ahaddarg[in]{normalize}{Normalize volume of psf to unity}{T}{Bool}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr.smooth(model='3C273XC1.clean', image='3C273XC1.clean.restored',
bmaj='2.0arcsec', bmin='2.0arcsec')
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{stop}{stop the currently executing function asap}
\begin{ahdescription}
Stop the currently executing function as soon as possible. Note that
it is not always possible to stop a function. 
\end{ahdescription}
\ahreturns{Bool}
\end{ahfunction}

\begin{ahfunction}{summary}{Summarize the current state of the imager tool}
\begin{ahdescription}
Writes a summary of the properties of the imager to the
default logger. This includes:
\begin{itemize}
\item The name of the MeasurementSet (set in construction or via the
\ahlink{open}{imager:imager.open} function.
\item The parameters of the image (set via \ahlink{setimage}
{imager:imager.setimage})
\item The current beam (set by \ahlink{fitpsf}{imager:imager.fitpsf}
or \ahlink{setbeam}{imager:imager.setbeam}.
\item The selection of an ms (set via \ahlink{setdata}
{imager:imager.setdata})
\item The general processing options (set via \ahlink{setoptions}
{imager:imager.setoptions})
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
- imgr:=imager('3C273XC1.MS');
- imgr.setimage(npix=[256,256])
- imgr.summary()
\end{verbatim}
\end{ahexample}
\end{ahfunction}




\begin{ahfunction}{uvrange}{Select data within the limit of a given range}
\begin{ahdescription}
Apply a uvrange so that only points within a given uvrange are selected for further usage.  To be noted \ahlink{setdata}{imager:imager.setdata} if used after uvrange will reset the selected range. So setdata should be used prior to uvrange or can be used 
to reset it if one changes one's mind. The points are not flagged! Further point to be noted for spectral line data the uv distance is calculated using the mean of the wavelengths of the different spectral channels selected. 

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{uvmin}{Minimum uv distance allowed (wavelengths)}{0.0}{Float}
\ahaddarg[in]{uvmax}{Maximum uv distance allowed (wavelengths)}{0.0}{Float}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.weight('uniform')
imgr.uvrange(0, 4000.0)
\end{verbatim}
\end{ahexample}
\end{ahfunction}
%


%

\begin{ahfunction}{weight}{Apply additional weighting to the visibility weights}
\begin{ahdescription}
Apply visibility weighting to correct for the local density of
sampling in the uv plane. The imaging weights are written into a Table
column called IMAGING\_WEIGHT, which may be plotted using 
\ahlink{plotweights}{imager:imager.plotweights}. In addition this
columns may be accessed directly using either the
\ahlink{table}{table} or \ahlink{ms}{ms} modules.

To correct for visibility sampling effects, natural, uniform (the
default), radial, and Briggs weighting are supported.  These work as
follows. Then:
\begin{description}
\item[natural]: minimizes the noise in the dirty image. The weight of
the $i$-th sample is set to the inverse variance:
\begin{equation}
w_i={1\over{\sigma_i^2}}
\end{equation}
where $\sigma_i$ is the noise of the $i$'th sample.
\item[radial]: approximately minimizes rms sidelobes for an east-west synthesis
array. The weight of the $i$-th sample is multiplied
by the radial distance from the center of the $u,v$ plane:
\begin{equation}
w_i=w_i \sqrt{u_i^2+v_i^2}
\end{equation}
\item[uniform]: For Briggs and uniform weighting, we first grid the inverse
variance $w_i$ for all selected data onto a grid of size given by the
argument npixels (default to nx) and u,v cell-size given by
$2/$fieldofview where fieldofview is the specified field of view
(defaults to the image field of view).  This forms the gridded weights
$W_k$. The weight of the $i$-th sample is then changed:
\begin{equation}
w_i={w_i\over{W_k}}
\end{equation}
where $W_k$ is the gridded weight of the relevant cell.
It may be shown that this minimizes rms sidelobes over
the field of view. By changing the field of view, one may suppress
the sidelobes over a region different (usually smaller) than the
image size.
\item[superuniform]: Similar to uniform except that the parameter {\tt
  npixels} is used to determine the cell size in the uv domain. if
  {\tt npixels}  is 0, the default used is $\pm 3$ pixels. 

\item[briggs: rmode='norm']: The weights are changed:
\begin{equation}
w_i={w_i\over{1 + W_k f^2}}
\end{equation}
where:
\begin{equation}
f^2={{(5*10^{-R})^2}\over{{\sum_k W_k^2}\over{\sum_i w_i}}}
\end{equation}
and $R$ is the robust parameter. The scaling of $R$ is such that
$R=0$ gives a good tradeoff between resolution and sensitivity.
$R$ takes value between -2.0 (close to uniform weighting) to 2.0
(close to natural).
\item[briggs: rmode='abs']: The weights are changed:
\begin{equation}
w_i={w_i\over{W_k*R^2+2*\sigma_R^2}}
\end{equation}
where $R$ is the robust parameter and $\sigma_R$ is the noise
parameter. 
\end{description}
For more details about Briggs (aka robust) weighting, see the \htmladdnormallink{Briggs thesis}
{\briggsURL}.

Note that this weighting is {\em not} cumulative since the imaging weights are
calculated from the specified sigma (expected noise) per visibility
(actually stored in the SIGMA column).

\end{ahdescription}
\begin{ahargs}
\ahaddarg[in]{type}{Type of weighting}{uniform}{String: 'uniform'|'superuniform'|'natural'|'briggs'|'radial'}
\ahaddarg[in]{rmode}{Mode of briggs weighting}{none}{String: 'norm'|'abs'|'none'}
\ahaddarg[in]{noise}{Noise used in absolute briggs weighting}{'0.0Jy'}{Quantity}
\ahaddarg[in]{robust}{Parameter in briggs weighting}{0.0}{Double: range
-2.0 to 2.0}
\ahaddarg[in]{fieldofview}{Field of view for uniform weighting}{'0arcsec'}{Quantity}
\ahaddarg[in]{npixels}{Number of pixels in the u and v directions}{0}{Int}
\ahaddarg[in]{mosaic}{Individually weight the fields of a mosaic}{F}{Bool}
\ahaddarg[in]{async}{Run asynchronously in the background}{!dowait}{Bool}
\end{ahargs}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imgr.weight(type='briggs', rmode='norm', robust=0.5)
\end{verbatim}
\end{ahexample}
\begin{ahcomments}
Applies Briggs (robust) weighting.
\end{ahcomments}
\end{ahfunction}



%


%



%
\end{ahobject}



\begin{ahfunction}{imagermaketestms}{Make a standard MeasurementSet that can be used for experimentation}
\begin{ahdescription}
A standard dataset is converted from a FITS file to 
a MeasurementSet. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{msfile}{Name of output ms}{'3C273XC1.ms'}{String}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
imagermaketestms('MY3C273.ms')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{imagermaketestsdms}{Make a standard single dish MeasurementSet that can be used for experimentation}
\begin{ahdescription}
A standard dataset is converted from a set of GBT fits files
to a MeasurementSet. The dataset used is an
observation of the Cygnus loop at 800MHz using GBT. It
is part of the \aipspp\ distribution.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{msfile}{Name of output ms}{'gbt\_cygnus\_800MHz.ms'}{String}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
imagermaketestsdms('mySD.ms')
\end{verbatim}
\end{ahexample}
\end{ahfunction}


\begin{ahfunction}{imagermaketestmfms}{Make a standard multifield MeasurementSet that can be used for experimentation}
\begin{ahdescription}
A standard multifield dataset is converted from a FITS file to 
a MeasurementSet. The dataset used is a seven field 
VLA D-array observation of CAS A at 8 GHz and
is part of the \aipspp\ distribution.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{msfile}{Name of output ms}{'XCAS.ms'}{String}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
imagermaketestmfms('XCAS.ms')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{imagermaketestcl}{Make a standard componentlist for a standard MeasurementSet}
\begin{ahdescription}
A standard component list is made for the 3C273XC1 data set.
The reference for the component can be specified: the components
will be then converted to this reference (e.g. 'gal') before processing.
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{clfile}{Name of output cl}{'3C273XC1.cl'}{String}
\ahaddarg{refer}{Reference}{'gal'}{String}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
imagermaketestcl('MY3C273.cl', 'gal')
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{imagertest}{Perform a test of imaging from a standard MeasurementSet}
\begin{ahdescription}
Perform a test. The dataset used is an observation of 3C273 at 8GHz
using the C-configuration of the VLA. It is part of the \aipspp\
distribution.

Note that if doshift is set to T then the imaging is done in
Galactic coordinates.

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item A summary of what exists is logged.
\item The data are weighted using the Briggs algorithm.
\item An initial CLEAN-only deconvolution is performed, and then restored.
\item A CLEAN mask is constructed by thresholding $I>0.015$
\item The deconvolution is repeated with 
masks enabled.
\item Residual images are calculated for the North Celestial pole,
on the Sun, and for azimuth elevation (0d, 0d).
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{size}{Number of pixels on a side}{128}{Int}
\ahaddarg{cleanniter}{Number of clean iterations}{1000}{Int}
\ahaddarg{cleangain}{Clean loop gain}{0.1}{Float}
\ahaddarg{doshift}{Shift the phase center}{T}{Bool}
\ahaddarg{doplot}{Plot?}{T}{Bool}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
include 'imager.g'
imagertest(size=256)
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{imagerlongtest}{Perform a long test of imaging from a standard MeasurementSet}
\begin{ahdescription}
Perform a test. The dataset used is an observation of 3C273 at 8GHz
using the C-configuration of the VLA. It is part of the \aipspp\
distribution.

The test is similar to imagertest, except that the various
functions are checked one by one and status reported.
\end{ahdescription}
\begin{ahexample}
\begin{verbatim}
include 'imager.g'
imagerlongtest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{imagermftest}{Perform a test of multi-field processing using a standard MeasurementSet}
\begin{ahdescription}
Perform a test of multi-field processing. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution.

Note that if doshift is set to T then the imaging is done in
Galactic coordinates.

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item The data are weighted using the Briggs algorithm.
\item Two fields are cleaned, one on the core and one on the
jet, using the standard component list.
\item If doplot=T then the visibilities are plotted.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{doplot}{Plot?}{T}{Bool}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
imagermftest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{imagerspectraltest}{Perform a test of spectral processing using a standard spectral line MeasurementSet}
\begin{ahdescription}
Perform a test. The dataset used is an observation of BLLAC
at 110 GHz using the BIMA array. It is part of the \aipspp\
distribution.

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item An CLEAN-only deconvolution is performed, and then restored.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imagerspectraltest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}
%
\begin{ahfunction}{imagerpbtest}{Perform a test of primary beam processing using a standard MeasurementSet}
\begin{ahdescription}
Perform a test of primary processing. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution.

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item A default calibration is applied
\item The data are weighted using the Briggs algorithm.
\item One field is cleaned, using the mf algorithm and the primary
beam is applied both during the subtraction of components (the
major cycle) and in estimating the residuals.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
imagerpbtest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{imagercomponenttest}
{Perform a test of component model processing using a standard MeasurementSet}
\begin{ahdescription}
Perform a test of component model processing. The dataset used is an
observation of 3C273 at 8GHz using the C-configuration of the VLA. It
is part of the \aipspp\ distribution. 

The test does the following:
\begin{itemize}
\item The uvfits file that is to be read in is
in a standard place in the \aipspp\ code source area.
\item The MeasurementSet is read from the uvfits file.
\item A component list is constructed and using in the
subsequent processing. A point component is placed at the
position of the core of 3C273, but specified in Galactic
coordinates.
\item The component model is used in predicting the
model visibilities.
\item A plot of the visibilities is made.
\item The image is cleaned and restored. The center of the image
is shifted to half way down the jet.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{size}{Number of pixels on a side}{128}{Int}
\ahaddarg{doshift}{Shift the phase center}{T}{Bool}
\ahaddarg{doplot}{Plot?}{T}{Bool}
\end{ahargs}
\begin{ahexample}
\begin{verbatim}
imagercomponenttest()
\end{verbatim}
\end{ahexample}
\end{ahfunction}

%\begin{ahfunction}{imagerselfcaltest}
%{Perform a test of selfcal processing using a standard MeasurementSet}
%\begin{ahdescription}
%Perform a test of selfcal model processing. The dataset used is an
%observation of 3C273 at 8GHz using the C-configuration of the VLA. It
%is part of the \aipspp\ distribution. 
%
%The test does the following:
%\begin{itemize}
%\item The uvfits file that is to be read in is
%in a standard place in the \aipspp\ code source area.
%\item The MeasurementSet is read from the uvfits file.
%\item {\tt imager} and \htmlref{calibrater}{calibrater} tools are created.
%\item {\tt imager} is used to clean and restore the image
%\item The clean model is clipped at 750mJy
%\item The selfcal tool function is used to self-calibrate using the
%current model. The Jones matrices are: T, 60s and G, 600s.
%\item The clean and restoration are repeated with the 
%improved calibration.
%\end{itemize}
%\end{ahdescription}
%\ahreturns{Bool}
%\begin{ahargs}
%\ahaddarg{size}{Number of pixels on a side}{128}{Int}
%\ahaddarg{doshift}{Shift the phase center}{T}{Bool}
%\ahaddarg{doplot}{Plot?}{T}{Bool}
%\end{ahargs}
%\begin{ahexample}
%\begin{verbatim}
%imagerselfcaltest()
%\end{verbatim}
%\end{ahexample}
%\end{ahfunction}
%
\begin{ahfunction}{imagersdtest}{Perform a test of single dish imaging from a standard MeasurementSet}
\begin{ahdescription}
Perform a test. The dataset used is an observation of the Cygnus
region at 800 MHz using the GBT. It is part of the \aipspp\
distribution.

The test does the following:
\begin{itemize}
\item The GBT FITS files that are to be read in are
in a standard place in the \aipspp\ data respository.
\item The MeasurementSet is created using the 
\ahlink{gbtmsfiller}{gbtmsfiller}
\item The data are calibrated using 
\ahlink{gbtcal}{gbtcal}.
\item Two images are constructed: the data gridded and the weights
gridded.
\item The \ahlink{image calculator}{imagecalc} is used to normalize
by the weights image.
\end{itemize}
\end{ahdescription}
\ahreturns{Bool}
\begin{ahexample}
\begin{verbatim}
include 'imager.g'
imagersdtest();
\end{verbatim}
\end{ahexample}
\end{ahfunction}

\begin{ahfunction}{imageralltests}
{Perform all imager tests using standard MeasurementSets}
\begin{ahdescription}
All tests are run and the status returned. The complete
suite takes about 500s (real-time) on a Pentium Pro 200MHz.
\end{ahdescription}
\end{ahfunction}


\begin{ahfunction}{imagermultiscale}{Makes multi-resolution multiscale images.}
\begin{ahdescription}
Based on user-specified image sizes and cell sizes, we make several rounds of
multiscale clean images and use each model image as a fisr guess for
successively higher resolution images.  After the first image, each clean
is solving for deltas, and will tend to be neither positive nor negative.

For each round of multiscale cleaning, uniform weighting with a uv taper 
coresponding to 2.5 times the cell size is used.  The number of 
multiscale clean iterations used in each round is given by 
\begin{equation}
niter = nitermult * imsizes[i] ^{niterpower}.
\end{equation}

\end{ahdescription}
\ahreturns{Bool}
\begin{ahargs}
\ahaddarg{msname}{Name of input ms}{''}{String}
\ahaddarg{imsizes}{Image sizes for each round (should be monatonically increasing)}{[128, 256]}{Vector of Ints}
\ahaddarg{cellsizes}{Cell sizes [in arcsec] for each round (should be monatonically decreasing)}{[2, 1]}{Vector of Floats}
\ahaddarg{scales}{Name of input ms}{[0, 5, 15]}{Vector of Ints}
\ahaddarg{nitermult}{Multiplier parameter used to adjust niter with imsizes}{0.15}{Float}
\ahaddarg{niterpower}{Exponent of imsizes used to adjust niter with imsizes}{1.2}{Float}
\ahaddarg{fields}{Vector of field ids to image}{[1]}{Vector of Ints}
\ahaddarg{spwid}{Spectral window to image}{1}{Int}
\ahaddarg{centerfield}{Field id for central pointing}{1}{Int}
\end{ahargs}


\begin{ahexample}
\begin{verbatim}
imagermultiscale(msname='orion.ms', imsizes=[128, 256, 512], cellsizes=[16,8,4], 
scales=[0, 5, 15], nitermult=0.15, niterpower=1.2, fields=[1:4], 
spwid=[1], centerfield=1);
\end{verbatim}
\end{ahexample}
\end{ahfunction}



\input{dragon.help}

\input{imagerwizard.help}

\input{mosaicwizard.help}

\input{vpmanager.help}

\end{ahmodule}

\end{document}
